<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Keramics data format specifications</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="custom.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Keramics data format specifications</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Keramics provides read-only access to a collection of data formats.</p>
<p>This document is intended as a working document of specifications of data
formats used by the Keramics project. These specifications are based on
available documentation and analysis of data samples.</p>
<blockquote>
<p>Note that these might differ from authorative format specifications and are
works in progress.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="storage-media-image-formats"><a class="header" href="#storage-media-image-formats">Storage media image formats</a></h1>
<p>A storage media image format is used to store data from storage media devices
such as a hard disk, a floppy or optical disk like CD-ROM or DVD.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="expert-witness-compression-format-ewf"><a class="header" href="#expert-witness-compression-format-ewf">Expert Witness Compression Format (EWF)</a></h1>
<p>EWF is short for Expert Witness Compression Format. It is a file type used to
store storage media images for digital forensic purposes. It is currently
widely used in the field of computer forensics in proprietary tooling like
EnCase en FTK. The <a href="http://www.asrdata.com/whitepaper-html">original specification</a>
of the format was provided by ASR Data for the SMART application</p>
<p>The EWF format was succeeded by the <a href="ewf2.html">Expert Witness Compression Format version 2</a>
in EnCase 7 (EWF2-Ex01 and EWF2-Lx01). EnCase 7 also uses a different version
of EWF-L01 then its predecessors.</p>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>The Expert Witness Compression Format (EWF) is used to store:</p>
<ul>
<li>storage media images, such as hard disks, USB sticks, optical disks</li>
<li>individual volumes or partitions</li>
<li>"physical" RAM and process memory</li>
</ul>
<p>EWF can store data compressed or uncompressed, in a single image in one or more
segment files. Each segment file consist of a standard header, followed by
multiple sections. A single section cannot span multiple files. Sections are
arranged back-to-back.</p>
<h3 id="terminology"><a class="header" href="#terminology">Terminology</a></h3>
<p>In this document when referred to the EWF format it refers to the original
specification by ASR Data. The newer formats like that of EnCase are deducted
from the original specification and will be referred to as the EWF-E01, because
of the default file extension. Whereas the Logical File Evidence (LVF) format
introduced in EnCase 5, which is also stored in the EWF format will be referred
to as EWF-L01. The SMART format is viewed separately to allow for discussion if
the implementation differs from the specification by ASR Data and will be
referred to as the EWF-S01, because of the default file extension.</p>
<p>All offsets are relative to the beginning of an individual section, unless
otherwise noted. EnCase allows a maximum size of a segment file to be 2000 MiB.
This has to do with the size of the offset of the chunk of media data. This is
a 32 bit value where the most significant bit (MSB) is used as a compression
flag. Therefore the maximum offset size (31 bit) can address about 2048 MiB. In
EnCase 6.7 an addition was made to the table value to provide for a base offset
to allow for segment files greater than 2048 MiB.</p>
<p>A chunk is defined as the sector size (per default 512 bytes) multiplied by the
block size, the number of sectors per chunk (block) (per default 64 sectors).
The data within the EWF format is stored in little-endian. The terms block and
chunk are used intermittently.</p>
<h2 id="segment-file"><a class="header" href="#segment-file">Segment file</a></h2>
<p>EWF stores data in one or more segment files (or segments). Each segment file
consists of:</p>
<ul>
<li>A file header.</li>
<li>One or more sections.</li>
</ul>
<h3 id="file-header"><a class="header" href="#file-header">File header</a></h3>
<p>Each segment file starts with a file header.</p>
<p>EWF defines that the file header consists of 2 parts, namely:</p>
<ul>
<li>a signature part</li>
<li>fields part</li>
</ul>
<h4 id="ewf-ewf-e01-and-smart-ewf-s01"><a class="header" href="#ewf-ewf-e01-and-smart-ewf-s01">EWF, EWF-E01 and SMART (EWF-S01)</a></h4>
<p>The file header, used by both the EWF-E01 and SMART (EWF-S01) formats, is 13
bytes in size and consists of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>8</td><td>"EVF\x09\x0d\x0a\xff\x00"</td><td>Signature</td></tr>
<tr><td>8</td><td>1</td><td>0x01</td><td>Start of fields</td></tr>
<tr><td>9</td><td>2</td><td></td><td>Segment number, which must be 1 or higher</td></tr>
<tr><td>11</td><td>2</td><td>0x0000</td><td>End of fields</td></tr>
</table></div>
<p>The segment number contains a number which refers to the number of the segment
file, starting with 1 for the first file.</p>
<blockquote>
<p>Note this means there could only be a maximum of 65535 (0xffff) files, if it
is an unsigned value.</p>
</blockquote>
<h4 id="ewf-l01"><a class="header" href="#ewf-l01">EWF-L01</a></h4>
<p>The file header, used by the EWF-L01 format, is 13 bytes in size and consists
of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>8</td><td>"LVF\x09\x0d\x0a\xff\x00"</td><td>Signature</td></tr>
<tr><td>8</td><td>1</td><td>0x01</td><td>Start of fields</td></tr>
<tr><td>9</td><td>2</td><td></td><td>Segment number, which must be 1 or higher</td></tr>
<tr><td>11</td><td>2</td><td>0x0000</td><td>End of fields</td></tr>
</table></div>
<p>The segment number contains a number which refers to the number of the segment
file, starting with 1 for the first file.</p>
<blockquote>
<p>Note this means there could only be a maximum of 65535 (0xffff) files, if it
is an unsigned value.</p>
</blockquote>
<h3 id="segment-file-extensions"><a class="header" href="#segment-file-extensions">Segment file extensions</a></h3>
<p>The SMART (EWF-S01) and the EWF-E01 formats use a different naming convention
for the segment files.</p>
<h4 id="smart-ewf-s01"><a class="header" href="#smart-ewf-s01">SMART (EWF-S01)</a></h4>
<p>The SMART (EWF-S01) extension naming has two distinct parts.</p>
<ul>
<li>The first segment file has the extension '.s01'.
<ul>
<li>The next segment file has the extension '.s02.</li>
<li>This will continue up to '.s99'.</li>
</ul>
</li>
<li>After which the next segment file has the extension '.saa'.
<ul>
<li>The next segment file has the extension '.sab'.</li>
<li>This will continue up to '.saz'.</li>
<li>The next segment file has the extension '.sba'.</li>
<li>This will continue up to '.szz'.</li>
<li>The next segment file has the extension '.faa'.</li>
<li>This will continue up to '.zzz'.</li>
<li>Not confirmed but other sources report it will even continue to the use the extensions '.{aa'.</li>
</ul>
</li>
</ul>
<p>Keramics supports extensions up to .zzz</p>
<h4 id="ewf-e01"><a class="header" href="#ewf-e01">EWF-E01</a></h4>
<p>The EWF-E01 extension naming has two distinct parts.</p>
<ul>
<li>The first segment file has the extension '.E01'.
<ul>
<li>The next segment file has the extension '.E02.</li>
<li>This will continue up to '.E99'.</li>
</ul>
</li>
<li>After which the next segment file has the extension '.EAA'.
<ul>
<li>The next segment file has the extension '.EAB'.</li>
<li>This will continue up to '.EAZ'.</li>
<li>The next segment file has the extension '.EBA'.</li>
<li>This will continue up to '.EZZ'.</li>
<li>The next segment file has the extension '.FAA'.</li>
<li>This will continue up to '.ZZZ'.</li>
<li>Not confirmed but other sources report it will even continue to the use the extensions '.[AA'.</li>
</ul>
</li>
</ul>
<p>Keramics supports extensions up to .ZZZ</p>
<h4 id="ewf-l01-1"><a class="header" href="#ewf-l01-1">EWF-L01</a></h4>
<p>The EWF-L01 extension naming has two distinct parts.</p>
<ul>
<li>The first segment file has the extension '.L01'.
<ul>
<li>The next segment file has the extension '.L02.</li>
<li>This will continue up to '.L99'.</li>
</ul>
</li>
<li>After which the next segment file has the extension '.LAA'.
<ul>
<li>The next segment file has the extension '.LAB'.</li>
<li>This will continue up to '.LAZ'.</li>
<li>The next segment file has the extension '.LBA'.</li>
<li>This will continue up to '.LZZ'.</li>
<li>The next segment file has the extension '.MAA'.</li>
<li>This will continue up to '.ZZZ'.</li>
<li>Not confirmed but other sources report it will even continue to the use the extensions '.[AA'.</li>
</ul>
</li>
</ul>
<p>Keramics supports extensions up to .ZZZ</p>
<h3 id="segment-file-set-identifier-guid"><a class="header" href="#segment-file-set-identifier-guid">Segment file set identifier GUID</a></h3>
<p>Segment file sets do not have a strict unique identifier. However the
<a href="ewf.html#volume_section">volume section</a> contains a GUID that can be used for this
purpose. Where:</p>
<ul>
<li>linen 5 to 6 use a time and MAC address based version (1) of the GUID</li>
<li>EnCase 5 to 7 and linen 6 to 7 use a random based version (4) of the GUID</li>
</ul>
<blockquote>
<p>Note that in linen 6 the switch from a version 1 to 4 GUID was somewhere made
between version 6.01 and 6.19.</p>
</blockquote>
<p>See RFC4122 for more information about the different GUID versions.</p>
<h2 id="the-sections"><a class="header" href="#the-sections">The sections</a></h2>
<p>The remainder of the segment file consists of sections. Every section starts
with the same data this will be referred to as the section header. The section
header could also be referred as the section header, but this allows for
unnecessary confusion with the <a href="ewf.html#header_section">header section</a>.</p>
<h3 id="section-header"><a class="header" href="#section-header">Section header</a></h3>
<p>The section header consist of 76 bytes, it contains information about a
specific section.</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>16</td><td></td><td>Section type, a string containing the section type definition, such as "header" or "volume"</td></tr>
<tr><td>16</td><td>8</td><td></td><td>Next section offset, where the offset is relative from the start of the segment file</td></tr>
<tr><td>24</td><td>8</td><td></td><td>Section size</td></tr>
<tr><td>32</td><td>40</td><td>0x00</td><td>Unknown (Padding)</td></tr>
<tr><td>72</td><td>4</td><td></td><td>Checksum, which contains an Adler-32 of all the previous data within the section header.</td></tr>
</table></div>
<p>Some sections contain additional data, refer to paragraph section types for
more information.</p>
<blockquote>
<p>Note Expert Witness 1.35 (for Windows) does not set the section size.</p>
</blockquote>
<blockquote>
<p>Note that in EnCase 2 DOS version the padding itself does not contains 0-byte
values but data, probably the memory is not filled with 0-byte values.</p>
</blockquote>
<h3 id="section-types"><a class="header" href="#section-types">Section types</a></h3>
<p>There are multiple section types. <a href="http://www.asrdata.com/whitepaper-html">ASR Data - E01 Compression Format</a>
defines the following:</p>
<ul>
<li>Header section</li>
<li>Volume section</li>
<li>Table section</li>
<li>Next and Done section</li>
</ul>
<p>The following sections type were found analyzing more recent EnCase files (EWF-E01):</p>
<ul>
<li>Header2 section</li>
<li>Disk section</li>
<li>Sectors section</li>
<li>Table2 section</li>
<li>Data section</li>
<li>Error2 section</li>
<li>Session section</li>
<li>Hash section</li>
<li>Digest section</li>
</ul>
<p>The following sections type were found analyzing more recent EnCase files (EWF-L01):</p>
<ul>
<li>Ltree section</li>
<li>Ltypes section</li>
</ul>
<h3 id="header2-section"><a class="header" href="#header2-section">Header2 section</a></h3>
<p>The header2 section is identified in the section data type field as "header2".
Some aspects of this section are:</p>
<ul>
<li>Found in EWF-E01 in EnCase 4 to 7, and EWF-L01 in EnCase 5 to 7</li>
<li>Found at the start of the first segment file. Not found in subsequent segment files.</li>
<li>The same header2 section is found twice directly after one and other.</li>
</ul>
<p>The additional data this section contains is the following:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>76 (0x4c)</td><td>(variable)</td><td>Information about the acquired media.</td><td></td></tr>
</table></div>
<p>The information about the acquired media consists of <a href="zlib.html">zlib compressed data</a>.
It contains text in UTF16 format specifying information about the acquired
media. The text multiple lines separated by an end of line character(s).</p>
<p>The first 2 bytes of the UTF16 string are the byte order mark (BOM):</p>
<ul>
<li>0xff 0xfe for UTF-16 litte-endian</li>
<li>0xfe 0xff for UTF-16 big-endian</li>
</ul>
<p>In the next paragraphs the various variants of the header2 section are described.</p>
<h4 id="encase-4-ewf-e01"><a class="header" href="#encase-4-ewf-e01">EnCase 4 (EWF-E01)</a></h4>
<p>In EnCase 4 (EWF-E01) the header2 information consist of 5 lines, and contains
the equivalent information as the <a href="ewf.html#header_section">header section</a>.</p>
<div class="table-wrapper"><table><thead><th>Line number</th><th>Value</th><th>Description</th></thead><tr><td>1</td><td>1</td><td>The number of categories provided</td></tr>
<tr><td>2</td><td>main</td><td>The name/type of the category provided</td></tr>
<tr><td>3</td><td></td><td>Identifiers for the values in the 4th line</td></tr>
<tr><td>4</td><td></td><td>The data for the different identifiers in the 3rd line</td></tr>
<tr><td>5</td><td></td><td>(an empty line)</td></tr>
</table></div>
<p>The end of line character(s) is a newline (0x0a).</p>
<blockquote>
<p>Note this end of line character differs from the one used in the <a href="ewf.html#header_section">header section</a>.</p>
</blockquote>
<p>The 3rd and the 4th line consist of the following tab (0x09) separated values.</p>
<div class="table-wrapper"><table><thead><th>Identifier number</th><th>Character in 3rd line</th><th>Value in 4th line</th></thead><tr><td>1</td><td>a</td><td>Unique description</td></tr>
<tr><td>2</td><td>c</td><td>Case number</td></tr>
<tr><td>3</td><td>n</td><td>Evidence number</td></tr>
<tr><td>4</td><td>e</td><td>Examiner name</td></tr>
<tr><td>5</td><td>t</td><td>Notes</td></tr>
<tr><td>6</td><td>av</td><td>Version, which contains the EnCase version used to acquire the media</td></tr>
<tr><td>7</td><td>ov</td><td>Platform, which contains the platform/operating system used to acquire the media</td></tr>
<tr><td>8</td><td>m</td><td>Acquisition date and time</td></tr>
<tr><td>9</td><td>u</td><td>System date and time</td></tr>
<tr><td>10</td><td>p</td><td>Password hash</td></tr>
</table></div>
<p>Also see <a href="ewf.html#header2_values">header2 values</a></p>
<blockquote>
<p>Note the hashing algorithm is the same as for the <a href="ewf.html#header_section">header section</a>.</p>
</blockquote>
<h4 id="encase-5-to-7-ewf-e01"><a class="header" href="#encase-5-to-7-ewf-e01">EnCase 5 to 7 (EWF-E01)</a></h4>
<p>In EnCase 5 to 7 (EWF-E01) the header2 information consist of 17 lines, and
contains:</p>
<div class="table-wrapper"><table><thead><th>Line number</th><th>Value</th><th>Description</th></thead><tr><td>1</td><td>3</td><td>The number of categories provided</td></tr>
<tr><td>2</td><td>main</td><td>The name/type of the category provided</td></tr>
<tr><td>3</td><td></td><td>Identifier for the values in the category</td></tr>
<tr><td>4</td><td></td><td>The data for the different identifiers in the category</td></tr>
<tr><td>5</td><td></td><td>(an empty line)</td></tr>
<tr><td>6</td><td>srce</td><td>The name/type of the category provided, also see <a href="ewf.html#sources_category1">sources category</a></td></tr>
<tr><td>7</td><td></td><td></td></tr>
<tr><td>8</td><td></td><td>Identifier for the values in the category</td></tr>
<tr><td>9</td><td></td><td>The data for the different identifiers in the category</td></tr>
<tr><td>10</td><td></td><td></td></tr>
<tr><td>11</td><td></td><td>(an empty line)</td></tr>
<tr><td>12</td><td>sub</td><td>The name/type of the category provided, also see <a href="ewf.html#subjects_category1">subjects category</a></td></tr>
<tr><td>13</td><td></td><td></td></tr>
<tr><td>14</td><td></td><td>Identifier for the values in the category</td></tr>
<tr><td>15</td><td></td><td>The data for the different identifiers in the category</td></tr>
<tr><td>16</td><td></td><td></td></tr>
<tr><td>17</td><td></td><td>(an empty line)</td></tr>
</table></div>
<p>The end of line character(s) is a newline (0x0a).</p>
<h5 id="main-category"><a class="header" href="#main-category">Main category</a></h5>
<p>The 3rd and the 4th line consist of the following tab (0x09) separated values.</p>
<blockquote>
<p>Note the actual values in this category are dependent on the version of
EnCase.</p>
</blockquote>
<div class="table-wrapper"><table><thead><th>Identifier number</th><th>Character in 3rd line</th><th>Value in 4th line</th></thead><tr><td>1</td><td>a</td><td>Unique description</td></tr>
<tr><td>2</td><td>c</td><td>Case number</td></tr>
<tr><td>3</td><td>n</td><td>Evidence number</td></tr>
<tr><td>4</td><td>e</td><td>Examiner name</td></tr>
<tr><td>5</td><td>t</td><td>Notes</td></tr>
<tr><td>6</td><td>md</td><td>The model of the media, such as hard disk model (introduced in EnCase 6)</td></tr>
<tr><td>7</td><td>sn</td><td>The serial number of media (introduced in EnCase 6)</td></tr>
<tr><td>8</td><td>l</td><td>The device label (introduced in EnCase 6.19)</td></tr>
<tr><td>9</td><td>av</td><td>Version, which contains the EnCase version used to acquire the media. EnCase limits this value to 12 characters</td></tr>
<tr><td>10</td><td>ov</td><td>Platform, which contains the platform/operating system used to acquire the media</td></tr>
<tr><td>11</td><td>m</td><td>Acquisition date and time</td></tr>
<tr><td>12</td><td>u</td><td>System date and time</td></tr>
<tr><td>13</td><td>p</td><td>Password hash</td></tr>
<tr><td>14</td><td>pid</td><td>Process identifier, which contains the identifier of the process memory acquired (introduced in EnCase 6.12/Winen 6.11)</td></tr>
<tr><td>15</td><td>dc</td><td>Unknown</td></tr>
<tr><td>16</td><td>ext</td><td>Extents, which contains the extents of the process memory acquired (introduced in EnCase 6.12/Winen 6.11)</td></tr>
</table></div>
<p>Also see <a href="ewf.html#header2_values">header2 values</a></p>
<blockquote>
<p>Note that both the acquiry and system date and time are empty in a file
created by winen.</p>
</blockquote>
<blockquote>
<p>Note that rhe date values in the <a href="ewf.html#header_section">header section</a> (not the
header2 section) are set to: Thu Jan  1 00:00:00 1970. Where the time is
dependent on the time zone and daylight savings.</p>
</blockquote>
<h5 id="sources-category"><a class="header" href="#sources-category"><a name="sources_category1"></a>Sources category</a></h5>
<p>Line 6 the srce category contains information about acquisition sources.</p>
<p>TODO: describe what a source is in the context of EnCase.</p>
<p>Line 7 consists of 2 values, namely the values are "0 1".</p>
<p>The 8th line consist of the following tab (0x09) separated values. Note that
the actual values in this category are dependent on the version of EnCase.</p>
<div class="table-wrapper"><table><thead><th>Identifier number</th><th>Character in 8rd line</th><th>Meaning</th></thead><tr><td>1</td><td>p</td><td></td></tr>
<tr><td>2</td><td>n</td><td></td></tr>
<tr><td>3</td><td>id</td><td>Identifier, which contains an integer identifying the source</td></tr>
<tr><td>4</td><td>ev</td><td>Evidence number, which contains a string</td></tr>
<tr><td>5</td><td>tb</td><td>Total bytes, which contains an integer</td></tr>
<tr><td>6</td><td>lo</td><td>Logical offset, which contains an integer which is -1 when value is not set</td></tr>
<tr><td>7</td><td>po</td><td>Physical offset, which contains an integer which is -1 when value is not set</td></tr>
<tr><td>8</td><td>ah</td><td>MD5 hash, which contains a string with the MD5 hash of the source</td></tr>
<tr><td>9</td><td>sh</td><td>SHA1 hash, contains a string with the SHA1 hash of the source (introduced in EnCase 6.19)</td></tr>
<tr><td>10</td><td>gu</td><td>Device GUID, which contains a string with a GUID or "0" if not set</td></tr>
<tr><td>11</td><td>pgu</td><td>Primary device GUID, which contains a string with a GUID or "0" if not set (introduced in EnCase 7)</td></tr>
<tr><td>12</td><td>aq</td><td>Acquisition date and time, which contains an integer with a POSIX timestamp</td></tr>
</table></div>
<p>Line 9 consists of 2 values, namely the values are "0 0".</p>
<p>Line 10 contains the values defined by line 8.</p>
<blockquote>
<p>Note the default values of some of these values has changed around EnCase
6.12.</p>
</blockquote>
<p>If the "ha" value contains "00000000000000000000000000000000" this means the
MD5 hash is not set. The same applies for the "sha" value when it contains
"0000000000000000000000000000000000000000" the SHA1 has is not set.</p>
<h5 id="subjects-category"><a class="header" href="#subjects-category"><a name="subjects_category1"></a>Subjects category</a></h5>
<p>Line 12 the sub category contains information about subjects.</p>
<p>TODO: describe what a subject is in the context of EnCase.</p>
<p>Line 13 consists of 2 values, namely the values are "0 1".</p>
<p>The 14th line consist of the following tab (0x09) separated values.</p>
<div class="table-wrapper"><table><thead><th>Identifier number</th><th>Character in 14rd line</th><th>Meaning</th></thead><tr><td>1</td><td>p</td><td></td></tr>
<tr><td>2</td><td>n</td><td></td></tr>
<tr><td>3</td><td>id</td><td>Identifier, which contains an integer identifying the subject</td></tr>
<tr><td>4</td><td>nu</td><td>Unknown (Number)</td></tr>
<tr><td>5</td><td>co</td><td>Unknown (Comment)</td></tr>
<tr><td>6</td><td>gu</td><td>Unknown (GUID)</td></tr>
</table></div>
<p>Line 15 consists of 2 values, namely the values are "0 0".</p>
<p>Line 16 contains the values defined by line 14. Note that the default values of
some of these values has changed around EnCase 6.12.</p>
<h4 id="encase-5-to-7-ewf-l01"><a class="header" href="#encase-5-to-7-ewf-l01">EnCase 5 to 7 (EWF-L01)</a></h4>
<p>The EnCase 5 to 7 (EWF-E01) header2 section specification also applies to the
EnCase 5 to 7 (EWF-L01) format. However:</p>
<ul>
<li>both the acquired and system date and time are not set</li>
</ul>
<h4 id="header2-values"><a class="header" href="#header2-values"><a name="header2_values"></a>Header2 values</a></h4>
<div class="table-wrapper"><table><thead><th>Identifier</th><th>Description</th><th>Notes</th></thead><tr><td>a</td><td>Unique description</td><td>Free form string. Note that EnCase might not respond when this value is large e.g. &gt;= 1 MiB</td></tr>
<tr><td>av</td><td>Version</td><td>Free form string. EnCase limits this string to 12 - 1 characters</td></tr>
<tr><td>c</td><td>Case number</td><td>Free form string. EnCase limits this string to 3000 - 1 characters</td></tr>
<tr><td>dc</td><td>Unknown</td><td></td></tr>
<tr><td>e</td><td>Examiner name</td><td>Free form string. EnCase limits this string to 3000 - 1 characters</td></tr>
<tr><td>ext</td><td>Extents</td><td>Extents header value</td></tr>
<tr><td>l</td><td>Device label</td><td>Free form string</td></tr>
<tr><td>m</td><td>Acquisition date and time</td><td>String containing POSIX 32-bit epoch timestamp, e.g. "1142163845" which represents the date: March 12 2006, 11:44:05</td></tr>
<tr><td>md</td><td>Model</td><td>Free form string. EnCase limits this string to 3000 - 1 characters</td></tr>
<tr><td>n</td><td>Evidence number</td><td>Free form string. EnCase limits this string to 3000 - 1 characters</td></tr>
<tr><td>ov</td><td>Platform</td><td>Free form string. EnCase limits this string to 24 - 1 characters</td></tr>
<tr><td>pid</td><td>Process identifier</td><td>String containing the process identifier (pid) number</td></tr>
<tr><td>p</td><td>Password hash</td><td>String containing the password hash. If no password is set it should be simply the character '0'.</td></tr>
<tr><td>sn</td><td>Serial Number</td><td>Free form string. EnCase limits this string to 3000 - 1 characters</td></tr>
<tr><td>t</td><td>Notes</td><td>Free form string. EnCase limits this string to 3000 - 1 characters</td></tr>
<tr><td>u</td><td>System date and time</td><td>String containing POSIX 32-bit epoch timestamp, e.g. "1142163845" which represents the date: March 12 2006, 11:44:05</td></tr>
</table></div>
<blockquote>
<p>Note the restrictions were tested with EnCase 7.02.01, older versions could
have a restriction of 40 characters instead of 3000 characters.</p>
</blockquote>
<h5 id="extents-header-value"><a class="header" href="#extents-header-value">Extents header value</a></h5>
<p>An extents header value consist of:</p>
<pre><code>number of entries
entries that consist of: S &lt;1&gt; &lt;2&gt; &lt;3&gt;
</code></pre>
<h4 id="header-section"><a class="header" href="#header-section"><a name="header_section"></a>Header section</a></h4>
<p>The header section is identified in the section data type field as "header".
Some aspects of this section are:</p>
<ul>
<li>Defined in <a href="http://www.asrdata.com/whitepaper-html">ASR Data - E01 Compression Format</a></li>
<li>Found in EWF-E01 in EnCase 1 to 7 or linen 5 to 7 or FTK Imager, EWF-L01 in EnCase 5 to 7, and SMART (EWF-S01)</li>
<li>Found at the start of the first segment file or in EnCase 4 to 7 after the header2 section in the first segment file. Not found in subsequent segment files.</li>
</ul>
<p>The additional data this section contains is the following:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Number of bytes</th><th>Description</th></thead><tr><td>76 (0x4c)</td><td>(variable)</td><td>Information about the acquired media.</td></tr>
</table></div>
<p>The information about the acquired media consists of <a href="zlib.html">zlib compressed data</a>.
It contains text in ASCII format specifying information about the acquired
media. The text multiple lines separated by an end of line character(s).</p>
<p>In the next paragraphs the various variants of the header section are
described. In all cases the information consists of at least 4 lines:</p>
<div class="table-wrapper"><table><thead><th>Line number</th><th>Value</th><th>Description</th></thead><tr><td>1</td><td>1</td><td>The number of categories provided</td></tr>
<tr><td>2</td><td>main</td><td>The name/type of the category provided</td></tr>
<tr><td>3</td><td></td><td>Identifiers for the values in the 4th line</td></tr>
<tr><td>4</td><td></td><td>The data for the different identifiers in the 3rd line</td></tr>
</table></div>
<p>An additional 5th line is found in FTK Imager, EnCase 1 to 7 (EWF-E01).</p>
<div class="table-wrapper"><table><thead><th>Line number</th><th>Value</th><th>Description</th></thead><tr><td>5</td><td></td><td>(an empty line)</td></tr>
</table></div>
<h4 id="ewf-format"><a class="header" href="#ewf-format">EWF format</a></h4>
<p>Some aspects of this section are:</p>
<ul>
<li><a href="http://www.asrdata.com/whitepaper-html">ASR Data - E01 Compression Format</a> specifies the end of line character(s) is a newline (0x0a).</li>
</ul>
<p>According to <a href="http://www.asrdata.com/whitepaper-html">ASR Data - E01 Compression Format</a>
the 3rd and the 4th line consist of the following tab (0x09) separated values:</p>
<div class="table-wrapper"><table><thead><th>Identifier number</th><th>Character in 3rd line</th><th>Value in 4th line</th></thead><tr><td>1</td><td>c</td><td>Case number</td></tr>
<tr><td>2</td><td>n</td><td>Evidence number</td></tr>
<tr><td>3</td><td>a</td><td>Unique description</td></tr>
<tr><td>4</td><td>e</td><td>Examiner name</td></tr>
<tr><td>5</td><td>t</td><td>Notes</td></tr>
<tr><td>6</td><td>m</td><td>Acquisition date and time</td></tr>
<tr><td>7</td><td>u</td><td>System date and time</td></tr>
<tr><td>8</td><td>p</td><td>Password hash</td></tr>
<tr><td>9</td><td>r</td><td>Compression level</td></tr>
</table></div>
<p>Also see <a href="ewf.html#header_values">header values</a></p>
<p><a href="http://www.asrdata.com/whitepaper-html">ASR Data - E01 Compression Format</a> states that the Expert Witness Compression uses 'f', fastest compression.</p>
<h4 id="encase-1-ewf-e01"><a class="header" href="#encase-1-ewf-e01">EnCase 1 (EWF-E01)</a></h4>
<p>Some aspects of this section are:</p>
<ul>
<li>The header section is defined only once.</li>
<li>It is the first section of the first segment file. It is not found in subsequent segment files.</li>
<li>The header data itself is compressed using zlib.</li>
<li>The end of line character(s) is a carriage return (0x0d) followed by a newline (0x0a).</li>
</ul>
<p>The 3rd and the 4th line consist of the following tab (0x09) separated values"</p>
<div class="table-wrapper"><table><thead><th>Identifier number</th><th>Character in 3rd line</th><th>Value in 4th line</th></thead><tr><td>1</td><td>c</td><td>Case number</td></tr>
<tr><td>2</td><td>n</td><td>Evidence number</td></tr>
<tr><td>3</td><td>a</td><td>Unique description</td></tr>
<tr><td>4</td><td>e</td><td>Examiner name</td></tr>
<tr><td>5</td><td>t</td><td>Notes</td></tr>
<tr><td>6</td><td>m</td><td>Acquisition date and time</td></tr>
<tr><td>7</td><td>u</td><td>System date and time</td></tr>
<tr><td>8</td><td>p</td><td>Password hash</td></tr>
<tr><td>9</td><td>r</td><td>Compression level</td></tr>
</table></div>
<p>Also see <a href="ewf.html#header_values">header values</a></p>
<h4 id="smart-ewf-s01-1"><a class="header" href="#smart-ewf-s01-1">SMART (EWF-S01)</a></h4>
<p>Some aspects of this section are:</p>
<ul>
<li>The header section is defined once.</li>
<li>It is the first section of the first segment file. It is not found in subsequent segment files.</li>
<li>The header data is always processed by zlib, however the same compression level is used as for the chunks. This could mean compression level 0 which is no compression.</li>
</ul>
<blockquote>
<p>The SMART format uses the FTK Imager (EWF-E01) specification for this section.
Note that this could be something FTK Imager specific.</p>
</blockquote>
<h4 id="encase-2-and-3-ewf-e01"><a class="header" href="#encase-2-and-3-ewf-e01">EnCase 2 and 3 (EWF-E01)</a></h4>
<p>Some aspects of this section are:</p>
<ul>
<li>The same header section defined twice.</li>
<li>It is the first and second section of the first segment file. It is not found in subsequent segment files.</li>
<li>The header data itself is compressed using zlib.</li>
<li>The end of line character(s) is a carriage return (0x0d) followed by a newline (0x0a).</li>
</ul>
<p>The 3rd and the 4th line consist of the following tab (0x09) separated values:</p>
<div class="table-wrapper"><table><thead><th>Identifier number</th><th>Character in 3rd line</th><th>Value in 4th line</th></thead><tr><td>1</td><td>c</td><td>Case number</td></tr>
<tr><td>2</td><td>n</td><td>Evidence number</td></tr>
<tr><td>3</td><td>a</td><td>Unique description</td></tr>
<tr><td>4</td><td>e</td><td>Examiner name</td></tr>
<tr><td>5</td><td>t</td><td>Notes</td></tr>
<tr><td>6</td><td>av</td><td>Version, which contains the EnCase version used to acquire the media</td></tr>
<tr><td>7</td><td>ov</td><td>Platform, which contains the platform/operating system used to acquire the media</td></tr>
<tr><td>8</td><td>m</td><td>Acquisition date and time</td></tr>
<tr><td>9</td><td>u</td><td>System date and time</td></tr>
<tr><td>10</td><td>p</td><td>Password hash</td></tr>
<tr><td>11</td><td>r</td><td>Compression level</td></tr>
</table></div>
<p>Also see <a href="ewf.html#header_values">header values</a></p>
<h4 id="encase-4-to-7-ewf-e01"><a class="header" href="#encase-4-to-7-ewf-e01">EnCase 4 to 7 (EWF-E01)</a></h4>
<p>Some aspects of this section are:</p>
<ul>
<li>The header is defined only once.</li>
<li>It resides after the header2 sections of the first segment file. It is not found in subsequent segment files.</li>
<li>The header data itself is compressed using zlib.</li>
<li>The end of line character(s) is a carriage return (0x0d) followed by a newline (0x0a).</li>
</ul>
<p>The 3rd and the 4th line consist of the following tab (0x09) separated values:</p>
<div class="table-wrapper"><table><thead><th>Identifier number</th><th>Character in 3rd line</th><th>Value in 4th line</th></thead><tr><td>1</td><td>c</td><td>Case number</td></tr>
<tr><td>2</td><td>n</td><td>Evidence number</td></tr>
<tr><td>3</td><td>a</td><td>Unique description</td></tr>
<tr><td>4</td><td>e</td><td>Examiner name</td></tr>
<tr><td>5</td><td>t</td><td>Notes</td></tr>
<tr><td>6</td><td>av</td><td>Version, which contains the EnCase version used to acquire the media</td></tr>
<tr><td>7</td><td>ov</td><td>Platform, which contains the platform/operating system used to acquire the media</td></tr>
<tr><td>8</td><td>m</td><td>Acquisition date and time</td></tr>
<tr><td>9</td><td>u</td><td>System date and time</td></tr>
<tr><td>10</td><td>p</td><td>Password hash</td></tr>
</table></div>
<p>Also see <a href="ewf.html#header_values">header values</a></p>
<h4 id="linen-5-to-7-ewf-e01"><a class="header" href="#linen-5-to-7-ewf-e01">linen 5 to 7 (EWF-E01)</a></h4>
<p>Some aspects of this section are:</p>
<ul>
<li>The same header section defined twice.</li>
<li>It is the first and second section of the first segment file. It is not found in subsequent segment files.</li>
<li>The header data itself is compressed using zlib.</li>
<li>The end of line character(s) is a newline (0x0a).</li>
</ul>
<p>The header information consist of 18 lines</p>
<p>The remainder of the string contains the following information:</p>
<div class="table-wrapper"><table><thead><th>Line number</th><th>Value</th><th>Description</th></thead><tr><td>1</td><td>3</td><td>The number of categories provided</td></tr>
<tr><td>2</td><td>main</td><td>The name/type of the category provided</td></tr>
<tr><td>3</td><td></td><td>Identifier for the values in the 4th line</td></tr>
<tr><td>4</td><td></td><td>The data for the different identifiers in the 3rd line</td></tr>
<tr><td>5</td><td></td><td>(an empty line)</td></tr>
<tr><td>6</td><td>srce</td><td>The name/type of the section provided, also see <a href="ewf.html#sources_category2">Sources category</a></td></tr>
<tr><td>7</td><td></td><td></td></tr>
<tr><td>8</td><td></td><td>Identifier for the values in the section</td></tr>
<tr><td>9</td><td></td><td></td></tr>
<tr><td>10</td><td></td><td></td></tr>
<tr><td>11</td><td></td><td>(an empty line)</td></tr>
<tr><td>12</td><td>sub</td><td>The name/type of the section provided, also see <a href="ewf.html#subjects_category2">Subjects category</a></td></tr>
<tr><td>13</td><td></td><td></td></tr>
<tr><td>14</td><td></td><td>Identifier for the values in the section</td></tr>
<tr><td>15</td><td></td><td></td></tr>
<tr><td>16</td><td></td><td></td></tr>
<tr><td>17</td><td></td><td>(an empty line)</td></tr>
</table></div>
<p>The end of line character(s) is a newline (0x0a).</p>
<h5 id="main-category---linen-5"><a class="header" href="#main-category---linen-5">Main category - linen 5</a></h5>
<p>The 3rd and the 4th line consist of the following tab (0x09) separated values.</p>
<blockquote>
<p>Note the actual values in this category are dependent on the version of linen.</p>
</blockquote>
<div class="table-wrapper"><table><thead><th>Identifier number</th><th>Character in 3rd line</th><th>Value in 4th line</th></thead><tr><td>1</td><td>a</td><td>Unique description</td></tr>
<tr><td>2</td><td>c</td><td>Case number</td></tr>
<tr><td>3</td><td>n</td><td>Evidence number</td></tr>
<tr><td>4</td><td>e</td><td>Examiner name</td></tr>
<tr><td>5</td><td>t</td><td>Notes</td></tr>
<tr><td>6</td><td>av</td><td>Version, which contains the linen version used to acquire the media</td></tr>
<tr><td>7</td><td>ov</td><td>Platform, which contains the platform/operating system used to acquire the media</td></tr>
<tr><td>8</td><td>m</td><td>Acquisition date and time</td></tr>
<tr><td>9</td><td>u</td><td>System date and time</td></tr>
<tr><td>10</td><td>p</td><td>Password hash</td></tr>
</table></div>
<p>Also see <a href="ewf.html#header_values">header values</a></p>
<h5 id="main-category---linen-6-to-7"><a class="header" href="#main-category---linen-6-to-7">Main category - linen 6 to 7</a></h5>
<p>The 3rd and the 4th line consist of the following tab (0x09) separated values.</p>
<blockquote>
<p>Note the actual values in this category are dependent on the version of linen.</p>
</blockquote>
<div class="table-wrapper"><table><thead><th>Identifier number</th><th>Character in 3rd line</th><th>Value in 4th line</th></thead><tr><td>1</td><td>a</td><td>Unique description</td></tr>
<tr><td>2</td><td>c</td><td>Case number</td></tr>
<tr><td>3</td><td>n</td><td>Evidence number</td></tr>
<tr><td>4</td><td>e</td><td>Examiner name</td></tr>
<tr><td>5</td><td>t</td><td>Notes</td></tr>
<tr><td>6</td><td>md</td><td>The model of the media, such as hard disk model (Introduced in linen 6)</td></tr>
<tr><td>7</td><td>sn</td><td>The serial number of media (Introduced in linen 6)</td></tr>
<tr><td>8</td><td>l</td><td>The device label (Introduced in linen 6.19)</td></tr>
<tr><td>9</td><td>av</td><td>Version, which contains the linen version used to acquire the media</td></tr>
<tr><td>10</td><td>ov</td><td>Platform, which contains the platform/operating system used to acquire the media</td></tr>
<tr><td>11</td><td>m</td><td>Acquisition date and time</td></tr>
<tr><td>12</td><td>u</td><td>System date and time</td></tr>
<tr><td>13</td><td>p</td><td>Password hash</td></tr>
<tr><td>14</td><td>pid</td><td>Process identifier, which contains the identifier of the process memory acquired (Introduced in linen 6.19 or earlier)</td></tr>
<tr><td>15</td><td>dc</td><td>Unknown (Introduced in linen 6)</td></tr>
<tr><td>16</td><td>ext</td><td>Extents, which contains the extents of the process memory acquired (Introduced in linen 6.19 or earlier)</td></tr>
</table></div>
<blockquote>
<p>Note as of linen 6.19 the acquire date and time is in UTC and the system date
and time is in local time. Where as before both values were in local time.</p>
</blockquote>
<p>Also see <a href="ewf.html#header_values">header values</a></p>
<h5 id="sources-category-1"><a class="header" href="#sources-category-1"><a name="sources_category2"></a>Sources category</a></h5>
<p>Line 6 the srce category contains information about acquisition sources</p>
<p>TODO: describe what a source is in the context of EnCase.</p>
<p>Line 7 consists of 2 values, namely the values are "0 1".</p>
<p>The 8th line consist of the following tab (0x09) separated values.</p>
<div class="table-wrapper"><table><thead><th>Identifier number</th><th>Character in 8rd line</th><th>Meaning</th></thead><tr><td>1</td><td>p</td><td></td></tr>
<tr><td>2</td><td>n</td><td></td></tr>
<tr><td>3</td><td>id</td><td>Identifier, which contains an integer identifying the source</td></tr>
<tr><td>4</td><td>ev</td><td>Evidence number, which contains a string</td></tr>
<tr><td>5</td><td>tb</td><td>Total bytes, which contains an integer</td></tr>
<tr><td>6</td><td>lo</td><td>Logical offset, which contains an integer which is -1 when value is not set</td></tr>
<tr><td>7</td><td>po</td><td>Physical offset, which contains an integer which is -1 when value is not set</td></tr>
<tr><td>8</td><td>ah</td><td>Unknown (MD5?), which contains a string</td></tr>
<tr><td>9</td><td>sh</td><td>Unknown (SHA1?), which contains a string (Introduced in linen 6.19 or earlier)</td></tr>
<tr><td>10</td><td>gu</td><td>Device GUID, which contains a string with a GUID or "0" if not set</td></tr>
<tr><td>11</td><td>aq</td><td>Acquisition date and time, which contains an integer with a POSIX timestamp</td></tr>
</table></div>
<p>Line 9 consists of 2 values, namely the values are "0 0".</p>
<p>Line 10 contains the values defined by line 8.</p>
<blockquote>
<p>Note the default values of some of these values has changed around linen 6.19
or earlier.</p>
</blockquote>
<h5 id="subjects-category-1"><a class="header" href="#subjects-category-1"><a name="subjects_category2"></a>Subjects category</a></h5>
<p>Line 12 the sub category contains information about subjects.</p>
<p>TODO: describe what a subject is in the context of EnCase.</p>
<p>Line 13 consists of 2 values, namely the values are "0 1".</p>
<p>The 14th line consist of the following tab (0x09) separated values.</p>
<div class="table-wrapper"><table><thead><th>Identifier number</th><th>Character in 14rd line</th><th>Meaning</th></thead><tr><td>1</td><td>p</td><td></td></tr>
<tr><td>2</td><td>n</td><td></td></tr>
<tr><td>3</td><td>id</td><td>Identifier, which contains an integer identifying the subject</td></tr>
<tr><td>4</td><td>nu</td><td>Unknown (Number)</td></tr>
<tr><td>5</td><td>co</td><td>Unknown (Comment)</td></tr>
<tr><td>6</td><td>gu</td><td>Unknown (GUID)</td></tr>
</table></div>
<p>Line 15 consists of 2 values, namely the values are "0 0".</p>
<p>Line 16 contains the values defined by line 14.</p>
<blockquote>
<p>Note the default values of some of these values has changed around linen 6.19
or earlier.</p>
</blockquote>
<h4 id="ftk-imager-ewf-e01"><a class="header" href="#ftk-imager-ewf-e01">FTK Imager (EWF-E01)</a></h4>
<p>Some aspects of this section are:</p>
<ul>
<li>In FTK Imager (EWF-E01) the same header section defined twice.</li>
<li>It is the first and second section of the first segment file. It is not found in subsequent segment files.</li>
<li>The header data itself is compressed using zlib. Note that the compression level can be none and therefore the header looks uncompressed.</li>
<li>In FTK Imager the end of line character(s) is a newline (0x0a).</li>
</ul>
<p>The 3rd and the 4th line consist of the following tab (0x09) separated values:</p>
<div class="table-wrapper"><table><thead><th>Identifier number</th><th>Character in 3rd line</th><th>Value in 4th line</th></thead><tr><td>1</td><td>c</td><td>Case number</td></tr>
<tr><td>2</td><td>n</td><td>Evidence number</td></tr>
<tr><td>3</td><td>a</td><td>Unique description</td></tr>
<tr><td>4</td><td>e</td><td>Examiner name</td></tr>
<tr><td>5</td><td>t</td><td>Notes</td></tr>
<tr><td>6</td><td>av</td><td>Version, which contains the FTK Imager version used to acquire the media</td></tr>
<tr><td>7</td><td>ov</td><td>Platform, which contains the platform/operating system used to acquire the media</td></tr>
<tr><td>8</td><td>m</td><td>Acquisition date and time</td></tr>
<tr><td>9</td><td>u</td><td>System date and time</td></tr>
<tr><td>10</td><td>p</td><td>Password hash</td></tr>
<tr><td>11</td><td>r</td><td>Compression level</td></tr>
</table></div>
<p>Also see <a href="ewf.html#header_values">header values</a></p>
<h4 id="encase-5-to-7-ewf-l01-1"><a class="header" href="#encase-5-to-7-ewf-l01-1">EnCase 5 to 7 (EWF-L01)</a></h4>
<p>The EnCase 4 to 7 (EWF-E01) header section specification is also used for the
EnCase 5 to 7 (EWF-L01) format, with the following aspects:</p>
<ul>
<li>In EnCase 5 both the acquired and system date and time are set to 0.</li>
<li>In EnCase 6 and 7 both the acquired and system date and time are set to Jan 1, 1970 00:00:00 (the time is dependent on the local timezone and daylight savings)</li>
</ul>
<h4 id="header-values"><a class="header" href="#header-values"><a name="header_values"></a>Header values</a></h4>
<div class="table-wrapper"><table><thead><th>Identifier</th><th>Description</th><th>Notes</th></thead><tr><td>a</td><td>Unique description</td><td>Free form string. Note that EnCase might not respond when this value is  large e.g. &gt;= 1 MiB</td></tr>
<tr><td>av</td><td>Version</td><td>Free form string. EnCase limits this string to 12 - 1 characters</td></tr>
<tr><td>c</td><td>Case number</td><td>Free form string. EnCase limits this string to 3000 - 1 characters</td></tr>
<tr><td>dc</td><td>Unknown</td><td></td></tr>
<tr><td>e</td><td>Examiner name</td><td>Free form string. EnCase limits this string to 3000 - 1 characters</td></tr>
<tr><td>ext</td><td>Extents</td><td><a href="ewf.html#extents_header_value">Extents header value</a></td></tr>
<tr><td>l</td><td>Device label</td><td>Free form string</td></tr>
<tr><td>m</td><td>Acquisition date and time</td><td>Contains a <a href="ewf.html#date_time_header_value">date and time header value</a>.</td></tr>
<tr><td>md</td><td>Model</td><td>Free form string. EnCase limits this string to 3000 - 1 characters</td></tr>
<tr><td>n</td><td>Evidence number</td><td>Free form string. EnCase limits this string to 3000 - 1 characters</td></tr>
<tr><td>ov</td><td>Platform</td><td>Free form string. EnCase limits this string to 24 -1 characters</td></tr>
<tr><td>pid</td><td>Process identifier</td><td>String containing the process identifier (pid) number</td></tr>
<tr><td>p</td><td>Password hash</td><td>String containing the password hash. If no password is set it should be simply the character '0'.</td></tr>
<tr><td>r</td><td>Compression level</td><td><a href="ewf.html#compression_header_value">Compression header value</a></td></tr>
<tr><td>sn</td><td>Serial Number</td><td>Free form string. EnCase limits this string to 3000 - 1 characters</td></tr>
<tr><td>t</td><td>Notes</td><td>Free form string. EnCase limits this string to 3000 - 1 characters</td></tr>
<tr><td>u</td><td>Systemdate and time</td><td>Contains a <a href="ewf.html#date_time_header_value">date and time header value</a>.</td></tr>
</table></div>
<blockquote>
<p>Note the restrictions were tested with EnCase 7.02.01, older versions could
have a restriction of 40 characters instead of 3000 characters.</p>
</blockquote>
<h5 id="date-and-time-header-value"><a class="header" href="#date-and-time-header-value"><a name="date_time_header_value"></a>Date and time header value</a></h5>
<p>In EnCase a date and time contains a string of individual values separated by a
space, e.g. "2002 3 4 10 19 59", which represents March 4, 2002 10:19:59.</p>
<p>In linen a date and time contains a string with a POSIX 32-bit epoch timestamp,
e.g. "1142163845" which represents the date: March 12 2006, 11:44:05</p>
<h5 id="extents-header-value-1"><a class="header" href="#extents-header-value-1"><a name="extents_header_value"></a>Extents header value</a></h5>
<p>An extents header value consist of:</p>
<pre><code>number of entries
entries that consist of: S &lt;1&gt; &lt;2&gt; &lt;3&gt;
</code></pre>
<h5 id="compression-header-value"><a class="header" href="#compression-header-value"><a name="compression_header_value"></a>Compression header value</a></h5>
<p>A compression header value consist of a single character that represent the
compression level.</p>
<div class="table-wrapper"><table><thead><th>Character value</th><th>Meaning</th></thead><tr><td>b</td><td>Best compression is used</td></tr>
<tr><td>f</td><td>Fastest compression is used</td></tr>
<tr><td>n</td><td>No compression is used</td></tr>
</table></div>
<h5 id="notes"><a class="header" href="#notes">Notes</a></h5>
<p>There should not be a tab, carriage return and newline characters within the
text in the 4th line. Or is there a method to escape these characters?</p>
<p><a href="http://www.asrdata.com/whitepaper-html">ASR Data - E01 Compression Format</a>
states that these characters should not be used in the free form text. Need to
confirm this, the specification only speaks of a newline character.</p>
<p>Currently the password has no a additional value than allow an application
check it. The data itself is not protected using the password. The password
hashing algorithm is unknown. Need to find out. And does the algorithm differ
per EnCase version? probably not. The algorithm does not differ in EnCase
1 to 7. FTK Imager does not bother with a password.</p>
<h3 id="volume-section"><a class="header" href="#volume-section"><a name="volume_section"></a>Volume section</a></h3>
<p>The volume section is identified in the section data type field as "volume".
Some aspects of this section are:</p>
<ul>
<li>Defined in <a href="http://www.asrdata.com/whitepaper-html">ASR Data - E01 Compression Format</a></li>
<li>Found in EWF-E01 in EnCase 1 to 7 or linen 5 to 7 or FTK Imager, EWF-L01 in EnCase 5 to 7, and SMART (EWF-S01)</li>
<li>Found after the header section of the first segment file. Not found in subsequent segment files.</li>
</ul>
<p>In the next paragraphs the various versions of the volume section are described.</p>
<h4 id="ewf-specification"><a class="header" href="#ewf-specification">EWF specification</a></h4>
<p>The specification according to <a href="http://www.asrdata.com/whitepaper-html">ASR Data - E01 Compression Format</a>.</p>
<p>The volume section data is 94 bytes in size and consists of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>4</td><td>0x01</td><td>Unknown (Reserved)</td></tr>
<tr><td>4</td><td>4</td><td></td><td>The number of chunks within the all segment files.</td></tr>
<tr><td>8</td><td>4</td><td></td><td>The number of sectors per chunk, which contains 64 per default.</td></tr>
<tr><td>12</td><td>4</td><td></td><td>The number of bytes per sectors, which contains 512 per default</td></tr>
<tr><td>16</td><td>4</td><td></td><td>The sectors count, the number of sectors within all segment files</td></tr>
<tr><td>20</td><td>20</td><td>0x00</td><td>Unknown (Reserved)</td></tr>
<tr><td>40</td><td>45</td><td>0x00</td><td>Unknown (Padding)</td></tr>
<tr><td>85</td><td>5</td><td></td><td>Signature, which contains the EWF file header signature</td></tr>
<tr><td>90</td><td>4</td><td></td><td>Checksum, which contains an Adler-32 of all the previous data within the volume section data.</td></tr>
</table></div>
<p>The number of chunks is a 32-bit value this means it maximum of addressable
chunks would be: 4294967295 (= 2^32 - 1). For a chunk size of 32768 x 4294967295 = about 127 TiB.
The maximum segment file amount is 2^16 - 1 = 65535. This allows for an equal
number of storage if a segment file is filled to its maximum number of chunks.</p>
<p>However Keramics is restricted at 14295 segment files, due to the extension
naming schema of the segment files.</p>
<h4 id="smart-ewf-s01-2"><a class="header" href="#smart-ewf-s01-2">SMART (EWF-S01)</a></h4>
<p>The SMART format uses the EWF specification for this section.</p>
<p>In SMART the signature (reverse) value is the string "SMART" (0x53 0x4d 0x41
0x52 0x54) instead of the file header signature.</p>
<h4 id="ftk-imager-encase-1-to-7-and-linen-5-to-7-ewf-e01"><a class="header" href="#ftk-imager-encase-1-to-7-and-linen-5-to-7-ewf-e01">FTK Imager, EnCase 1 to 7 and linen 5 to 7 (EWF-E01)</a></h4>
<p>The specification for FTK Imager, EnCase 1 to 7 and linen 5 to 7.</p>
<p>The volume section data is 1052 bytes in size and consists of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>1</td><td></td><td><a href="ewf.html#media_type">Media type</a></td></tr>
<tr><td>1</td><td>3</td><td>0x00</td><td>Unknown (empty values)</td></tr>
<tr><td>4</td><td>4</td><td></td><td>The number of chunks within the all segment files.</td></tr>
<tr><td>8</td><td>4</td><td></td><td>The number of sectors per chunk (or block size), which contains 64 per default. EnCase 5 is the first version which allows this value to be different than 64.</td></tr>
<tr><td>12</td><td>4</td><td></td><td>The number of bytes per sector</td></tr>
<tr><td>16</td><td>8</td><td></td><td>The sectors count, which contains the number of sectors within all segment files. This value probably has been changed in EnCase 6 from a 32-bit value to a 64-bit value to support media &gt;2TiB</td></tr>
<tr><td>24</td><td>4</td><td></td><td>The number of cylinders of the C:H:S value, which most of the time this value is empty (0x00)</td></tr>
<tr><td>28</td><td>4</td><td></td><td>The number of heads of the C:H:S value, which most of the time this value is empty (0x00)</td></tr>
<tr><td>32</td><td>4</td><td></td><td>The number of sectors of the C:H:S value, which most of the time this value is empty (0x00)</td></tr>
<tr><td>36</td><td>1</td><td></td><td><a href="ewf.html#media_flags">Media flags</a></td></tr>
<tr><td>37</td><td>3</td><td>0x00</td><td>Unknown (empty values)</td></tr>
<tr><td>40</td><td>4</td><td></td><td>PALM volume start sector</td></tr>
<tr><td>44</td><td>4</td><td>0x00</td><td>Unknown (empty values)</td></tr>
<tr><td>48</td><td>4</td><td></td><td>SMART logs start sector, which contains an offset relative from the end of media, e.g. a value of 10 would refer to sector = number of sectors - 10</td></tr>
<tr><td>52</td><td>1</td><td></td><td><a href="ewf.html#compression_level">Compression level</a> (Introduced in EnCase 5)</td></tr>
<tr><td>53</td><td>3</td><td>0x00</td><td>Unknown (empty values, these values seem to be part of the compression level)</td></tr>
<tr><td>56</td><td>4</td><td></td><td>The sector error granularity, which contains the error block size (Introduced in EnCase 5)</td></tr>
<tr><td>60</td><td>4</td><td>0x00</td><td>Unknown (empty values)</td></tr>
<tr><td>64</td><td>16</td><td></td><td>Segment file set identifier, which contains a GUID/UUID generated on the acquiry system probably used to uniquely identify a set of segment files (Introduced in EnCase 5)</td></tr>
<tr><td>80</td><td>963</td><td>0x00</td><td>Unknown (empty values)</td></tr>
<tr><td>1043</td><td>5</td><td>0x00</td><td>Unknown (Signature)</td></tr>
<tr><td>1048</td><td>4</td><td></td><td>Checksum, which contains an Adler-32 of all the previous data within the volume section data.</td></tr>
</table></div>
<p>TODO: a value that could be in the volume is the RAID stripe size</p>
<blockquote>
<p>Note that EnCase requires for media that contains no partition table that the
is physical media flag is not set and vice versa. Other tools like FTK check
the actual storage media data.</p>
</blockquote>
<h4 id="encase-5-to-7-ewf-l01-2"><a class="header" href="#encase-5-to-7-ewf-l01-2">EnCase 5 to 7 (EWF-L01)</a></h4>
<p>The EWF-L01 format uses the EnCase 5 (EWF-E01) volume section specification. However:</p>
<ul>
<li>the volume type contains 0x0e</li>
<li>the number of chunks is 0</li>
<li>the number of bytes per sectors is some kind of block size value (4096), perhaps the source file system block size</li>
<li>the sectors count, represents some other value because ( sector_size x sector_amount != total_size ). The total size is in the ltree section.</li>
</ul>
<h4 id="media-type"><a class="header" href="#media-type"><a name="media_type"></a>Media type</a></h4>
<div class="table-wrapper"><table><thead><th>Value</th><th>Identifier</th><th>Description</th></thead><tr><td>0x00</td><td></td><td>A removable storage media device</td></tr>
<tr><td>0x01</td><td></td><td>A fixed storage media device</td></tr>
<tr><td></td><td></td><td></td></tr>
<tr><td>0x03</td><td></td><td>An optical disc (CD/DVD/BD)</td></tr>
<tr><td></td><td></td><td></td></tr>
<tr><td>0x0e</td><td></td><td>Logical Evidence (LEF or L01)</td></tr>
<tr><td></td><td></td><td></td></tr>
<tr><td>0x10</td><td></td><td>Physical Memory (RAM) or process memory</td></tr>
</table></div>
<blockquote>
<p>Note that FTK imager versions, before version 2.9, set the storage media to
fixed (0x01). The exact version of FTK imager where this behavior changed is
unknown.</p>
</blockquote>
<h4 id="media-flags"><a class="header" href="#media-flags"><a name="media_flags"></a>Media flags</a></h4>
<div class="table-wrapper"><table><thead><th>Value</th><th>Identifier</th><th>Description</th></thead><tr><td>0x01</td><td></td><td>Is an image file. In FTK Imager, EnCase 1 to 7 this bit is always set, when not set EnCase seems to see the image file as a device</td></tr>
<tr><td>0x02</td><td></td><td>Is physical device or device type, where 0 represents a non physical device (logical) and 1 represents a physical device</td></tr>
<tr><td>0x04</td><td></td><td>Fastbloc write blocker used</td></tr>
<tr><td>0x08</td><td></td><td>Tableau write blocker used. This was added in EnCase 6.13</td></tr>
</table></div>
<blockquote>
<p>Note that if both the the Fastbloc and Tableau write blocker media flags are
set EnCase only shows the Fastbloc.</p>
</blockquote>
<h4 id="compression-level"><a class="header" href="#compression-level"><a name="compression_level"></a>Compression level</a></h4>
<div class="table-wrapper"><table><thead><th>Value</th><th>Identifier</th><th>Description</th></thead><tr><td>0x00</td><td></td><td>no compression</td></tr>
<tr><td>0x01</td><td></td><td>good compression</td></tr>
<tr><td>0x02</td><td></td><td>best compression</td></tr>
</table></div>
<blockquote>
<p>Note that EnCase 7 no longer provides the fast and best compression options.</p>
</blockquote>
<h3 id="disk-section"><a class="header" href="#disk-section">Disk section</a></h3>
<p>The disk section is identified in the section data type field as "disk". Some
aspects of this section are:</p>
<ul>
<li>Not defined in <a href="http://www.asrdata.com/whitepaper-html">ASR Data - E01 Compression Format</a>.</li>
<li>Not found in SMART (EWF-S01).</li>
</ul>
<p>With a disk section in an FTK Imager 2.3 (EWF-E01) image it was confirmed that
the disk section is the same as the volume section.</p>
<blockquote>
<p>Note that the disk section was found only in FTK Imager 2.3 when acquiring a
physical disk not a floppy. This requires additional research, it is currently
assumed that the disk section some old method to differentiate between a
partition (volume) image or a physical disk image.</p>
</blockquote>
<h3 id="data-section"><a class="header" href="#data-section">Data section</a></h3>
<p>The data section is identified in the section data type field as "data". Some
aspects of this section are:</p>
<ul>
<li>Not defined in <a href="http://www.asrdata.com/whitepaper-html">ASR Data - E01 Compression Format</a>.</li>
<li>Found in EWF-E01 in EnCase 1 to 7 or linen 5 to 7 or FTK Imager, and EWF-L01 in EnCase 5 to 7. Not found in SMART (EWF-S01).</li>
<li>For multiple segment files it does not reside in the first segment file. For a single segment file it does.</li>
<li>Found after the last table2 section in a single segment file or for multiple segment files at the start of the segment files, except for the first.</li>
<li>The data section has data it should should contain the same information as the volume section.</li>
</ul>
<p>The data section is a copy of the <a href="ewf.html#volume_section">volume section</a>.</p>
<h4 id="ftk-imager-encase-1-to-7-and-linen-5-to-7-ewf-e01-1"><a class="header" href="#ftk-imager-encase-1-to-7-and-linen-5-to-7-ewf-e01-1">FTK Imager, EnCase 1 to 7 and linen 5 to 7 (EWF-E01)</a></h4>
<blockquote>
<p>Note that in Logicube products (Talon (firmware predating April 2013) and
Forensic dossier (before version 3.3.3RC16)) the checksum is not calculated
and set to 0.</p>
</blockquote>
<h3 id="sectors-section"><a class="header" href="#sectors-section">Sectors section</a></h3>
<p>The sectors section is identified in the section data type field as "sectors".
Some aspects of this section are:</p>
<ul>
<li>Not defined in <a href="http://www.asrdata.com/whitepaper-html">ASR Data - E01 Compression Format</a>.</li>
<li>Found in EWF-E01 in EnCase 2 to 7, or linen 5 to 7 or FTK Imager, EWF-L01 in EnCase 5 to 7. Not found in EnCase 1 (EWF-E01) or SMART (EWF-S01).</li>
<li>The first sectors section can be found after the volume section in the first segment file or at the after the data section in subsequent segment files. Successive sector data sections are found after the sector table2 section.</li>
</ul>
<p>The sectors section contains the actual chunks of media data.</p>
<ul>
<li>The sectors section can contain multiple chunks.</li>
<li>The default size of a chunk is 32768 bytes of data (64 standard sectors, with a size of 512 bytes per sector). It is possible in EnCase 5 and 6 and linen 5 and 6 to change the number of sectors per block to 64, 128, 256, 1024, 2048, 4096, 8192, 16384 or 32768. In EnCase 7 and linen 7 this has been reduced to 64, 128, 256, 1024.</li>
</ul>
<h4 id="data-chunk"><a class="header" href="#data-chunk">Data chunk</a></h4>
<p>The first chunk is often located directly after the section header, although
the format does not require this.</p>
<p>When the data is compressed and the compressed data (with checksum) is larger
than the uncompressed data (without the checksum) the data chunk is stored
uncompressed. The default size of a chunk is 32768 bytes of data (64 standard
sectors).</p>
<p>An uncompressed data chunk is of variable size and consists of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>...</td><td></td><td>Uncompressed chunk data</td></tr>
<tr><td>...</td><td>4</td><td></td><td>Checksum, which contains an Adler-32 of the chunk data</td></tr>
</table></div>
<p>The compressed data chunk consist of <a href="zlib.html">zlib compressed data</a>. The
checksum of the compressed data chunk is part the zlib compressed data format.</p>
<h4 id="optical-disc-images"><a class="header" href="#optical-disc-images">Optical disc images</a></h4>
<p>For a MODE‑1 CD-ROM optical disc image EnCase only seems to support 2048 bytes
per sector (the data).</p>
<p>The raw sector size of a MODE-1 CD-ROM is 2352 bytes in size and consists of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>16</td><td></td><td>Synchronization bytes</td></tr>
<tr><td>16</td><td>2048</td><td></td><td>Data</td></tr>
<tr><td>2054</td><td>4</td><td></td><td>Error detection</td></tr>
<tr><td>2058</td><td>8</td><td>0x00</td><td>Unknown (Empty values)</td></tr>
<tr><td>2066</td><td>276</td><td></td><td>Error correction</td></tr>
</table></div>
<p>TODO: add information about Mode-2 and Mode-XA</p>
<h3 id="table-section"><a class="header" href="#table-section">Table section</a></h3>
<p>The table section is identified in the section data type field as "table". Some
aspects of this section are:</p>
<ul>
<li>Defined in <a href="http://www.asrdata.com/whitepaper-html">ASR Data - E01 Compression Format</a>.</li>
<li>Found in EWF-E01 in EnCase 1 to 7 or linen 5 to 7 or FTK Imager, EWF-L01 in EnCase 5 to 7, and SMART (EWF-S01)</li>
</ul>
<blockquote>
<p>Note that the offsets within the section header are 8 bytes (64 bits) of
size while the offsets in the table entry array are 4 bytes (32 bits) in size.</p>
</blockquote>
<p>In the next paragraphs the various versions of the table section are described.</p>
<h4 id="ewf-specification-1"><a class="header" href="#ewf-specification-1">EWF specification</a></h4>
<p>Some aspects of the table section according to the EWF specification are:</p>
<ul>
<li>The first table section resides after the volume section in the first segment file or after the file header in subsequent segment files.</li>
<li>It can be found in every segment file.</li>
</ul>
<p>The table section consists of:</p>
<ul>
<li>the table header</li>
<li>an array of table entries</li>
<li>the data chunks</li>
</ul>
<h5 id="table-header"><a class="header" href="#table-header">Table header</a></h5>
<p>The table header is 24 bytes in size and consists of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>4</td><td></td><td>The number of entries</td></tr>
<tr><td>4</td><td>16</td><td>0x00</td><td>Unknown (Padding)</td></tr>
<tr><td>20</td><td>4</td><td></td><td>Checksum, which contains an Adler-32 of all the previous data within the table header data.</td></tr>
</table></div>
<p>According to <a href="http://www.asrdata.com/whitepaper-html">ASR Data - E01 Compression Format</a></p>
<ul>
<li>the number of entries, contains 0x01</li>
<li>the table can hold 16375 entries if more entries are required an additional table section should be created.</li>
</ul>
<h5 id="table-entry"><a class="header" href="#table-entry">Table entry</a></h5>
<p>The table entry is 4 bytes in size and consists of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>4</td><td></td><td>Chunk data offset</td></tr>
</table></div>
<p>The most significant bit (MSB) in the chunk data offset indicates if the chunk
is compressed (1) or uncompressed (0).</p>
<p>A chunk data offset points to the start of the chunk of media data, which
resides in the same table section within the segment file. The offset contains
a value relative to the start of the file.</p>
<h5 id="data-chunk-1"><a class="header" href="#data-chunk-1">Data chunk</a></h5>
<p>The first chunk is often located directly after the last table entry, although
the format does not require this.</p>
<p>A data chunk is always compressed even when no compression is required. This
approach provides a checksum for each chunk. The default size of a chunk is
32768 bytes of data (64 standard sectors). The resulting size of the
"compressed" chunk can therefore be larger than the default chunk size.</p>
<blockquote>
<p>Note that this was deducted from the behavior of FTK Imager for SMART (EWF-S01).</p>
</blockquote>
<p>The compressed data chunk consist of <a href="zlib.html">zlib compressed data</a>. The
checksum of the compressed data chunk is part the zlib compressed data format.</p>
<h4 id="smart-ewf-s01-3"><a class="header" href="#smart-ewf-s01-3">SMART (EWF-S01)</a></h4>
<p>The table section in the SMART (EWF-S01) format is equivalent to that of the
EWF specification.</p>
<h4 id="encase-1-ewf-e01-1"><a class="header" href="#encase-1-ewf-e01-1">EnCase 1 (EWF-E01)</a></h4>
<p>Some aspects of this section are:</p>
<ul>
<li>The table section resides after the volume section in the first segment file or after the file header in subsequent segment files.</li>
<li>It can be found in every segment file.</li>
</ul>
<p>The table section consists of:</p>
<ul>
<li>the table header</li>
<li>an array of table entries</li>
<li>the table footer</li>
<li>the data chunks</li>
</ul>
<h5 id="table-header-1"><a class="header" href="#table-header-1">Table header</a></h5>
<p>The table header is 24 bytes in size and consists of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>4</td><td></td><td>The number of entries</td></tr>
<tr><td>4</td><td>16</td><td>0x00</td><td>Unknown (Padding)</td></tr>
<tr><td>20</td><td>4</td><td></td><td>Checksum, which contains an Adler-32 of all the previous data within the table header data.</td></tr>
</table></div>
<p>The table can hold 16375 entries if more entries are required an additional table section should be created.</p>
<h5 id="table-entry-1"><a class="header" href="#table-entry-1">Table entry</a></h5>
<p>The table entry is 4 bytes in size and consists of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>4</td><td></td><td>Chunk data offset</td></tr>
</table></div>
<p>The most significant bit (MSB) in the chunk data offset indicates if the chunk
is compressed (1) or uncompressed (0).</p>
<p>A chunk data offset points to the start of the chunk of media data, which
resides in the same table section within the segment file. The offset contains
a value relative to the start of the file.</p>
<h5 id="table-footer"><a class="header" href="#table-footer">Table footer</a></h5>
<p>The table footer is 4 bytes in size and consists of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>4</td><td></td><td>Checksum, which contains an Adler-32 of the offset array</td></tr>
</table></div>
<h5 id="data-chunk-2"><a class="header" href="#data-chunk-2">Data chunk</a></h5>
<p>The first chunk is often located directly after the table footer, although the
format does not require this.</p>
<p>When the data is compressed and the compressed data (with checksum) is larger
than the uncompressed data (without the checksum) the data chunk is stored
uncompressed. The default size of a chunk is 32768 bytes of data (64 standard
sectors).</p>
<p>An uncompressed data chunk is of variable size and consists of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>...</td><td></td><td>Uncompressed chunk data</td></tr>
<tr><td>...</td><td>4</td><td></td><td>Checksum, which contains an Adler-32 of the chunk data</td></tr>
</table></div>
<p>The compressed data chunk consist of <a href="zlib.html">zlib compressed data</a>. The
checksum of the compressed data chunk is part the zlib compressed data format.</p>
<h4 id="ftk-imager-and-encase-2-to-5-and-linen-5-ewf-e01"><a class="header" href="#ftk-imager-and-encase-2-to-5-and-linen-5-ewf-e01">FTK Imager and EnCase 2 to 5 and linen 5 (EWF-E01)</a></h4>
<p>Some aspects of this section are:</p>
<ul>
<li>The table section resides after the sectors section.</li>
<li>It can be found in every segment file.</li>
<li>The data chunks are no longer stored in this section but in the sectors section instead.</li>
<li>The table2 section contains a mirror copy of the table section. In EWF-E01 it is always present.</li>
</ul>
<p>The table section consists of:</p>
<ul>
<li>the table header</li>
<li>an array of table entries</li>
<li>the table footer</li>
</ul>
<h5 id="table-header-2"><a class="header" href="#table-header-2">Table header</a></h5>
<p>The sector table header is 24 bytes in size and consists of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>4</td><td></td><td>The number of entries</td></tr>
<tr><td>4</td><td>16</td><td>0x00</td><td>Unknown (Padding)</td></tr>
<tr><td>20</td><td>4</td><td></td><td>Checksum, which contains an Adler-32 of all the previous data within the table header data.</td></tr>
</table></div>
<p>The table section can hold 16375 entries. A new table section should be created
to hold more entries. Both FTK Imager and EnCase 5 can handle more than 16375,
FTK 1 cannot. To contain more than 16375 chunks new sectors, table and table2
sections need to be created after the table2 section.</p>
<h5 id="table-entry-2"><a class="header" href="#table-entry-2">Table entry</a></h5>
<p>The table entry is 4 bytes in size and consists of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>4</td><td></td><td>Chunk data offset</td></tr>
</table></div>
<p>The most significant bit (MSB) in the chunk data offset indicates if the chunk
is compressed (1) or uncompressed (0).</p>
<p>A chunk data offset points to the start of the chunk of media data, which
resides in the preceding sectors section within the segment file. The offset
contains a value relative to the start of the file.</p>
<h5 id="table-footer-1"><a class="header" href="#table-footer-1">Table footer</a></h5>
<p>The table footer is 4 bytes in size and consists of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>4</td><td></td><td>Checksum, which contains an Adler-32 of the offset array</td></tr>
</table></div>
<h4 id="encase-6-to-7-and-linen-6-to-7-ewf-e01"><a class="header" href="#encase-6-to-7-and-linen-6-to-7-ewf-e01">EnCase 6 to 7 and linen 6 to 7 (EWF-E01)</a></h4>
<p>Some aspects of this section are:</p>
<ul>
<li>Every segment file contains its own table section.</li>
<li>It resides after the sectors section.</li>
<li>The data chunks are no longer stored in this section but in the sectors section instead.</li>
<li>The table2 section contains a mirror copy of the table section. In EWF-E01 it is always present.</li>
</ul>
<p>The table section consists of:</p>
<ul>
<li>the table header</li>
<li>an array of table entries</li>
<li>the table footer</li>
</ul>
<h5 id="table-header-3"><a class="header" href="#table-header-3">Table header</a></h5>
<p>The sector table header is 24 bytes in size and consists of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>4</td><td></td><td>The number of entries</td></tr>
<tr><td>4</td><td>4</td><td>0x00</td><td>Unknown (Padding)</td></tr>
<tr><td>8</td><td>8</td><td></td><td>The table base offset</td></tr>
<tr><td>16</td><td>4</td><td>0x00</td><td>Unknown (Padding)</td></tr>
<tr><td>20</td><td>4</td><td></td><td>Checksum, which contains an Adler-32 of all the previous data within the table header data.</td></tr>
</table></div>
<p>As of EnCase 6 the number of entries is no longer restricted to 16375 entries.
The new limit seems to be 65534.</p>
<h5 id="table-entry-3"><a class="header" href="#table-entry-3">Table entry</a></h5>
<p>The table entry is 4 bytes in size and consists of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>4</td><td></td><td>Chunk data offset</td></tr>
</table></div>
<p>The most significant bit (MSB) in the chunk data offset indicates if the chunk
is compressed (1) or uncompressed (0).</p>
<p>A chunk data offset points to the start of the chunk of media data, which
resides in the preceding sectors section within the segment file. The offset
contains a value relative to the table base offset.</p>
<p>In EnCase 6.7.1 the sectors section can be larger than 2048Mb. The table
entries offsets are 31 bit values in EnCase6 the offset in a table entry value
will actually use <em>the full 32 bit</em> if the 2048Mb has been exceeded. This
behavior is no longer present in EnCase 6.8 so it is assumed to be a bug.
Libewf currently assumes that the if the 31 bit value overflows the following
chunks are uncompressed. This allows EnCase 6.7.1 faulty EWF files to be
converted by Keramics.</p>
<h5 id="table-footer-2"><a class="header" href="#table-footer-2">Table footer</a></h5>
<p>The table footer is 4 bytes in size and consists of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>4</td><td></td><td>Checksum, which contains an Adler-32 of the offset array</td></tr>
</table></div>
<h4 id="encase-6-to-7-ewf-l01"><a class="header" href="#encase-6-to-7-ewf-l01">EnCase 6 to 7 (EWF-L01)</a></h4>
<p>The EWF-L01 format uses the EnCase 6 to 7 (EWF-E01) table section specification.</p>
<h3 id="table2-section"><a class="header" href="#table2-section">Table2 section</a></h3>
<p>The table2 section is identified in the section data type field as "table2".
Some aspects of this section are:</p>
<ul>
<li>Not defined in <a href="http://www.asrdata.com/whitepaper-html">ASR Data - E01 Compression Format</a>.</li>
<li>Found in EWF-E01 in EnCase 2 to 7, or linen 5 to 7 or FTK Imager, EWF-L01 in EnCase 5 to 7. Not found in EnCase 1 (EWF-E01) or SMART (EWF-S01).</li>
<li>Uses the same format as the table section.</li>
<li>Resides directly after the table section.</li>
</ul>
<h4 id="ftk-imager-and-encase-2-to-7-and-linen-5-to-7-ewf-e01"><a class="header" href="#ftk-imager-and-encase-2-to-7-and-linen-5-to-7-ewf-e01">FTK Imager and EnCase 2 to 7 and linen 5 to 7 (EWF-E01)</a></h4>
<p>The table2 section contains a mirror copy of the table section. Probably
intended for recovery purposes.</p>
<h4 id="encase-5-to-7-ewf-l01-3"><a class="header" href="#encase-5-to-7-ewf-l01-3">EnCase 5 to 7 (EWF-L01)</a></h4>
<p>The EWF-L01 format uses the EWF-E01 table2 section specification.</p>
<h3 id="next-section"><a class="header" href="#next-section">Next section</a></h3>
<p>The next section is identified in the section data type field as "next". Some
aspects of this section are:</p>
<ul>
<li>Defined in <a href="http://www.asrdata.com/whitepaper-html">ASR Data - E01 Compression Format</a>.</li>
<li>Found in EWF-E01 in EnCase 1 to 7 or linen 5 to 7 or FTK Imager, EWF-L01 in EnCase 5 to 7, and SMART (EWF-S01)</li>
<li>The last section within a segment other than the last segment file.</li>
<li>The offset to the next section in the section header of the next section point to itself (the start of the next section).</li>
<li>It should be the last section in a segment file, other than the last segment file.</li>
</ul>
<h4 id="smart-ewf-s01-4"><a class="header" href="#smart-ewf-s01-4">SMART (EWF-S01)</a></h4>
<p>It resides after the table or table2 section.</p>
<h4 id="ftk-imager-encase-and-linen-ewf-e01"><a class="header" href="#ftk-imager-encase-and-linen-ewf-e01">FTK Imager, EnCase and linen (EWF-E01)</a></h4>
<p>It resides after the data section in a single segment file or for multiple
segment files after the table2 section.</p>
<p>In the EnCase (EWF-E01) format the size in the section header is 0 instead of
76 (the size of the section header).</p>
<blockquote>
<p>Note that FTK imager versions before 2.9 sets the section size to 76. At the
moment it is unknown in which version this behavior was changed.</p>
</blockquote>
<h3 id="ltypes-section"><a class="header" href="#ltypes-section">Ltypes section</a></h3>
<p>The ltypes section is identifier in the section data type field as "ltypes".
Some aspects of this section are:</p>
<ul>
<li>Found in EWF-L01 in of EnCase 7</li>
<li>Found in the last segment file after table2 section before tree section.</li>
</ul>
<p>The additional ltypes section data is 6 bytes in size and consists of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>2</td><td></td><td>Unknown</td></tr>
<tr><td>2</td><td>2</td><td></td><td>Unknown</td></tr>
<tr><td>4</td><td>2</td><td></td><td>Unknown</td></tr>
</table></div>
<h3 id="ltree-section"><a class="header" href="#ltree-section">Ltree section</a></h3>
<p>The ltree section is identifier in the section data type field as "ltree". Some
aspects of this section are:</p>
<ul>
<li>Found in EWF-L01 in of EnCase 5 to 7</li>
<li>Found in the last segment file after ltypes section and before data section.</li>
</ul>
<p>The ltree section consists of:</p>
<ul>
<li>ltree header</li>
<li>ltree data</li>
</ul>
<h4 id="ltree-header"><a class="header" href="#ltree-header">Ltree header</a></h4>
<p>The ltree header is 48 bytes in size and consists of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>16</td><td></td><td>Integrity hash, which contains the MD5 of the ltree data</td></tr>
<tr><td>16</td><td>8</td><td></td><td>Data size</td></tr>
<tr><td>24</td><td>4</td><td></td><td>Checksum, which contains an Adler-32 of all the data within the ltree header where the checksum value itself is zeroed out.</td></tr>
<tr><td>28</td><td>20</td><td></td><td>Unknown (empty values)</td></tr>
</table></div>
<h4 id="ltree-data"><a class="header" href="#ltree-data">Ltree data</a></h4>
<p>The ltree data string consists of an UTF-16 little-endian encoded string without
byte order mark. The ltree data is not strict UTF-16 since it allows for unpaired
surrogates, such as "U+d800" and "U+dc00".</p>
<p>Other observed characteristics where the names in the ltree deviate from
the original source:</p>
<ul>
<li>[U+0001-U+0008] were converted to U+00ba</li>
<li>[U+0009, U+000a] were stripped</li>
<li>[U+000b, U+000c] were converted to U+0020</li>
<li>U+000d was converted to U+0002</li>
<li>U+00ba remained the same</li>
</ul>
<p>Note that this behavior could be related to EnCase as well and might not be
specific for EWF-L01.</p>
<p>The ltree data string contains the following information:</p>
<div class="table-wrapper"><table><thead><th>Line number</th><th>Value</th><th>Description</th></thead><tr><td>1</td><td>5</td><td>The number of categories provided</td></tr>
<tr><td>2</td><td>rec</td><td>Information about unknown, also see <a href="ewf.html#records_category3">Records category</a></td></tr>
<tr><td>...</td><td></td><td>(an empty line)</td></tr>
<tr><td>...</td><td>perm</td><td>Information about file permissions, also see <a href="ewf.html#permissions_category3">Permissions category</a></td></tr>
<tr><td>...</td><td></td><td>(an empty line)</td></tr>
<tr><td>...</td><td>srce</td><td>Information about acquisition sources, also see <a href="ewf.html#sources_category3">sources category</a></td></tr>
<tr><td>...</td><td></td><td>(an empty line)</td></tr>
<tr><td>...</td><td>sub</td><td>Information about unknown, also see <a href="ewf.html#subjects_category3">subjects category</a></td></tr>
<tr><td>...</td><td></td><td>(an empty line)</td></tr>
<tr><td>...</td><td>entry</td><td>Information about file entries, also see <a href="ewf.html#file_entries_category3">File entries category</a></td></tr>
<tr><td>...</td><td></td><td>(an empty line)</td></tr>
</table></div>
<p>The end of line character(s) is a newline (0x0a).</p>
<h4 id="records-category"><a class="header" href="#records-category"><a name="records_category3"></a>Records category</a></h4>
<p>The rec category contains information about records.</p>
<p>The 1st line of the category contains the string "rec".</p>
<p>The 2nd line of the category contains tab (0x09) separated type indicators.</p>
<div class="table-wrapper"><table><thead><th>Identifier number</th><th>Type indicator</th><th>Description</th></thead><tr><td>1</td><td>tb</td><td>Total bytes, which contains an integer with size of the logical file data (media data)</td></tr>
<tr><td>2</td><td>cl</td><td>Unknown (Clusters?)</td></tr>
<tr><td>3</td><td>n</td><td>Unknown (introduced in EnCase 6.19)</td></tr>
<tr><td>4</td><td>fp</td><td>Unknown (introduced in EnCase 7)</td></tr>
<tr><td>5</td><td>pg</td><td>Unknown (introduced in EnCase 7)</td></tr>
<tr><td>6</td><td>lg</td><td>Unknown (introduced in EnCase 7)</td></tr>
<tr><td>7</td><td>ig</td><td>Unknown (introduced in EnCase 7)</td></tr>
</table></div>
<p>The 3rd line of the category consist of the tab (0x09) separated values.</p>
<h4 id="permissions-category"><a class="header" href="#permissions-category"><a name="permissions_category3"></a>Permissions category</a></h4>
<p>The perm category contains information about file permissions.</p>
<p>The 1st line of the category contains the string "perm".</p>
<p>The 2nd line consists of the following 2 values:</p>
<div class="table-wrapper"><table><thead><th>Value number</th><th>Value</th><th>Description</th></thead><tr><td>1</td><td></td><td>The number of permission groups in the category</td></tr>
<tr><td>2</td><td>1</td><td>Unknown</td></tr>
</table></div>
<p>The 3rd line of the category contains tab (0x09) separated type indicators. For
more information see the sections below.</p>
<p>The remaining lines in the category consist of:</p>
<ul>
<li>category root entry
<ul>
<li>zero or more permissions group entries
<ul>
<li>zero or more permission entries</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Each entry consist of 2 lines:</p>
<div class="table-wrapper"><table><thead><th>Line number</th><th>Value</th><th>Description</th></thead><tr><td>1</td><td></td><td>Number of entries</td></tr>
<tr><td>2</td><td></td><td>Tab (0x09) separated values that correspond to the type indicators.</td></tr>
</table></div>
<p>The 1st line of the category root entry consists of the following 2 values:</p>
<div class="table-wrapper"><table><thead><th>Value number</th><th>Value</th><th>Description</th></thead><tr><td>1</td><td>0</td><td>Unknown</td></tr>
<tr><td>2</td><td></td><td>The number of permission groups in the category</td></tr>
</table></div>
<p>The 1st line of the permission group entry consists of the following 2 values:</p>
<div class="table-wrapper"><table><thead><th>Value number</th><th>Value</th><th>Description</th></thead><tr><td>1</td><td>0</td><td>Unknown</td></tr>
<tr><td>2</td><td></td><td>The number of permissions in the group</td></tr>
</table></div>
<p>The 1st line of the permission entry consists of the following 2 values:</p>
<div class="table-wrapper"><table><thead><th>Value number</th><th>Value</th><th>Description</th></thead><tr><td>1</td><td>0</td><td>Unknown</td></tr>
<tr><td>2</td><td>0</td><td>Unknown</td></tr>
</table></div>
<h5 id="permission-type-indicators"><a class="header" href="#permission-type-indicators">Permission type indicators</a></h5>
<div class="table-wrapper"><table><thead><th>Identifier number</th><th>Type indicator</th><th>Description</th></thead><tr><td>1</td><td>p</td><td>Is parent, where 1 represents if the entry is a category root or permissions group and 0 represents if the entry is a permission</td></tr>
<tr><td>2</td><td>n</td><td>Name, which contains a string</td></tr>
<tr><td>3</td><td>s</td><td>Security identifier, which contains a string with either a <a href="https://github.com/libyal/libfwnt/blob/master/documentation/Security%20Descriptor.asciidoc#security-identifier">Windows NT security identifier (SID)</a> or a POSIX user (uid) or group identifier (gid) in the format " number:" such as " 99:"</td></tr>
<tr><td>4</td><td>pr</td><td>Property type, also see <a href="ewf.html#permission_types">permission types</a></td></tr>
<tr><td>5</td><td>nta</td><td>Access mask</td></tr>
<tr><td>6</td><td>nti</td><td>Unknown (Windows NT access control entry (ACE) flags?, which contains an integer with a <a href="https://github.com/libyal/libfwnt/blob/master/documentation/Security%20Descriptor.asciidoc#access-control-entry-ace-flags">Windows NT access control entry (ACE) flags</a>).</td></tr>
<tr><td>7</td><td>nts</td><td>Unknown (Permission?) (Removed in EnCase 6)</td></tr>
</table></div>
<h5 id="permission-types"><a class="header" href="#permission-types"><a name="permission_types"></a>Permission types</a></h5>
<div class="table-wrapper"><table><thead><th>Value</th><th>Identifier</th><th>Description</th></thead><tr><td>(empty)</td><td></td><td>Owner or category root</td></tr>
<tr><td>1</td><td></td><td>Group</td></tr>
<tr><td>2</td><td></td><td>Allow</td></tr>
<tr><td colspan="3">  </tr>
<tr><td>6</td><td></td><td>Other</td></tr>
<tr><td colspan="3">  </tr>
<tr><td>10</td><td></td><td>Unknown (permissions group?)</td></tr>
</table></div>
<h5 id="access-mask"><a class="header" href="#access-mask">Access mask</a></h5>
<p>Access mask seen in combination with property types 0, 1 and 6</p>
<div class="table-wrapper"><table><thead><th>Value</th><th>Identifier</th><th>Description</th></thead><tr><td>(empty)</td><td></td><td>Owner or category root</td></tr>
<tr><td>0x00000001</td><td><code>[Lst Fldr/Rd Data]</code></td><td>List folder / Read data</td></tr>
<tr><td>0x00000002</td><td><code>[Crt Fl/W Data]</code></td><td>Create file / Write data</td></tr>
<tr><td colspan="3">  </tr>
<tr><td>0x00000020</td><td><code>[Trav Fldr/X Fl]</code></td><td>Traverse folder / Execute file</td></tr>
</table></div>
<p>Access mask seen in combination with property type 2</p>
<pre><code>[0x001200a9] [R&amp;X] [R] [Sync]
[0x001301bf] [M] [R&amp;X] [R] [W] [Sync]
[0x001f01ff] [FC] [M] [R&amp;X] [R] [W] [Sync]
</code></pre>
<div class="table-wrapper"><table><thead><th>Value</th><th>Identifier</th><th>Description</th></thead><tr><td>(empty)</td><td></td><td>Owner or category root</td></tr>
<tr><td>0x00000001</td><td></td><td></td></tr>
<tr><td>0x00000002</td><td></td><td></td></tr>
<tr><td>0x00000004</td><td></td><td></td></tr>
<tr><td>0x00000008</td><td></td><td></td></tr>
<tr><td>0x00000010</td><td></td><td></td></tr>
<tr><td>0x00000020</td><td></td><td></td></tr>
<tr><td>0x00000040</td><td></td><td></td></tr>
<tr><td>0x00000080</td><td></td><td></td></tr>
<tr><td>0x00000100</td><td></td><td></td></tr>
<tr><td colspan="3">  </tr>
<tr><td>0x00010000</td><td></td><td></td></tr>
<tr><td>0x00020000</td><td></td><td></td></tr>
<tr><td>0x00040000</td><td></td><td></td></tr>
<tr><td>0x00080000</td><td></td><td></td></tr>
<tr><td>0x00100000</td><td></td><td></td></tr>
</table></div>
<h4 id="sources-category-2"><a class="header" href="#sources-category-2"><a name="sources_category3"></a>Sources category</a></h4>
<p>The srce category contains information about acquisition sources of the file entries.</p>
<p>TODO: describe what an acquisition source is in the context of EnCase.</p>
<p>The 1st line of the category contains the string "srce".</p>
<p>The 2nd line consists of 2 values.</p>
<div class="table-wrapper"><table><thead><th>Value index</th><th>Value</th><th>Description</th></thead><tr><td>1</td><td></td><td>The number of sources in the category</td></tr>
<tr><td>2</td><td>1</td><td>Unknown</td></tr>
</table></div>
<p>The 3rd line of the category contains tab (0x09) separated type indicators. For
more information see the sections below.</p>
<p>The remaining lines in the category consist of:</p>
<ul>
<li>category root
<ul>
<li>zero or more source entries</li>
</ul>
</li>
</ul>
<p>Each entry consist of 2 lines:</p>
<div class="table-wrapper"><table><thead><th>Line number</th><th>Value</th><th>Description</th></thead><tr><td>1</td><td></td><td>Number of entries</td></tr>
<tr><td>2</td><td></td><td>Tab (0x09) separated values that correspond to the type indicators.</td></tr>
</table></div>
<p>The 1st line of the category root entry consists of the following 2 values:</p>
<div class="table-wrapper"><table><thead><th>Value number</th><th>Value</th><th>Description</th></thead><tr><td>1</td><td>0</td><td>Unknown</td></tr>
<tr><td>2</td><td></td><td>The number of sources in the category</td></tr>
</table></div>
<p>The 1st line of the source entry consists of the following 2 values:</p>
<div class="table-wrapper"><table><thead><th>Value number</th><th>Value</th><th>Description</th></thead><tr><td>1</td><td>0</td><td>Unknown</td></tr>
<tr><td>2</td><td>0</td><td>Unknown</td></tr>
</table></div>
<h5 id="source-type-indicators"><a class="header" href="#source-type-indicators">Source type indicators</a></h5>
<div class="table-wrapper"><table><thead><th>Identifier number</th><th>Type indicator</th><th>Description</th></thead><tr><td>1</td><td>p</td><td></td></tr>
<tr><td>2</td><td>n</td><td></td></tr>
<tr><td>3</td><td>id</td><td>Identifier, which contains an integer identifying the source</td></tr>
<tr><td>4</td><td>ev</td><td>Evidence number, which contains a string</td></tr>
<tr><td>5</td><td>do</td><td>Domain, which contains a string (introduced in EnCase 7.9)</td></tr>
<tr><td>6</td><td>loc</td><td>Location, which contains a string (introduced in EnCase 7.9)</td></tr>
<tr><td>7</td><td>se</td><td>Serial number, which contains a string (introduced in EnCase 7.9)</td></tr>
<tr><td>8</td><td>mfr</td><td>Manufacturer, which contains a string (introduced in EnCase 7.9)</td></tr>
<tr><td>9</td><td>mo</td><td>Model, which contains a string (introduced in EnCase 7.9)</td></tr>
<tr><td>10</td><td>tb</td><td>Total bytes, which contains an integer</td></tr>
<tr><td>11</td><td>lo</td><td>Logical offset, which contains an integer which is -1 when value is not set</td></tr>
<tr><td>12</td><td>po</td><td>Physical offset, which contains an integer which is -1 when value is not set</td></tr>
<tr><td>13</td><td>ah</td><td>MD5 hash, which contains a string with the MD5 hash of the source</td></tr>
<tr><td>14</td><td>sh</td><td>SHA1 hash, which contains a string with the SHA1 hash of the source (introduced in EnCase 6.19)</td></tr>
<tr><td>15</td><td>gu</td><td>Device GUID, which contains a string with a GUID or "0" if not set</td></tr>
<tr><td>16</td><td>pgu</td><td>Primary device GUID, which contains a string with a GUID or "0" if not set (introduced in EnCase 7)</td></tr>
<tr><td>17</td><td>aq</td><td>Acquisition date and time, which contains an integer with a POSIX timestamp</td></tr>
<tr><td>18</td><td>ip</td><td>IP address, which contains a string (introduced in EnCase 7.9)</td></tr>
<tr><td>19</td><td>si</td><td>Unknown (Static IP address?), Contains 1 if static, empty otherwise (introduced in EnCase 7.9)</td></tr>
<tr><td>20</td><td>ma</td><td>MAC address, which contains a string without separator characters (introduced in EnCase 7.9)</td></tr>
<tr><td>21</td><td>dt</td><td>Drive type, which contains a single character (introduced in EnCase 7.9)</td></tr>
</table></div>
<p>The acquisition date and time is in the form of: "1142163845", which is a POSIX
epoch timestamp and represents the date: March 12 2006, 11:44:05.</p>
<p>If the "ha" value contains "00000000000000000000000000000000" this means the
MD5 hash is not set. The same applies for the "sha" value when it contains
"0000000000000000000000000000000000000000" the SHA1 has is not set.</p>
<p>If the "ma" value contains "000000000000" this means the MAC address is not
set.</p>
<h5 id="drive-type"><a class="header" href="#drive-type">Drive type</a></h5>
<div class="table-wrapper"><table><thead><th>Character value</th><th>Meaning</th></thead><tr><td>f</td><td>Fixed drive</td></tr>
</table></div>
<h4 id="subjects-category-2"><a class="header" href="#subjects-category-2"><a name="subjects_category3"></a>Subjects category</a></h4>
<p>The sub category contains information about TODO</p>
<p>TODO: describe what a subject is in the context of EnCase.</p>
<p>The 1st line of the category contains the string "sub".</p>
<p>The 2nd line consists of 2 values.</p>
<div class="table-wrapper"><table><thead><th>Value index</th><th>Value</th><th>Description</th></thead><tr><td>1</td><td></td><td>The number of subjects in the category</td></tr>
<tr><td>2</td><td>1</td><td>Unknown</td></tr>
</table></div>
<p>The 3rd line of the category contains tab (0x09) separated type indicators. For
more information see the sections below.</p>
<p>The remaining lines in the category consist of:</p>
<ul>
<li>category root
<ul>
<li>zero or more subject entries</li>
</ul>
</li>
</ul>
<p>Each entry consist of 2 lines:</p>
<div class="table-wrapper"><table><thead><th>Line number</th><th>Value</th><th>Description</th></thead><tr><td>1</td><td></td><td>Number of entries</td></tr>
<tr><td>2</td><td></td><td>Tab (0x09) separated values that correspond to the type indicators.</td></tr>
</table></div>
<p>The 1st line of the category root entry consists of the following 2 values:</p>
<div class="table-wrapper"><table><thead><th>Value number</th><th>Value</th><th>Description</th></thead><tr><td>1</td><td>0</td><td>Unknown</td></tr>
<tr><td>2</td><td></td><td>The number of subject in the category</td></tr>
</table></div>
<p>The 1st line of the subject entry consists of the following 2 values:</p>
<div class="table-wrapper"><table><thead><th>Value number</th><th>Value</th><th>Description</th></thead><tr><td>1</td><td>0</td><td>Unknown</td></tr>
<tr><td>2</td><td>0</td><td>Unknown</td></tr>
</table></div>
<h5 id="subject-type-indicators"><a class="header" href="#subject-type-indicators">Subject type indicators</a></h5>
<div class="table-wrapper"><table><thead><th>Identifier number</th><th>Type indicator</th><th>Description</th></thead><tr><td>1</td><td>p</td><td></td></tr>
<tr><td>2</td><td>n</td><td></td></tr>
<tr><td>3</td><td>id</td><td>Identifier, which contains an integer identifying the subject</td></tr>
<tr><td>4</td><td>nu</td><td>Unknown (Number)</td></tr>
<tr><td>5</td><td>co</td><td>Unknown (Comment)</td></tr>
<tr><td>6</td><td>gu</td><td>Unknown (GUID)</td></tr>
</table></div>
<h4 id="file-entries-category"><a class="header" href="#file-entries-category"><a name="file_entries_category3"></a>File entries category</a></h4>
<p>The entry category contains information about the file entries.</p>
<p>The 1st line of the category contains the string "entry".</p>
<p>The 2nd line consists of 2 values.</p>
<div class="table-wrapper"><table><thead><th>Value index</th><th>Value</th><th>Description</th></thead><tr><td>1</td><td></td><td>The number of file entries in the category or 1 if unknown</td></tr>
<tr><td>2</td><td>1</td><td>Unknown</td></tr>
</table></div>
<p>The 3rd line of the category contains tab (0x09) separated type indicators. For
more information see the sections below.</p>
<p>The remaining lines in the category consist of:</p>
<ul>
<li>category root
<ul>
<li>zero or more file entries
<ul>
<li>zero or more sub file entries
<ul>
<li>...</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Each entry consist of 2 lines:</p>
<div class="table-wrapper"><table><thead><th>Line number</th><th>Value</th><th>Description</th></thead><tr><td>1</td><td></td><td>Number of entries</td></tr>
<tr><td>2</td><td></td><td>Tab (0x09) separated values that correspond to the type indicators.</td></tr>
</table></div>
<p>The 1st line of the category root entry consists of the following 2 values:</p>
<div class="table-wrapper"><table><thead><th>Value number</th><th>Value</th><th>Description</th></thead><tr><td>1</td><td></td><td>0 if not set or 26 if Unknown</td></tr>
<tr><td>2</td><td></td><td>The number of file entries in the category</td></tr>
</table></div>
<p>The 1st line of the file entry consists of the following 2 values:</p>
<div class="table-wrapper"><table><thead><th>Value number</th><th>Value</th><th>Description</th></thead><tr><td>1</td><td></td><td>Number of file entries in the parent file entry or 0 if not set</td></tr>
<tr><td>2</td><td></td><td>The number of sub file entries in the file entry</td></tr>
</table></div>
<h5 id="encase-5-and-6-ewf-l01-file-entry-type-indicators"><a class="header" href="#encase-5-and-6-ewf-l01-file-entry-type-indicators">EnCase 5 and 6 (EWF-L01) file entry type indicators</a></h5>
<div class="table-wrapper"><table><thead><th>Identifier number</th><th>Character in 29th line</th><th>Meaning</th></thead><tr><td>1</td><td>p</td><td>Is parent, where 1 =&gt; if the entry is a directory and (empty) =&gt; if the entry is a file</td></tr>
<tr><td>2</td><td>n</td><td><a href="ewf.html#file_entry_name">Name</a></td></tr>
<tr><td>3</td><td>id</td><td>Identifier, contains an integer identifying the file entry</td></tr>
<tr><td>4</td><td>opr</td><td><a href="ewf.html#file_entry_flags">File entry flags</a></td></tr>
<tr><td>5</td><td>src</td><td>Source identifier, which contains an integer that corresponds to an identifier in the <a href="ewf.html#sources_category3">Sources category</a></td></tr>
<tr><td>6</td><td>sub</td><td>Subject identifier, which contains an integer that corresponds to an identifier in the <a href="ewf.html#subjects_category3">Subjects category</a></td></tr>
<tr><td>7</td><td>cid</td><td>Unknown (record type)</td></tr>
<tr><td>8</td><td>jq</td><td>Unknown</td></tr>
<tr><td>9</td><td>cr</td><td>Creation date and time</td></tr>
<tr><td>10</td><td>ac</td><td>Access date and time, for which currently is assumed the precision is date only</td></tr>
<tr><td>11</td><td>wr</td><td>(File) modification (last written) date and time</td></tr>
<tr><td>12</td><td>mo</td><td>(File system) entry modification date and time</td></tr>
<tr><td>13</td><td>dl</td><td>Deletion date and time</td></tr>
<tr><td>14</td><td>aq</td><td>Acquisition date and time, which contains an integer with a POSIX timestamp</td></tr>
<tr><td>15</td><td>ha</td><td>MD5 hash, which contains a string with the MD5 hash of the file data</td></tr>
<tr><td>16</td><td>ls</td><td>File size in bytes. If the file size is 0 the data size should be 1</td></tr>
<tr><td>17</td><td>du</td><td>Duplicate data offset, relative from the start of the media data</td></tr>
<tr><td>18</td><td>lo</td><td>Logical offset, which contains an integer which is -1 when value is not set</td></tr>
<tr><td>19</td><td>po</td><td>Physical offset, which contains an integer which is -1 when value is not set (or does this value contain the segment file in which the start of the data is stored, -1 for a single segment file?)</td></tr>
<tr><td>20</td><td>mid</td><td>GUID, which contains a string with a GUID (introduced in EnCase 6.19)</td></tr>
<tr><td>21</td><td>cfi</td><td>Unknown (introduced in EnCase 6.14)</td></tr>
<tr><td>22</td><td>be</td><td><a href="ewf.html#binary_extents">Binary extents</a></td></tr>
<tr><td>23</td><td>pm</td><td>Permissions group index, which contains an integer that corresponds to an identifier in the <a href="ewf.html#permissions_category3">Permissions category</a> or -1 if not set.  The value is 0 by default</td></tr>
<tr><td>24</td><td>lpt</td><td>Unknown (introduced in EnCase 6.19)</td></tr>
</table></div>
<p>The creation, access and last written date and time are in the form of:
"1142163845", which is a POSIX epoch timestamp and represents the date: March
12 2006, 11:44:05.</p>
<p>The "ha" value (Hash) consist of a MD5 hash string when file entries are
hashed. If the "ha" value contains "00000000000000000000000000000000" this
means the MD5 hash is not set.</p>
<h6 id="ltree-file-entries"><a class="header" href="#ltree-file-entries">Ltree file entries</a></h6>
<p>The ltree entries of files and directories consist of entries starting with: 0
followed by the number of sub file entries.</p>
<p>The entries of files and directories:</p>
<div class="table-wrapper"><table><thead><th>Line number</th><th>Value</th><th>Description</th></thead><tr><td>1</td><td>(empty)</td><td>The root directory</td></tr>
<tr><td>2</td><td></td><td>The target drive/mount point</td></tr>
<tr><td>3</td><td></td><td>The actual single file entries</td></tr>
</table></div>
<h5 id="encase-7-ewf-l01-file-entry-type-indicators"><a class="header" href="#encase-7-ewf-l01-file-entry-type-indicators">EnCase 7 (EWF-L01) file entry type indicators</a></h5>
<div class="table-wrapper"><table><thead><th>Identifier number</th><th>Character in 29th line</th><th>Meaning</th></thead><tr><td>1</td><td>mid</td><td>GUID, which contains a string with a GUID</td></tr>
<tr><td>2</td><td>ls</td><td>File size, in bytes. If the file size is 0 the data size should be 1</td></tr>
<tr><td>3</td><td>be</td><td><a href="ewf.html#binary_extents">Binary extents</a></td></tr>
<tr><td>4</td><td>id</td><td>Identifier, which contains an integer identifying the file entry</td></tr>
<tr><td>5</td><td>cr</td><td>Creation date and time</td></tr>
<tr><td>6</td><td>ac</td><td>Access date and time</td></tr>
<tr><td>7</td><td>wr</td><td>(File) modification (last written) date and time</td></tr>
<tr><td>8</td><td>mo</td><td>(File system) entry modification date and time</td></tr>
<tr><td>9</td><td>dl</td><td>Deletion date and time</td></tr>
<tr><td>10</td><td>sig</td><td>Unknown (Introduced in EnCase 7)</td></tr>
<tr><td>11</td><td>ha</td><td>MD5 hash, which contains a string with the MD5 hash of the file data</td></tr>
<tr><td>12</td><td>sha</td><td>SHA1 hash, which contains a string with the SHA1 hash of the file data. (Introduced in EnCase 7)</td></tr>
<tr><td>13</td><td>ent</td><td>Unknown, seen "B" (Introduced in EnCase 7.9)</td></tr>
<tr><td>14</td><td>snh</td><td><a href="ewf.html#short_name">Short name</a> (or DOS 8.3 name) (Introduced in EnCase 7.9)</td></tr>
<tr><td>15</td><td>p</td><td>Is parent, where "1" represents that the entry is a directory and "" (an empty string) that the entry is a file</td></tr>
<tr><td>16</td><td>n</td><td><a href="ewf.html#file_entry_name">Name</a></td></tr>
<tr><td>17</td><td>du</td><td>Duplicate data offset, relative from the start of the media data</td></tr>
<tr><td>18</td><td>lo</td><td>Logical offset, which contains an integer which is -1 when value is not set</td></tr>
<tr><td>19</td><td>po</td><td>Physical offset, which contains an integer which is -1 when value is not set (or does this value contain the segment file in which the start of the data is stored, -1 for a single segment file?)</td></tr>
<tr><td>20</td><td>pm</td><td>Permissions group index, which contains an integer that corresponds to an identifier in the <a href="ewf.html#permissions_category3">Permissions category</a> or -1 if not set.  The value is 0 by default</td></tr>
<tr><td>21</td><td>oes</td><td>Unknown (Original extents?) (Introduced in EnCase 7)</td></tr>
<tr><td>22</td><td>opr</td><td><a href="ewf.html#file_entry_flags">File entry flags</a></td></tr>
<tr><td>23</td><td>src</td><td>Source identifier, which contains an integer that corresponds to an identifier in the <a href="ewf.html#sources_category3">Sources category</a></td></tr>
<tr><td>24</td><td>sub</td><td>Subject identifier, which contains an integer that corresponds to an identifier in the <a href="ewf.html#subjects_category3">Subjects category</a></td></tr>
<tr><td>25</td><td>cid</td><td>Unknown (record type?)</td></tr>
<tr><td>26</td><td>jq</td><td>Unknown</td></tr>
<tr><td>27</td><td>alt</td><td>Unknown (Introduced in EnCase 7)</td></tr>
<tr><td>28</td><td>ep</td><td>Unknown (Introduced in EnCase 7)</td></tr>
<tr><td>29</td><td>aq</td><td>Acquisition date and time, which contains an integer with a POSIX timestamp</td></tr>
<tr><td>30</td><td>cfi</td><td>Unknown</td></tr>
<tr><td>31</td><td>sg</td><td>Unknown (Introduced in EnCase 7)</td></tr>
<tr><td>32</td><td>ea</td><td><a href="ewf.html#extended_attributes">Extended attributes</a> (Introduced in EnCase 7.9)</td></tr>
<tr><td>33</td><td>lpt</td><td>Unknown</td></tr>
</table></div>
<p>If the "ha" value contains "00000000000000000000000000000000" this means the
MD5 hash is not set. The same applies for the "sha" value when it contains
"0000000000000000000000000000000000000000" the SHA1 has is not set.</p>
<h6 id="file-entry-name"><a class="header" href="#file-entry-name"><a name="file_entry_name"></a>File entry name</a></h6>
<p>A file entry name ("n" value):</p>
<ul>
<li>can contain path segment separator characters like "\" and "/"</li>
<li>uses the "MIDDLE DOT" Unicode character (U+00b7) as a (NTFS) alternative data stream (ADS) name seperator</li>
</ul>
<blockquote>
<p>Note that a regular "MIDDLE DOT" Unicode character will be encoded in the
same way so no real way to reliably tell the difference.</p>
</blockquote>
<p>An empty name has been observed to be represented as "NoName".</p>
<h6 id="short-name"><a class="header" href="#short-name"><a name="short_name"></a>Short name</a></h6>
<p>The short name ("snh") value contains 2 values:</p>
<div class="table-wrapper"><table><thead><th>Value number</th><th>Value</th><th>Description</th></thead><tr><td>1</td><td></td><td>The number of characters in the short name including the end-of-string character</td></tr>
<tr><td>2</td><td></td><td>The short name string, without an end-of-string character</td></tr>
</table></div>
<p>For example: "13 FILE10~1.TXT"</p>
<h6 id="original-extents"><a class="header" href="#original-extents">Original extents</a></h6>
<p>TODO: add some text</p>
<pre><code>1 30a555b 30a6000 12011ae00 9008d7 3f 43 1 12011ae00 30a6000 120113 30a6 9008d7 18530
</code></pre>
<h6 id="ltree-file-entries-1"><a class="header" href="#ltree-file-entries-1">Ltree file entries</a></h6>
<p>The ltree entries of files and directories consist of entries starting with: 26
followed by the number of sub file entries.</p>
<p>The entries of files and directories:</p>
<div class="table-wrapper"><table><thead><th>Line number</th><th>Value</th><th>Description</th></thead><tr><td>1</td><td>LogicalEntries</td><td>The root directory</td></tr>
<tr><td>2</td><td></td><td>The target drive/mount point</td></tr>
<tr><td>3</td><td></td><td>The actual single file entries</td></tr>
</table></div>
<h5 id="file-entry-flags"><a class="header" href="#file-entry-flags"><a name="file_entry_flags"></a>File entry flags</a></h5>
<div class="table-wrapper"><table><thead><th>Value</th><th>Identifier</th><th>Description</th></thead><tr><td>0x00000001</td><td></td><td>Unknown (Is read-only?)</td></tr>
<tr><td>0x00000002</td><td>Hidden</td><td>Is hidden</td></tr>
<tr><td>0x00000004</td><td>System</td><td>Is system</td></tr>
<tr><td>0x00000008</td><td>Archive</td><td>Is archive</td></tr>
<tr><td>0x00000010</td><td>Sym Link</td><td>Is symbolic link, junction or reparse point</td></tr>
<tr><td></td><td></td><td></td></tr>
<tr><td>0x00000080</td><td>Deleted</td><td>Is deleted</td></tr>
<tr><td></td><td></td><td></td></tr>
<tr><td>0x00001000</td><td>Hard Linked</td><td>Is hard link</td></tr>
<tr><td>0x00002000</td><td>Stream</td><td>Is stream</td></tr>
<tr><td></td><td></td><td></td></tr>
<tr><td>0x00100000</td><td>Internal</td><td>Is internal (used in combination with 0x00000006?)</td></tr>
<tr><td></td><td></td><td></td></tr>
<tr><td>0x00200000</td><td>Unallocated Clusters</td><td>Unknown</td></tr>
<tr><td>0x00400000</td><td></td><td>Unknown</td></tr>
<tr><td></td><td></td><td></td></tr>
<tr><td>0x01000000</td><td></td><td>Unknown</td></tr>
<tr><td>0x02000000</td><td>Folder</td><td>Is folder</td></tr>
<tr><td>0x04000000</td><td></td><td>Data is sparse.</td></tr>
</table></div>
<p>If 0x00002000 or 0x02000000 are not set the file entry is of type "File".</p>
<p>If the sparse data flag is set:</p>
<ul>
<li>the data size should be 1 and data should consist of a single byte value.</li>
<li>the data size should be equal to the file size and data should be the same.</li>
</ul>
<p>If the duplicate data offset value is not set the single byte value in the data
should be used to reconstruct the file data. E.g. if the file size is 4096 and
the data contains the byte value 0x00 the resulting file should consists of
4096 x 0x00 byte values.</p>
<p>If the duplicate data offset value is set the single byte in the data is
ignored and the duplicate data offset refers to the location where the data
stored.</p>
<h5 id="binary-extents-value"><a class="header" href="#binary-extents-value"><a name="binary_extents"></a>Binary extents value</a></h5>
<p>The binary extents value contains 3 values separated by a space:</p>
<pre><code>Unknown Offset Size
</code></pre>
<p>Where:</p>
<ul>
<li>unknown always is 1, could this be the number of extents?</li>
<li>extent data offset, relative from the start of the media data</li>
<li>extent data size</li>
</ul>
<p>The offset and size are specified in hexadecimal values.</p>
<blockquote>
<p>Note that the binary extents value contains only 1 value for the first single file entry.</p>
</blockquote>
<h5 id="extended-attributes-value"><a class="header" href="#extended-attributes-value"><a name="extended_attributes"></a>Extended attributes value</a></h5>
<p>The extended attributes value contains base-16 encoded data, which consists of:</p>
<ul>
<li>Extended attributes header (stored as an extended attribute)</li>
<li>One or more extended attributes</li>
</ul>
<h6 id="extended-attributes-header"><a class="header" href="#extended-attributes-header">Extended attributes header</a></h6>
<p>The extended attributes header is 37 bytes in size and consists of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>4</td><td>0</td><td>Unknown (0 =&gt; root, 1 =&gt; otherwise)</td></tr>
<tr><td>4</td><td>1</td><td>1</td><td>Unknown (0 =&gt; is leaf node, 1 =&gt; is branch node?)</td></tr>
<tr><td>5</td><td>4</td><td>11</td><td>Number of characters in name string including the end-of-string character</td></tr>
<tr><td>9</td><td>4</td><td>1</td><td>Number of characters in value string including the end-of-string character</td></tr>
<tr><td>13</td><td>22</td><td>"Attributes\0"</td><td>Name string, which contains an UTF-16 little-endian encoded string including end-of-string character</td></tr>
<tr><td>35</td><td>2</td><td>"\0"</td><td>Value string, which contains an UTF-16 little-endian encoded string including end-of-string character</td></tr>
</table></div>
<h6 id="extended-attribute"><a class="header" href="#extended-attribute">Extended attribute</a></h6>
<p>An extended attributes is of variable size and consists of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>4</td><td></td><td>Unknown (0 =&gt; root, 1 =&gt; otherwise)</td></tr>
<tr><td>4</td><td>1</td><td></td><td>Unknown (0 =&gt; is leaf node, 1 =&gt; is branch node?)</td></tr>
<tr><td>5</td><td>4</td><td></td><td>Number of characters in name string including the end-of-string character</td></tr>
<tr><td>9</td><td>4</td><td></td><td>Number of characters in value string including the end-of-string character</td></tr>
<tr><td>13</td><td>...</td><td></td><td>Name string, which contains an UTF-16 little-endian encoded string including end-of-string character</td></tr>
<tr><td>...</td><td>...</td><td></td><td>Value string, which contains an UTF-16 little-endian encoded string including end-of-string character</td></tr>
</table></div>
<p>TODO: complete section</p>
<blockquote>
<p>Note that branch nodes are presuably used to group attributes, however these
are not used consistently and are not shown by EnCase 7.</p>
</blockquote>
<h3 id="map-section"><a class="header" href="#map-section">Map section</a></h3>
<p>Some aspects of this section are:</p>
<ul>
<li>Found in EWF-L01 in of EnCase 7 (First seen in EnCase 7.4.1.10)</li>
<li>Found in the last segment file after data section before done section.</li>
</ul>
<p>The map consists of:</p>
<ul>
<li>map string</li>
<li>map entries array</li>
</ul>
<h4 id="map-string"><a class="header" href="#map-string">Map string</a></h4>
<p>The map string consists of an UTF-16 little-endian encoded string without the
UTF-16 endian byte order mark.</p>
<p>The map string contains the following information:</p>
<div class="table-wrapper"><table><thead><th>Line number</th><th>Value</th><th>Description</th></thead><tr><td>1</td><td>1</td><td>The number of categories provided</td></tr>
<tr><td>2</td><td>r</td><td>Probably the type of information provided</td></tr>
<tr><td>3</td><td>c</td><td>Identifier for the values in the 4th line</td></tr>
<tr><td>4</td><td></td><td>The data for the different identifiers in the 3rd line</td></tr>
<tr><td>5</td><td></td><td>(an empty line)</td></tr>
</table></div>
<h5 id="map-string-values"><a class="header" href="#map-string-values">Map string values</a></h5>
<div class="table-wrapper"><table><thead><th>Identifier number</th><th>Character in 29th line</th><th>Meaning</th></thead><tr><td>1</td><td>C</td><td>Number of map entries (count)</td></tr>
</table></div>
<p>The number of map entries should match the number of file entries in the ltree.</p>
<h4 id="map-entry"><a class="header" href="#map-entry">Map entry</a></h4>
<p>A map entry is 24 bytes in size and consists of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>4</td><td></td><td>Unknown</td></tr>
<tr><td>4</td><td>4</td><td></td><td>Unknown (empty values or part of previous value)</td></tr>
<tr><td>8</td><td>16</td><td></td><td>Unknown</td></tr>
</table></div>
<h3 id="session-section"><a class="header" href="#session-section">Session section</a></h3>
<p>The session section is identifier in the section data type field as "session". Some aspects of this section are:</p>
<ul>
<li>Not defined in <a href="http://www.asrdata.com/whitepaper-html">ASR Data - E01 Compression Format</a>.</li>
<li>It is not found in SMART (EWF-S01) and FTK Imager (EWF-E01).</li>
<li>It is found in EnCase 5 and 6 (EWF-E01) files.</li>
<li>It is only added to the last segment file for images of optical disc (CD/DVD/BD) media.</li>
<li>It is found after the data section and before the error2 section.</li>
</ul>
<p>The session section data consists of:</p>
<ul>
<li>The session header</li>
<li>The session entries array</li>
<li>The session footer</li>
</ul>
<h4 id="session-header"><a class="header" href="#session-header">Session header</a></h4>
<p>The session header is 36 byte in size and consists of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>4</td><td></td><td>Number of sessions</td></tr>
<tr><td>4</td><td>28</td><td></td><td>Unknown (empty values)</td></tr>
<tr><td>32</td><td>4</td><td></td><td>Checksum, which contains an Adler-32 of all the previous data within the additional session section data.</td></tr>
</table></div>
<h4 id="session-entry"><a class="header" href="#session-entry">Session entry</a></h4>
<p>A session entry is 32 byte in size and consists of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>4</td><td></td><td>Flags</td></tr>
<tr><td>4</td><td>4</td><td></td><td>Start sector</td></tr>
<tr><td>8</td><td>24</td><td></td><td>Unknown (empty values)</td></tr>
</table></div>
<p>EnCase stores audio tracks as 0 byte data with a sector size of 2048.</p>
<blockquote>
<p>Note that for a CD the first session sector is stored as 16, although the
actual session starts at sector 0. Could this value be overloaded to indicate
the size of the reserved space between the start of the session and the ISO
9660 volume descriptor.</p>
</blockquote>
<h4 id="session-flags"><a class="header" href="#session-flags">Session flags</a></h4>
<div class="table-wrapper"><table><thead><th>Value</th><th>Identifier</th><th>Description</th></thead><tr><td>0x00000001</td><td></td><td>If set the track is an audio track otherwise the track is a data track</td></tr>
</table></div>
<h4 id="session-footer"><a class="header" href="#session-footer">Session footer</a></h4>
<p>The session footer is 4 byte in size and consists of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>4</td><td></td><td>Checksum, which contains an Adler-32 of all the data within the session entries array</td></tr>
</table></div>
<h3 id="error2-section"><a class="header" href="#error2-section">Error2 section</a></h3>
<p>The error2 section is identifier in the section data type field as "error2".
Some aspects of this section are:</p>
<ul>
<li>Not defined in <a href="http://www.asrdata.com/whitepaper-html">ASR Data - E01 Compression Format</a>.</li>
<li>It is not found in SMART (EWF-S01).</li>
<li>It is found in, EnCase 3 to 7 and linen 5 to 7 (EWF-E01) files.</li>
<li>It is only added to the last segment file when errors were encountered while reading the input.</li>
</ul>
<p>TODO: check FTK Imager, EnCase 1 and 2 for presence of the error2 section.</p>
<p>It contains the sectors that have read errors. The sector where a read error
occurred are filled with zero's during acquiry by EnCase.</p>
<p>The error2 section data consists of:</p>
<ul>
<li>The error2 header</li>
<li>The error2 entries array</li>
<li>The error2 footer</li>
</ul>
<h4 id="error2-header"><a class="header" href="#error2-header">Error2 header</a></h4>
<p>The error2 header is 520 byte in size and consists of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>4</td><td></td><td>Number of entries</td></tr>
<tr><td>4</td><td>512</td><td></td><td>Unknown (empty values)</td></tr>
<tr><td>516</td><td>4</td><td></td><td>Checksum, which contains an Adler-32 of all the previous data within the error2 header data.</td></tr>
</table></div>
<h4 id="error2-entry"><a class="header" href="#error2-entry">Error2 entry</a></h4>
<p>An error2 entry is 8 byte in size and consists of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>4</td><td></td><td>Start sector</td></tr>
<tr><td>4</td><td>4</td><td></td><td>The number of sectors</td></tr>
</table></div>
<h4 id="error2-footer"><a class="header" href="#error2-footer">Error2 footer</a></h4>
<p>The error2 footer is 4 byte in size and consists of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>4</td><td></td><td>Checksum, which contains an Adler-32 of all the data within the error2 entries array</td></tr>
</table></div>
<h3 id="digest-section"><a class="header" href="#digest-section">Digest section</a></h3>
<p>The digest section is identified in the section data type field as "digest".
Some aspects of this section are:</p>
<ul>
<li>It is found in EnCase 6 to 7 files, as of EnCase 6.12 and linen 6.12 (EWF-E01).</li>
</ul>
<p>The digest section contains a MD5 and/or SHA1 hash of the data within the chunks.</p>
<p>The digest section data is 80 byte in size and consists of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>16</td><td></td><td>MD5 hash of the media data</td></tr>
<tr><td>16</td><td>20</td><td></td><td>SHA1 hash of the media data</td></tr>
<tr><td>36</td><td>40</td><td>0x00</td><td>Unknown (Padding)</td></tr>
<tr><td>76</td><td>4</td><td></td><td>Checksum, which contains an Adler-32 of all the previous data within the digest section data.</td></tr>
</table></div>
<h3 id="hash-section"><a class="header" href="#hash-section">Hash section</a></h3>
<p>The hash section is identified in the section data type field as "hash". Some
aspects of this section are:</p>
<ul>
<li>Defined in <a href="http://www.asrdata.com/whitepaper-html">ASR Data - E01 Compression Format</a>.</li>
<li>It is found in SMART (EWF-S01) and FTK Imager, EnCase 1 to 7 and linen 5 to 7 (EWF-E01) files.</li>
<li>It is not found in EnCase 5 (EWF-L01).</li>
<li>The hash section is optional, it does not need to be present. If it does it resides in the last segment file before the done section.</li>
</ul>
<p>The hash section contains a MD5 hash of the data within the chunks.</p>
<p>The hash section data is 36 byte in size and consists of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>16</td><td></td><td>MD5 hash of the media data</td></tr>
<tr><td>16</td><td>16</td><td></td><td>Unknown</td></tr>
<tr><td>32</td><td>4</td><td></td><td>Checksum, which contains an Adler-32 of all the previous data within the additional hash section data.</td></tr>
</table></div>
<h4 id="notes-1"><a class="header" href="#notes-1">Notes</a></h4>
<p>Observations regarding the unknown value:</p>
<ul>
<li>is zero in SMART</li>
<li>is zero in EnCase 3 and below</li>
<li>in EnCase 4 the first 4 bytes are 0, the next 8 bytes seem random, the last 4 bytes seem fixed</li>
<li>in EnCase 5 and 6 the first 8 bytes seem random, the last 8 bytes equal the file header signature</li>
<li>in linen 5 the first and last set of 4 bytes seem the same, the second set of 4 bytes seem to be random, the third set of 4 bytes seem to contain a piece of the file header signature</li>
<li>in linen 6 the first and third set of 4 bytes seem random, the second and last set of 4 bytes seem to be the same</li>
<li>EnCase5 seems to contain a GUID of the acquired device?</li>
</ul>
<p>Test with EnCase 4 show that:</p>
<ul>
<li>The value does not equal the checksum of the media data</li>
<li>Does not differentiate for the same media acquired within the same program session, using different formats, but differ for different media and different program sessions</li>
</ul>
<h3 id="done-section"><a class="header" href="#done-section">Done section</a></h3>
<p>The done section is identified in the section data type field as "done". Some
aspects of this section are:</p>
<ul>
<li>Defined in <a href="http://www.asrdata.com/whitepaper-html">ASR Data - E01 Compression Format</a>.</li>
<li>It is found in SMART (EWF-S01), FTK Imager, EnCase 1 to 7 and linen 5 to 7 (EWF-E01) and EnCase 5 (EWF-L01) files.</li>
<li>The done section is the last section within the last segment file.</li>
<li>The offset to the next section in the section header of the done section point to itself (the start of the done section).</li>
<li>It should be the last section in the last segment file.</li>
</ul>
<h4 id="smart-ewf-s01-5"><a class="header" href="#smart-ewf-s01-5">SMART (EWF-S01)</a></h4>
<p>It resides after the table or table2 section.</p>
<h4 id="ftk-imager-encase-and-linen-ewf-e01-1"><a class="header" href="#ftk-imager-encase-and-linen-ewf-e01-1">FTK Imager, EnCase and linen (EWF-E01)</a></h4>
<p>It resides after the data section in a single segment file or for multiple
segment files after the table2 section.</p>
<p>In the EnCase (EWF-E01) format the size in the section header is 0 instead of
76 (the size of the section header).</p>
<blockquote>
<p>Note that FTK imager versions before 2.9 sets the section size to 76. At the
moment it is unknown in which version this behavior was changed.</p>
</blockquote>
<h4 id="incomplete-section"><a class="header" href="#incomplete-section">Incomplete section</a></h4>
<p>The incomplete section is identified in the section data type field as
"incomplete".</p>
<p>This section is seen rarely. It was seen in an EnCase 6.13 (EWF-E01) file as
the last last section within the last segment file. The incomplete section was
preceded by a hash and digest section, although later in the set of EWF files
another hash and digest section were defined.</p>
<p>It is currently assumed that the incomplete section indicates an incomplete
image created using remote imaging. The incomplete section contains data but
currently there is no indication what purpose the data has.</p>
<h2 id="ewf-x"><a class="header" href="#ewf-x">EWF-X</a></h2>
<p>EWF-X (extended) is an experimental format to enhance the EWF format. EWF-X is
based on the EWF-E01 format. EWF-X does not limit the table entries to 16375.
EWF-X is not the same as version 2 of EWF.</p>
<p>TODO: add note about the table entry limit.</p>
<h3 id="sections"><a class="header" href="#sections">Sections</a></h3>
<p>Additional sections provided in the EWF-X format are:</p>
<ul>
<li>xheader</li>
<li>xhash</li>
</ul>
<h4 id="xheader"><a class="header" href="#xheader">Xheader</a></h4>
<p>The xheader section contains <a href="zlib.html">zlib compressed data</a> containing XML
data containing the header values.</p>
<pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;xheader&gt;
        &lt;case_number&gt;1&lt;/case_number&gt;
        &lt;description&gt;Description&lt;/description&gt;
        &lt;examiner_name&gt;John D.&lt;/examiner_name&gt;
        &lt;evidence_number&gt;1.1&lt;/evidence_number&gt;
        &lt;notes&gt;Just a floppy in my system&lt;/notes&gt;
        &lt;acquiry_operating_system&gt;Linux&lt;/acquiry_operating_system&gt;
        &lt;acquiry_date&gt;Sat Jan 20 18:32:08 2007 CET&lt;/acquiry_date&gt;
        &lt;acquiry_software&gt;ewfacquire&lt;/acquiry_software&gt;
        &lt;acquiry_software_version&gt;20070120&lt;/acquiry_software_version&gt;
&lt;/xheader&gt;
</code></pre>
<h4 id="xhash"><a class="header" href="#xhash">Xhash</a></h4>
<p>The xhash section contains <a href="zlib.html">zlib compressed data</a> containing XML data
containing the hash values.</p>
<pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;xhash&gt;
        &lt;md5&gt;ae1ce8f5ac079d3ee93f97fe3792bda3&lt;/md5&gt;
        &lt;sha1&gt;31a58f090460b92220d724b28eeb2838a1df6184&lt;/sha1&gt;
&lt;/xhash&gt;
</code></pre>
<h3 id="guid"><a class="header" href="#guid">GUID</a></h3>
<p>EWF-X uses a random based version of the GUID</p>
<h2 id="corruption-scenarios"><a class="header" href="#corruption-scenarios">Corruption scenarios</a></h2>
<p>This chapter contains several corruption scenarios that have been encountered
"in the wild".</p>
<h3 id="corrupt-uncompressed-chunk"><a class="header" href="#corrupt-uncompressed-chunk">Corrupt uncompressed chunk</a></h3>
<p>TODO: add description</p>
<h3 id="corrupt-compressed-chunk"><a class="header" href="#corrupt-compressed-chunk">Corrupt compressed chunk</a></h3>
<p>TODO: add description</p>
<h3 id="deflate-uncompressed-block-data-with-copy-of-uncompressed-data-size-of-0"><a class="header" href="#deflate-uncompressed-block-data-with-copy-of-uncompressed-data-size-of-0">DEFLATE uncompressed block data with copy of uncompressed data size of 0</a></h3>
<p>Seen in combination with some firmware versions of Tableau TD3 forensic imager.</p>
<p>In this corruption scenarion the copy of uncompressed data size value of the
<a href="zlib.html">DEFLATE uncompressed block data</a> is set to 0 instead of the 1s
complement of the uncompressed data size.</p>
<p>Libewf currently does not handle this corruption scenario.</p>
<h3 id="corrupt-section-header"><a class="header" href="#corrupt-section-header">Corrupt section header</a></h3>
<p>TODO: add description</p>
<pre><code>reading section header from file IO pool entry: 1 at offset: 415912423
type                      : table2
next offset               : 415978027
size                      : 65604
checksum                  : 0xf35f03e0
number of offsets         : 16375
base offset               : 0x00000000
checksum                  : 0x180d0137

reading section header from file IO pool entry: 1 at offset: 415978027
type                      : sectors
next offset               : 415978027
size                      : 0
checksum                  : 0x1ad00464
</code></pre>
<h3 id="corrupt-table-section"><a class="header" href="#corrupt-table-section">Corrupt table section</a></h3>
<p>TODO: add description</p>
<p>Scenarios:</p>
<ul>
<li>with and with out table 2</li>
<li>corruption in number of entries</li>
<li>corruption in entry data</li>
</ul>
<h3 id="corrupted-segment-file-header"><a class="header" href="#corrupted-segment-file-header">Corrupted segment file header</a></h3>
<p>TODO: add description</p>
<h3 id="partial-segment-file"><a class="header" href="#partial-segment-file">Partial segment file</a></h3>
<p>TODO: add description</p>
<h3 id="missing-segment-files"><a class="header" href="#missing-segment-files">Missing segment file(s)</a></h3>
<p>TODO: add description</p>
<h3 id="dual-image-section-size-versus-offset"><a class="header" href="#dual-image-section-size-versus-offset">Dual image: section size versus offset</a></h3>
<p>The section headers define both the next section offset and the size of the
section. If an implementation reads only one of the two to determine the next
section, a dual EWF image can be crafted that consists of two separate images
including hashes.</p>
<p>Keramics will mark such an image as corrupted.</p>
<h3 id="table-entries-offset-overflow"><a class="header" href="#table-entries-offset-overflow">Table entries offset overflow</a></h3>
<p>In EnCase 6.7.1 the sectors section can be larger than 2048 MiB. The table
entries offsets are 31 bit values in EnCase6 the offset in a table entry value
will actually use the full 32 bit if the 2048 MiB has been exceeded. This
behavior is no longer present in EnCase 6.8 so it is assumed to be a bug.</p>
<p>Libewf currently assumes that the if the 31 bit value overflows the following
chunks are uncompressed. This allows EnCase 6.7.1 faulty EWF files to be
converted by Keramics.</p>
<h3 id="multiple-incomplete-segment-file-set-identifiers"><a class="header" href="#multiple-incomplete-segment-file-set-identifiers">Multiple incomplete segment file set identifiers</a></h3>
<p>Although rare it can occur that a set of EWF image files changes its segment
file set identifier. This was seen in an image created by EnCase 6.13,
presumably using remote imaging. The image contained 3 different segment file
set identifiers. The first changes after an incomplete section. The second one
changed without any clear indication. The corresponding data section also
changed in some extent e.g. compression method and media flags, the is physical
flag being dropped. The change was consistent across multiple segment files. It
is unlikely that deliberate manipulation is involved. EnCase considers the
image as invalid.</p>
<p>Although with some tweaking of the individual segment file sets could be read.
In this case the data read from the segment file sets was heavily corrupted.
For now Keramics does not support reading multiple segment files sets from a
single image, but this might change in the future.</p>
<h2 id="ad-encryption"><a class="header" href="#ad-encryption">AD encryption</a></h2>
<p>As of version 2.8 FTK Imager supports "AD encryption". Although the output file
uses the EWF extensions the file actually is a AES-256 encrypted container. The
EWF can be encrypted using a pass-phrase or a certificate.</p>
<p>TODO: link to format definition</p>
<h2 id="references"><a class="header" href="#references">References</a></h2>
<ul>
<li><a href="http://www.asrdata.com/whitepaper-html">ASR Data - E01 Compression Format</a></li>
<li><a href="http://www.ietf.org/rfc/rfc4122.txt">RFC4122 - A Universally Unique Identifier (UUID) URN Namespace</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="expert-witness-compression-format-version-2-ewf2"><a class="header" href="#expert-witness-compression-format-version-2-ewf2">Expert Witness Compression Format version 2 (EWF2)</a></h1>
<p>TODO: add description</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mac-os-sparse-bundle-sparsebundle-format"><a class="header" href="#mac-os-sparse-bundle-sparsebundle-format">Mac OS sparse bundle (.sparsebundle) format</a></h1>
<p>The Mac OS sparse bundle (.sparsebundle) format is one of the disk image formats
supported natively by Mac OS.</p>
<p>The sparse bundle disk image was introduced in Mac OS X 10.5.</p>
<h2 id="overview-1"><a class="header" href="#overview-1">Overview</a></h2>
<p>A sparse bundle consists of a directory (bundle) with the .sparsbundle suffix
containing:</p>
<ul>
<li>"Info.bckup" file</li>
<li>"Info.plist" file</li>
<li>"token" file</li>
<li>"bands" directory containing the band files</li>
</ul>
<h3 id="characteristics"><a class="header" href="#characteristics">Characteristics</a></h3>
<div class="table-wrapper"><table><thead><th>Characteristics</th><th>Description</th></thead><tr><td>Byte order</td><td>N/A</td></tr>
<tr><td>Date and time values</td><td>N/A</td></tr>
<tr><td>Character strings</td><td>N/A</td></tr>
</table></div>
<h2 id="infoplist-and-infobckup-files"><a class="header" href="#infoplist-and-infobckup-files">Info.plist and Info.bckup files</a></h2>
<p>The Info.plist and its backup (Info.bckup) contain a <a href="plist.html">XML plist</a>.</p>
<p>This plist is also referred to as "Information Property List" and contains a
single dictionary with the following key-value pairs.</p>
<div class="table-wrapper"><table><thead><th>Identifier</th><th>Value</th><th>Description</th></thead><tr><td>CFBundleInfoDictionaryVersion</td><td>"6.0"</td><td>The information property list format version</td></tr>
<tr><td>band-size</td><td></td><td>The maximum size of a band file in bytes</td></tr>
<tr><td>bundle-backingstore-version</td><td>1</td><td>Unknown</td></tr>
<tr><td>diskimage-bundle-type</td><td>"com.apple.diskimage.sparsebundle"</td><td>The bundle type</td></tr>
<tr><td>size</td><td></td><td>The media size in bytes</td></tr>
</table></div>
<pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd"&gt;
&lt;plist version="1.0"&gt;
&lt;dict&gt;
        &lt;key&gt;CFBundleInfoDictionaryVersion&lt;/key&gt;
        &lt;string&gt;6.0&lt;/string&gt;
        &lt;key&gt;band-size&lt;/key&gt;
        &lt;integer&gt;8388608&lt;/integer&gt;
        &lt;key&gt;bundle-backingstore-version&lt;/key&gt;
        &lt;integer&gt;1&lt;/integer&gt;
        &lt;key&gt;diskimage-bundle-type&lt;/key&gt;
        &lt;string&gt;com.apple.diskimage.sparsebundle&lt;/string&gt;
        &lt;key&gt;size&lt;/key&gt;
        &lt;integer&gt;4194304&lt;/integer&gt;
&lt;/dict&gt;
&lt;/plist&gt;
</code></pre>
<h2 id="token-file"><a class="header" href="#token-file">Token file</a></h2>
<p>The token file is empty.</p>
<h2 id="bands-directory"><a class="header" href="#bands-directory">Bands directory</a></h2>
<p>The bands directory contains files containing the actual data of the bands. The
files are named using a hexadecimal naming scheme where "0" is the 1st band,
"a" the 10th, "f" the 15th, "10" the 16th, etc.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mac-os-sparse-image-sparseimage-format"><a class="header" href="#mac-os-sparse-image-sparseimage-format">Mac OS sparse image (.sparseimage) format</a></h1>
<p>The Mac OS sparse image (.sparseimage) format is one of the disk image formats
supported natively by Mac OS.</p>
<h2 id="overview-2"><a class="header" href="#overview-2">Overview</a></h2>
<p>A sparse disk image consists of:</p>
<ul>
<li>header data</li>
<li>bands data</li>
</ul>
<h3 id="characteristics-1"><a class="header" href="#characteristics-1">Characteristics</a></h3>
<div class="table-wrapper"><table><thead><th>Characteristics</th><th>Description</th></thead><tr><td>Byte order</td><td>big-endian</td></tr>
<tr><td>Date and time values</td><td>N/A</td></tr>
<tr><td>Character strings</td><td>N/A</td></tr>
</table></div>
<p>The number of bytes per sector is 512.</p>
<h2 id="header-data"><a class="header" href="#header-data">Header data</a></h2>
<p>The header data is 4096 bytes in size and consist of:</p>
<ul>
<li>file header</li>
<li>band numbers array</li>
<li>trailing data, which should be filled with 0-byte values</li>
</ul>
<h3 id="file-header-1"><a class="header" href="#file-header-1">File header</a></h3>
<p>The file header is 64 bytes in size and consist of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>4</td><td>"sprs"</td><td>Signature</td></tr>
<tr><td>4</td><td>4</td><td></td><td>Unknown (format version?), seen 3</td></tr>
<tr><td>8</td><td>4</td><td></td><td>Number of sectors per band</td></tr>
<tr><td>12</td><td>4</td><td></td><td>Unknown, seen 1</td></tr>
<tr><td>16</td><td>4</td><td></td><td>The media data size in sectors</td></tr>
<tr><td>20</td><td>12</td><td>0</td><td>Unknown (0-byte values)</td></tr>
<tr><td>32</td><td>4</td><td></td><td>Unknown</td></tr>
<tr><td>36</td><td>28</td><td>0</td><td>Unknown (0-byte values)</td></tr>
</table></div>
<h3 id="band-numbers-array"><a class="header" href="#band-numbers-array">Band numbers array</a></h3>
<p>The band numbers array consists of:</p>
<ul>
<li>one or more band numbers</li>
</ul>
<h4 id="band-number"><a class="header" href="#band-number">Band number</a></h4>
<p>A band number is 4 bytes in size and consist of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>4</td><td></td><td>Band number, where 0 indicates a sparse range and any other value refers to a location in the media data.</td></tr>
</table></div>
<p>Where the corresponding media offset can be calculated as following:</p>
<pre><code>media_offset = ( band_number - 1 ) * sectors_per_band * 512
</code></pre>
<p>The offset of band data can be calculated as following:</p>
<pre><code>band_data_offset = 4096 + ( array_index * sectors_per_band * 512 )
</code></pre>
<p>For example if the first array entry contains a band number of 4, then the
band data is located at offset 4096 and the corresponding media offset is:
<code>3 * sectors_per_band * 512</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="qemu-copy-on-write-qcow-image-file-format"><a class="header" href="#qemu-copy-on-write-qcow-image-file-format">QEMU Copy-On-Write (QCOW) image file format</a></h1>
<p>The QEMU Copy-On-Write (QCOW) image file format is used by the QEMU Open Source
Process Emulator to store disk images (storage media)</p>
<h2 id="overview-3"><a class="header" href="#overview-3">Overview</a></h2>
<p>A QCOW image file consists of:</p>
<ul>
<li>the file header
<ul>
<li>optional file header extensions</li>
</ul>
</li>
<li>the level 1 table (cluster aligned)</li>
<li>the reference count table (cluster aligned)</li>
<li>reference count blocks</li>
<li>snapshot headers (8-byte aligned on cluster boundary)</li>
<li>clusters containing:
<ul>
<li>level 2 tables</li>
<li>storage media data</li>
</ul>
</li>
</ul>
<p>The storage media data is stored in clusters. Each cluster is a multitude of
512 bytes. The level 1 (L1) table contains level 1 reference of level 2 (L2)
tables. The level 2 tables contain level 2 references of the storage media
clusters.</p>
<p>There are multiple versions of the QCOW image file format. QCOW (version 1)
and QCOW2 (version 2 and later) are sometimes considered even as separate image
formats. Version 3 is considered as an extended version of QCOW2.</p>
<h3 id="characteristics-2"><a class="header" href="#characteristics-2">Characteristics</a></h3>
<div class="table-wrapper"><table><thead><th>Characteristics</th><th>Description</th></thead><tr><td>Byte order</td><td>big-endian in most cases, note that some values are in little-endian</td></tr>
<tr><td>Date and time values</td><td>Number of seconds since Jan 1, 1970 00:00:00 UTC (POSIX epoch)</td></tr>
<tr><td>Character strings</td><td>UTF-8</td></tr>
</table></div>
<blockquote>
<p>Note that this docuement assumes that character strings are stored in UTF-8</p>
</blockquote>
<p>The number of bytes per sector is 512.</p>
<h3 id="encryption"><a class="header" href="#encryption">Encryption</a></h3>
<p>The QCOW image format can encrypted the media data stored in the image format.
Currently supported encryption methods are:</p>
<ul>
<li>AES-CBC 128-bit</li>
<li>Linux Unified Key Setup (LUKS)</li>
</ul>
<p>If no encryption is used the encryption method in the file header is set to
none (0).</p>
<blockquote>
<p>Note it is currently unknown if the format supports compression and encryption
at the same time. It does not appear to be supported by qemu-img.</p>
</blockquote>
<h4 id="aes-cbc-128-bit"><a class="header" href="#aes-cbc-128-bit">AES-CBC 128-bit</a></h4>
<p>Both encryption and decryption use:</p>
<ul>
<li>AES-CBC with a 128-bits key decryption of sector data</li>
</ul>
<p>The key is direct copy of the first 16 characters of a user provided (narrow
character) password. If the password is smaller than 16 characters. The
remaining key data is set to 0-byte values.</p>
<blockquote>
<p>Note that it is currently unclear which character sets are allowed and how
characters outside the 7-bit ASCII set should be handled.</p>
</blockquote>
<p>The initialization vector of the AES-CBC is using media data sector number
(relative to the start of the disk) in little-endian format as the first 64
bits of the 128 bit initialization vector. The remaining initialization vector
data is set to 0-byte values. The first sector number is 0 and the bytes per
sector are 512.</p>
<h4 id="linux-unified-key-setup-luks"><a class="header" href="#linux-unified-key-setup-luks">Linux Unified Key Setup (LUKS)</a></h4>
<p>TODO: complete section</p>
<h2 id="file-header-2"><a class="header" href="#file-header-2">File header</a></h2>
<h3 id="file-header--version-1"><a class="header" href="#file-header--version-1">File header – version 1</a></h3>
<p>The file header - version 1 is 48 bytes in size and consist of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>4</td><td>"QFI\xfb" or "\x51\x46\x49\xfb"</td><td>The signature (or magic identifier)</td></tr>
<tr><td>4</td><td>4</td><td>1</td><td>Format version</td></tr>
<tr><td>8</td><td>8</td><td></td><td>Backing file name offset</td></tr>
<tr><td>16</td><td>4</td><td></td><td>Backing file name size</td></tr>
<tr><td>20</td><td>4</td><td></td><td>Modification date and time, which contains a POSIX timestamp</td></tr>
<tr><td>24</td><td>8</td><td></td><td>Storage media size</td></tr>
<tr><td>32</td><td>1</td><td></td><td>Number of cluster block bits</td></tr>
<tr><td>33</td><td>1</td><td></td><td>Number of level 2 table bits</td></tr>
<tr><td>34</td><td>2</td><td></td><td>[yellow-background]<em>Unknown (empty values)</em></td></tr>
<tr><td>36</td><td>4</td><td></td><td>Encryption method</td></tr>
<tr><td>40</td><td>8</td><td></td><td>Level 1 table offset</td></tr>
</table></div>
<p>The cluster block size is calculated as:</p>
<pre><code>cluster block size = 1 &lt;&lt; number of cluster block bits
</code></pre>
<p>The level table 2 size is calculated as:</p>
<pre><code>level table 2 size = ( 1 &lt;&lt; number of level 2 table bits ) * 8
</code></pre>
<p>The level 1 table size is calculated as:</p>
<pre><code>level 1 table size = cluster block size * ( 1 &lt;&lt; number of level 2 table bits )

if( media size % level 1 table size != 0 )
{
    level 1 table size = ( media size / level 1 table size ) + 1
}
else
{
    level 1 table size = media size / level 1 table size
}
level 1 table size *= 8
</code></pre>
<p>The backing file name is set in snapshot image files and is normally stored
after the file header.</p>
<h3 id="file-header--version-2"><a class="header" href="#file-header--version-2">File header – version 2</a></h3>
<p>The file header - version 2 is 72 bytes in size and consist of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>4</td><td>"QFI\xfb" or "\x51\x46\x49\xfb"</td><td>The signature (or magic identifier)</td></tr>
<tr><td>4</td><td>4</td><td>2</td><td>Format version</td></tr>
<tr><td>8</td><td>8</td><td></td><td>Backing file name offset</td></tr>
<tr><td>16</td><td>4</td><td></td><td>Backing file name size</td></tr>
<tr><td>20</td><td>4</td><td></td><td>Number of cluster block bits</td></tr>
<tr><td>24</td><td>8</td><td></td><td>Storage media size</td></tr>
<tr><td>32</td><td>4</td><td></td><td>Encryption method</td></tr>
<tr><td>36</td><td>4</td><td></td><td>Number of level 1 table references</td></tr>
<tr><td>40</td><td>8</td><td></td><td>Level 1 table offset</td></tr>
<tr><td>48</td><td>8</td><td></td><td>Reference count table offset</td></tr>
<tr><td>56</td><td>4</td><td></td><td>Reference count table clusters</td></tr>
<tr><td>60</td><td>4</td><td></td><td>Number of snapshots</td></tr>
<tr><td>64</td><td>8</td><td></td><td>Snapshots offset</td></tr>
</table></div>
<p>The cluster block size is calculated as:</p>
<pre><code>cluster block size = 1 &lt;&lt; number of cluster block bits
</code></pre>
<p>The number of level 2 table bits is calculated as:</p>
<pre><code>number of level 2 table bits = number of cluster block bits - 3
</code></pre>
<p>The level table 2 size is calculated as:</p>
<pre><code>level table 2 size = ( 1 &lt;&lt; number of level 2 table bits ) * 8
</code></pre>
<p>The level 1 table size is calculated as:</p>
<pre><code>level 1 table size = number of level 1 table references * 8
</code></pre>
<p>The backing file name is set in snapshot image files and is normally stored
after the file header.</p>
<h3 id="file-header--version-3"><a class="header" href="#file-header--version-3">File header – version 3</a></h3>
<p>The file header - version 3 is 104 or 112 bytes in size and consist of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>4</td><td>"QFI\xfb" or "\x51\x46\x49\xfb"</td><td>The signature (or magic identifier)</td></tr>
<tr><td>4</td><td>4</td><td>3</td><td>Format version</td></tr>
<tr><td>8</td><td>8</td><td></td><td>Backing file name offset</td></tr>
<tr><td>16</td><td>4</td><td></td><td>Backing file name size</td></tr>
<tr><td>20</td><td>4</td><td></td><td>Number of cluster block bits</td></tr>
<tr><td>24</td><td>8</td><td></td><td>Storage media size</td></tr>
<tr><td>32</td><td>4</td><td></td><td>Encryption method</td></tr>
<tr><td>36</td><td>4</td><td></td><td>Number of level 1 table references</td></tr>
<tr><td>40</td><td>8</td><td></td><td>Level 1 table offset</td></tr>
<tr><td>48</td><td>8</td><td></td><td>Reference count table offset</td></tr>
<tr><td>56</td><td>4</td><td></td><td>Reference count table clusters</td></tr>
<tr><td>60</td><td>4</td><td></td><td>Number of snapshots</td></tr>
<tr><td>64</td><td>8</td><td></td><td>Snapshots offset</td></tr>
<tr><td>72</td><td>8</td><td></td><td>Incompatible feature flags</td></tr>
<tr><td>80</td><td>8</td><td></td><td>Compatible feature flags</td></tr>
<tr><td>88</td><td>8</td><td></td><td>Auto-clear feature flags</td></tr>
<tr><td>96</td><td>4</td><td></td><td>Reference count order</td></tr>
<tr><td>100</td><td>4</td><td>104 or 112</td><td>File header size, which contains the size of the file header, this value does not include the size of the file header extensions</td></tr>
<tr><td colspan="4"> <em>If file header size equals 112</em></tr>
<tr><td>104</td><td>1</td><td></td><td>Compression method</td></tr>
<tr><td>105</td><td>7</td><td></td><td>Unknown (padding)</td></tr>
</table></div>
<p>The cluster block size is calculated as:</p>
<pre><code>cluster block size = 1 &lt;&lt; number of cluster block bits
</code></pre>
<p>The number of level 2 table bits is calculated as:</p>
<pre><code>number of level 2 table bits = number of cluster block bits - 3
</code></pre>
<p>The level table 2 size is calculated as:</p>
<pre><code>level table 2 size = ( 1 &lt;&lt; number of level 2 table bits ) * 8
</code></pre>
<p>The level 1 table size is calculated as:</p>
<pre><code>level 1 table size = number of level 1 table references * 8
</code></pre>
<p>The backing file name is set in snapshot image files and is normally stored
after the file header.</p>
<h3 id="encryption-methods"><a class="header" href="#encryption-methods">Encryption methods</a></h3>
<div class="table-wrapper"><table><thead><th>Value</th><th>Identifier</th><th>Description</th></thead><tr><td>0</td><td>QCOW_CRYPT_NONE</td><td>No encryption</td></tr>
<tr><td>1</td><td>QCOW_CRYPT_AES</td><td>AES-CBC 128-bits encryption</td></tr>
<tr><td>2</td><td>QCOW_CRYPT_LUKS</td><td>Linux Unified Key Setup (LUKS) encryption</td></tr>
</table></div>
<h3 id="incompatible-feature-flags"><a class="header" href="#incompatible-feature-flags">Incompatible feature flags</a></h3>
<div class="table-wrapper"><table><thead><th>Value</th><th>Identifier</th><th>Description</th></thead><tr><td>0x00000001</td><td>QCOW2_INCOMPAT_DIRTY</td><td></td></tr>
<tr><td>0x00000002</td><td>QCOW2_INCOMPAT_CORRUPT</td><td></td></tr>
<tr><td>0x00000004</td><td>QCOW2_INCOMPAT_DATA_FILE</td><td></td></tr>
<tr><td>0x00000008</td><td>QCOW2_INCOMPAT_COMPRESSION</td><td></td></tr>
<tr><td>0x00000010</td><td>QCOW2_INCOMPAT_EXTL2</td><td></td></tr>
</table></div>
<h3 id="compatible-feature-flags"><a class="header" href="#compatible-feature-flags">Compatible feature flags</a></h3>
<div class="table-wrapper"><table><thead><th>Value</th><th>Identifier</th><th>Description</th></thead><tr><td>0x00000001</td><td>QCOW2_COMPAT_LAZY_REFCOUNTS</td><td></td></tr>
</table></div>
<h3 id="auto-clear-feature-flags"><a class="header" href="#auto-clear-feature-flags">Auto-clear feature flags</a></h3>
<div class="table-wrapper"><table><thead><th>Value</th><th>Identifier</th><th>Description</th></thead><tr><td>0x00000001</td><td>QCOW2_AUTOCLEAR_BITMAPS</td><td></td></tr>
<tr><td>0x00000002</td><td>QCOW2_AUTOCLEAR_DATA_FILE_RAW</td><td></td></tr>
</table></div>
<h3 id="compression-methods"><a class="header" href="#compression-methods">Compression methods</a></h3>
<div class="table-wrapper"><table><thead><th>Value</th><th>Identifier</th><th>Description</th></thead><tr><td>0</td><td></td><td>ZLIB compression</td></tr>
</table></div>
<h3 id="file-header-extensions"><a class="header" href="#file-header-extensions">File header extensions</a></h3>
<p>A file header extension consist of:</p>
<ul>
<li>file header extension header</li>
<li>file header extension data</li>
</ul>
<h4 id="file-header-extension-header"><a class="header" href="#file-header-extension-header">File header extension header</a></h4>
<p>The file header extension header is 8 bytes in size and consist of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>4</td><td></td><td>The extension type (signature)</td></tr>
<tr><td>4</td><td>4</td><td></td><td>The extension data size</td></tr>
</table></div>
<h4 id="file-header-extension-types"><a class="header" href="#file-header-extension-types">File header extension types</a></h4>
<div class="table-wrapper"><table><thead><th>Value</th><th>Identifier</th><th>Description</th></thead><tr><td>0x0537be77</td><td>QCOW2_EXT_MAGIC_CRYPTO_HEADER</td><td>Crypto header</td></tr>
<tr><td>0x23852875</td><td>QCOW2_EXT_MAGIC_BITMAPS</td><td>Bitmaps</td></tr>
<tr><td>0x44415441 or "DATA"</td><td>QCOW2_EXT_MAGIC_DATA_FILE</td><td>Data-file</td></tr>
<tr><td>0x6803f857</td><td>QCOW2_EXT_MAGIC_FEATURE_TABLE</td><td>Feature table</td></tr>
<tr><td>0xe2792aca</td><td>QCOW2_EXT_MAGIC_BACKING_FORMAT</td><td>Backing format</td></tr>
</table></div>
<h4 id="backing-format-file-header-extension"><a class="header" href="#backing-format-file-header-extension">Backing format file header extension</a></h4>
<p>The backing format file header extension header is of variable size and consist
of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>...</td><td></td><td>Backing format identifier, which contains an UTF-8 string without end-of-string character</td></tr>
</table></div>
<h4 id="bitmaps-file-header-extension"><a class="header" href="#bitmaps-file-header-extension">Bitmaps file header extension</a></h4>
<p>TODO: complete section</p>
<h4 id="crypto-header-file-header-extension"><a class="header" href="#crypto-header-file-header-extension">Crypto header file header extension</a></h4>
<p>The crypto header file header extension header is 16 bytes in size and consist
of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>8</td><td></td><td>The crypto data offset</td></tr>
<tr><td>8</td><td>8</td><td></td><td>The crypto data size</td></tr>
</table></div>
<h4 id="data-file-file-header-extension"><a class="header" href="#data-file-file-header-extension">Data-file file header extension</a></h4>
<p>The data-file file header extension header is of variable size and consist of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>...</td><td></td><td>Data-file filename, which contains an UTF-8 string without end-of-string character</td></tr>
</table></div>
<h4 id="feature-table-file-header-extension"><a class="header" href="#feature-table-file-header-extension">Feature table file header extension</a></h4>
<p>TODO: complete section</p>
<h2 id="level-1-table"><a class="header" href="#level-1-table">Level 1 table</a></h2>
<p>The level 1 table contains level 2 table references.</p>
<p>A reference value of 0 represents unused or unallocated and is considered as
sparse or stored in a corresponding backing file.</p>
<h3 id="level-2-table-reference--version-1"><a class="header" href="#level-2-table-reference--version-1">Level 2 table reference – version 1</a></h3>
<p>The level 2 table reference is 8-bytes in size and consists of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0.0</td><td>63 bits</td><td></td><td>Level 2 table offset, which contains an offset relative from the start of the file</td></tr>
<tr><td>7.7</td><td>1 bit</td><td>QCOW_OFLAG_COMPRESSED</td><td>Is compressed flag</td></tr>
</table></div>
<h3 id="level-2-table-reference--version-2-or-3"><a class="header" href="#level-2-table-reference--version-2-or-3">Level 2 table reference – version 2 or 3</a></h3>
<p>The level 2 table reference is 8-bytes in size and consists of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0.0</td><td>62 bits</td><td></td><td>Level 2 table offset, which contains an offset relative from the start of the file</td></tr>
<tr><td>7.6</td><td>1 bit</td><td>QCOW_OFLAG_COMPRESSED</td><td>Is compressed flag</td></tr>
<tr><td>7.7</td><td>1 bit</td><td>QCOW_OFLAG_COPIED</td><td>Is copied flag</td></tr>
</table></div>
<p>The is copied flag indicates that the reference count of the corresponding
level 2 table is exactly one.</p>
<h2 id="level-2-table"><a class="header" href="#level-2-table">Level 2 table</a></h2>
<p>The level 2 table contains cluster block references.</p>
<p>The level 2 table size is calculated as:</p>
<pre><code>level 2 table size = ( 1 &lt;&lt; number of level 2 table bits ) * 8
</code></pre>
<p>A reference value of 0 represents unused or unallocated and is considered as
sparse or stored in a corresponding backing file.</p>
<h3 id="cluster-block-reference--version-1"><a class="header" href="#cluster-block-reference--version-1">Cluster block reference – version 1</a></h3>
<p>The cluster block reference - version 1 is 8-bytes in size and consists of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0.0</td><td>63 bits</td><td></td><td>Cluster block offset, which contains an offset relative to the start of the cluster block</td></tr>
<tr><td>7.7</td><td>1 bit</td><td>QCOW_OFLAG_COMPRESSED</td><td>Is compressed flag</td></tr>
</table></div>
<h3 id="cluster-block-reference--version-2-or-3"><a class="header" href="#cluster-block-reference--version-2-or-3">Cluster block reference – version 2 or 3</a></h3>
<p>The cluster block reference - version 2 or 3 is 8-bytes in size and consists of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0.0</td><td>62 bits</td><td></td><td>Cluster block offset, which contains an offset relative to the start of the cluster block</td></tr>
<tr><td>7.6</td><td>1 bit</td><td>QCOW_OFLAG_COMPRESSED</td><td>Is compressed flag</td></tr>
<tr><td>7.7</td><td>1 bit</td><td>QCOW_OFLAG_COPIED</td><td>Is copied flag</td></tr>
</table></div>
<p>The is copied flag indicates that the reference count of the corresponding
cluster block is exactly one.</p>
<h2 id="reference-count-table"><a class="header" href="#reference-count-table">Reference count table</a></h2>
<p>The cluster data blocks are referenced counted. For every cluster data block a
16-bit reference count is stored in the reference count table.</p>
<p>The reference count table is stored in cluster block sizes. The file header
contains the number of blocks (or reference count table clusters).</p>
<p>TODO: complete section</p>
<h3 id="notes-2"><a class="header" href="#notes-2">Notes</a></h3>
<pre><code>reference count cluster block offset = cluster data block offset /
reference count table offset = cluster data block /

In order to obtain the reference count of a given cluster, you split the
cluster offset into a refcount table offset and refcount block offset.

Since a refcount block is a single cluster of 2 byte entries, the lower
cluster_size - 1 bits is used as the block offset and the rest of the bits are
used as the table offset.

One optimization is that if any cluster pointed to by an L1 or L2 table entry
has a refcount exactly equal to one, the most significant bit of the L1/L2
entry is set as a "copied" flag. This indicates that no snapshots are using
this cluster and it can be immediately written to without having to make a copy
for any snapshots referencing it.
</code></pre>
<h2 id="cluster-data-block"><a class="header" href="#cluster-data-block">Cluster data block</a></h2>
<p>To retrieve a cluster data block corresponding a certain storage media offset:</p>
<p>Determine the level 1 table index from the offset:</p>
<pre><code>level 1 table index bit shift = number of cluster block bits + number of level 2 table bits
</code></pre>
<p>For version 1:</p>
<pre><code>level 1 table index = ( offset &amp; 0x7fffffffffffffffULL ) &gt;&gt; level 1 table index bit shift
</code></pre>
<p>For version 2 and 3:</p>
<pre><code>level 1 table index = ( offset &amp; 0x3fffffffffffffffULL ) &gt;&gt; level 1 table index bit shift
</code></pre>
<p>Retrieve the level 2 table offset from the level 1 table. If the level table 2
offset is 0 and the image has a backing file the cluster data block is stored
in the backing file otherwise the cluster block is considered sparse.</p>
<p>Read the corresponding level 2 table.</p>
<p>Determine the level 2 table index from the offset:</p>
<pre><code>level 2 table index bit mask = ~( 0xffffffffffffffffULL &lt;&lt; number of level 2 table bits )
</code></pre>
<pre><code>level 2 table index = ( offset &gt;&gt; number of cluster block bits ) &gt;&gt; level 2 table index bit mask
</code></pre>
<p>Retrieve the cluster block offset from the level 2 table. If the cluster block
offset is 0 and the image has a backing file the cluster data block is stored
in the backing file otherwise the cluster block is considered sparse.</p>
<h3 id="uncompressed-cluster-data-block"><a class="header" href="#uncompressed-cluster-data-block">Uncompressed cluster data block</a></h3>
<p>If the is compressed flag (QCOW_OFLAG_COMPRESSED) is not set:</p>
<pre><code>cluster block bit mask = ~( 0xffffffffffffffffULL &lt;&lt; number of cluster block bits )
</code></pre>
<pre><code>cluster block data offset = ( offset &amp; cluster block bit mask ) + cluster block offset
</code></pre>
<p>Note that in version 2 or 3 the last cluster block in the file can be smaller than
the cluster block size defined by the number of cluster block bits in the file
header. This does not seem to be the case for version 1.</p>
<h3 id="compressed-cluster-data-block"><a class="header" href="#compressed-cluster-data-block">Compressed cluster data block</a></h3>
<p>If the is compressed flag (QCOW_OFLAG_COMPRESSED) is set the cluster block data
is stored using the compression method defined by the file header or DEFLATE by
default.</p>
<p>Multiple compressed cluster data blocks are stored together in cluster block
sizes. The compressed cluster data blocks are sector (512 bytes) aligned.</p>
<p>The compressed data uses a DEFLATE (inflate) window bits value of -12</p>
<h4 id="compressed-chunk-data-block--version-1"><a class="header" href="#compressed-chunk-data-block--version-1">Compressed chunk data block – version 1</a></h4>
<pre><code>compressed size bit shift = 63 - number of cluster block bits
</code></pre>
<pre><code>compressed block size = ( ( cluster block offset &amp; 0x7fffffffffffffffULL ) &gt;&gt; compressed size bit shift
</code></pre>
<pre><code>compressed block offset &amp;= ~( 0xffffffffffffffffULL &lt;&lt; compressed size bit shift )
</code></pre>
<h4 id="compressed-chunk-data-block--version-2-or-3"><a class="header" href="#compressed-chunk-data-block--version-2-or-3">Compressed chunk data block – version 2 or 3</a></h4>
<pre><code>compressed size bit shift = 62 - ( number of cluster block bits – 8 )
</code></pre>
<p>According to "the QCOW2 Image Format" the compressed block size is calculated
as following:</p>
<pre><code>compressed block size = ( ( ( cluster block offset &amp; 0x3fffffffffffffffULL ) &gt;&gt; compressed size bit shift ) + 1 ) * 512
</code></pre>
<p>Since the compressed block size is stored in 512 byte sectors this value does
not contain the exact byte size of the compressed cluster block data. It
sometimes lacks the size of the last partially filled sector and one sector
should be added if possible within the bounds of the cluster blocks size and
the file size.</p>
<pre><code>cluster block offset &amp;= ~( 0xffffffffffffffffULL &lt;&lt; compressed size bit shift )
</code></pre>
<h2 id="snapshots"><a class="header" href="#snapshots">Snapshots</a></h2>
<p>As of version 1 QCOW can use the backing file name in the file header to point
to a backing file (or parent image) that contains the snapshot image where the
current image only contains the modifications. Version 2 adds support to store
snapshot inside the image.</p>
<h3 id="snapshot-header---version-2-or-3"><a class="header" href="#snapshot-header---version-2-or-3">Snapshot header - version 2 or 3</a></h3>
<p>An in-image snapshot is created by adding a snapshot header, copying the L1
table and incrementing the reference counts of all L2 tables and data clusters
referenced by the L1 table.</p>
<p>The snapshot header is of variable size and consists of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>8</td><td></td><td>Level 1 table offset</td></tr>
<tr><td>8</td><td>4</td><td></td><td>Level 1 size</td></tr>
<tr><td>12</td><td>2</td><td></td><td>Identifier string size</td></tr>
<tr><td>14</td><td>2</td><td></td><td>Name size</td></tr>
<tr><td>16</td><td>4</td><td></td><td>Date in seconds</td></tr>
<tr><td>20</td><td>4</td><td></td><td>Date in nano seconds</td></tr>
<tr><td>24</td><td>8</td><td></td><td>VM clock in nano seconds</td></tr>
<tr><td>32</td><td>4</td><td></td><td>VM state size</td></tr>
<tr><td>36</td><td>4</td><td></td><td>Extra data size</td></tr>
<tr><td>40</td><td>...</td><td></td><td>Extra data</td></tr>
<tr><td>...</td><td>...</td><td></td><td>Identifier string size</td></tr>
<tr><td>...</td><td>...</td><td></td><td>Name</td></tr>
</table></div>
<p>TODO: complete section</p>
<h2 id="references-1"><a class="header" href="#references-1">References</a></h2>
<ul>
<li><a href="https://web.archive.org/web/20201006212750/https://people.gnome.org/~markmc/qcow-image-format-version-1.html">The QCOW Image Format</a>, by Mark McLoughlin</li>
<li><a href="https://web.archive.org/web/20121004073848/http://people.gnome.org/~markmc/qcow-image-format.html">The QCOW2 Image Format</a>, by Mark McLoughlin</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="universal-disk-image-format-udif"><a class="header" href="#universal-disk-image-format-udif">Universal Disk Image Format (UDIF)</a></h1>
<p>The Universal Disk Image Format (UDIF) (.dmg) is one of the disk image formats
supported natively by Mac OS.</p>
<h2 id="overview-4"><a class="header" href="#overview-4">Overview</a></h2>
<p>Known UDIF image types are:</p>
<div class="table-wrapper"><table><thead><th>Identifier</th><th>Description</th></thead><tr><td>UDBZ</td><td>bzip2 compressed UDIF</td></tr>
<tr><td>UDCO</td><td>Apple Data Compression (ADC) compressed UDIF</td></tr>
<tr><td>UDIF</td><td>Read-write uncompressed UDIF</td></tr>
<tr><td>UDRO</td><td>Read-only uncompressed UDIF</td></tr>
<tr><td>UDxx</td><td>Uncompressed UDIF</td></tr>
<tr><td>UDZO</td><td>zlib/DEFLATE compressed UDIF</td></tr>
<tr><td>ULFO</td><td>LZFSE compressed UDIF</td></tr>
<tr><td>ULMO</td><td>LZMA compressed UDIF</td></tr>
</table></div>
<p>UDIF images are either uncompressed or compressed.</p>
<h3 id="uncompressed-image-format"><a class="header" href="#uncompressed-image-format">Uncompressed image format</a></h3>
<p>An uncompressed UDIF image consist of:</p>
<ul>
<li>data</li>
<li>optional file footer</li>
</ul>
<blockquote>
<p>Note that an uncompressed UDIF image without file footer is equivalent to a
RAW storage media image (CRawDiskImage).</p>
</blockquote>
<h3 id="compressed-image-format"><a class="header" href="#compressed-image-format">Compressed image format</a></h3>
<p>A compressed UDIF image consist of:</p>
<ul>
<li>Data fork</li>
<li>Optional resource fork</li>
<li>Optional XML plist</li>
<li>File footer the end of the image file</li>
</ul>
<h3 id="characteristics-3"><a class="header" href="#characteristics-3">Characteristics</a></h3>
<div class="table-wrapper"><table><thead><th>Characteristics</th><th>Description</th></thead><tr><td>Byte order</td><td>big-endian</td></tr>
<tr><td>Date and time values</td><td>N/A</td></tr>
<tr><td>Character strings</td><td>N/A</td></tr>
</table></div>
<p>The number of bytes per sector is 512.</p>
<h2 id="file-footer"><a class="header" href="#file-footer">File footer</a></h2>
<p>The file footer (also known as resource file or metadata) is 512 bytes in size
and consists of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>4</td><td>"koly"</td><td>Signature</td></tr>
<tr><td>4</td><td>4</td><td>4</td><td>Format version</td></tr>
<tr><td>8</td><td>4</td><td>512</td><td>File footer size in bytes</td></tr>
<tr><td>12</td><td>4</td><td></td><td><a href="udif.html#image_flags">Image flags</a></td></tr>
<tr><td>16</td><td>8</td><td></td><td>Unknown (RunningDataForkOffset)</td></tr>
<tr><td>24</td><td>8</td><td></td><td>Data fork offset, where the offset is relative from the start of the image file</td></tr>
<tr><td>32</td><td>8</td><td></td><td>Data fork size</td></tr>
<tr><td>40</td><td>8</td><td></td><td>Resource fork offset, where the offset is relative from the start of the image file</td></tr>
<tr><td>48</td><td>8</td><td></td><td>Resource fork size</td></tr>
<tr><td>56</td><td>4</td><td></td><td>Unknown (SegmentNumber)</td></tr>
<tr><td>60</td><td>4</td><td></td><td>Number of segments, which contains 0 if not set</td></tr>
<tr><td>64</td><td>16</td><td></td><td>Segment identifier, which contains an UUID</td></tr>
<tr><td>80</td><td>4</td><td></td><td>Data checksum type</td></tr>
<tr><td>84</td><td>4</td><td></td><td>Data checksum size, as number of bits</td></tr>
<tr><td>88</td><td>128</td><td></td><td>Data checksum</td></tr>
<tr><td>216</td><td>8</td><td></td><td>XML plist offset, where the offset is relative from the start of the image file</td></tr>
<tr><td>224</td><td>8</td><td></td><td>XML plist size</td></tr>
<tr><td>232</td><td>120</td><td></td><td>Unknown (Reserved)</td></tr>
<tr><td>352</td><td>4</td><td></td><td>Master checksum type</td></tr>
<tr><td>356</td><td>4</td><td></td><td>Master checksum size, as number of bits</td></tr>
<tr><td>360</td><td>128</td><td></td><td>Master checksum</td></tr>
<tr><td>488</td><td>4</td><td></td><td><a href="udif.html#image_type">Image type</a> (or variant)</td></tr>
<tr><td>492</td><td>8</td><td></td><td>Number of sectors</td></tr>
<tr><td>500</td><td>4</td><td></td><td>Unknown (reserved)</td></tr>
<tr><td>504</td><td>4</td><td></td><td>Unknown (reserved)</td></tr>
<tr><td>508</td><td>4</td><td></td><td>Unknown (reserved)</td></tr>
</table></div>
<blockquote>
<p>Note that the XML plist size can be 0, such as in an UDIF stub (UDxx) image.</p>
</blockquote>
<h3 id="image-flags"><a class="header" href="#image-flags"><a name="image_flags"></a>Image flags</a></h3>
<div class="table-wrapper"><table><thead><th>Value</th><th>Identifier</th><th>Description</th></thead><tr><td>0x00000001</td><td>kUDIFFlagsFlattened</td><td>Unknown (flattened?)</td></tr>
<tr><td></td><td></td><td></td></tr>
<tr><td>0x00000004</td><td>kUDIFFlagsInternetEnabled</td><td>Unknown (internet enabled?)</td></tr>
</table></div>
<h3 id="image-types"><a class="header" href="#image-types"><a name="image_types"></a>Image types</a></h3>
<div class="table-wrapper"><table><thead><th>Value</th><th>Identifier</th><th>Description</th></thead><tr><td>1</td><td>kUDIFDeviceImageType</td><td>Device image</td></tr>
<tr><td>2</td><td>kUDIFPartitionImageType</td><td>Paritition image</td></tr>
</table></div>
<h2 id="xml-plist"><a class="header" href="#xml-plist">XML plist</a></h2>
<p>TODO: complete section</p>
<pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd"&gt;
&lt;plist version="1.0"&gt;
&lt;dict&gt;
        &lt;key&gt;resource-fork&lt;/key&gt;
        &lt;dict&gt;
                &lt;key&gt;blkx&lt;/key&gt;
                &lt;array&gt;
                        &lt;dict&gt;
                                &lt;key&gt;Attributes&lt;/key&gt;
                                &lt;string&gt;0x0050&lt;/string&gt;
                                &lt;key&gt;CFName&lt;/key&gt;
                                &lt;string&gt;Protective Master Boot Record (MBR : 0)&lt;/string&gt;
                                &lt;key&gt;Data&lt;/key&gt;
                                &lt;data&gt;
                                bWlzaAAAAAEAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAA
                                AAgIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
                                AAIAAAAgQfL6MwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
                                AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
                                AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
                                AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
                                AAAAAAACgAAABQAAAAMAAAAAAAAAAAAAAAAAAAABAAAA
                                AAAAIA0AAAAAAAAAH/////8AAAAAAAAAAAAAAAEAAAAA
                                AAAAAAAAAAAAAAAAAAAAAAAAAAA=
                                &lt;/data&gt;
                                &lt;key&gt;ID&lt;/key&gt;
                                &lt;string&gt;-1&lt;/string&gt;
                                &lt;key&gt;Name&lt;/key&gt;
                                &lt;string&gt;Protective Master Boot Record (MBR : 0)&lt;/string&gt;
                        &lt;/dict&gt;
                        ...
                &lt;/array&gt;
                &lt;key&gt;plst&lt;/key&gt;
                &lt;array&gt;
                        &lt;dict&gt;
                                &lt;key&gt;Attributes&lt;/key&gt;
                                &lt;string&gt;0x0050&lt;/string&gt;
                                &lt;key&gt;Data&lt;/key&gt;
                                &lt;data&gt;
                                AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
                                AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
                                AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
                                AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
                                AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
                                AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
                                AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
                                AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
                                AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
                                AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
                                AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
                                AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
                                AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
                                AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
                                AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
                                AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAQAAAAAAAAAA
                                AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
                                AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
                                AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
                                AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
                                AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
                                AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
                                AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
                                AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
                                AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
                                AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
                                AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
                                AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
                                AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
                                AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
                                AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
                                AAAAAAAAAAAA
                                &lt;/data&gt;
                                &lt;key&gt;ID&lt;/key&gt;
                                &lt;string&gt;0&lt;/string&gt;
                                &lt;key&gt;Name&lt;/key&gt;
                                &lt;string&gt;&lt;/string&gt;
                        &lt;/dict&gt;
                &lt;/array&gt;
        &lt;/dict&gt;
&lt;/dict&gt;
&lt;/plist&gt;
</code></pre>
<p>The XML plist contains the following key-value pairs:</p>
<div class="table-wrapper"><table><thead><th>Identifier</th><th>Description</th></thead><tr><td>resource-fork</td><td>dictionary</td></tr>
</table></div>
<h3 id="xml-plist-resource-fork-dictionary"><a class="header" href="#xml-plist-resource-fork-dictionary">XML plist resource-fork dictionary</a></h3>
<p>The resource-fork dictionary contains the following key-value pairs:</p>
<div class="table-wrapper"><table><thead><th>Identifier</th><th>Description</th></thead><tr><td>blkx</td><td>array of dictionaries</td></tr>
<tr><td>plst</td><td>array of dictionaries</td></tr>
</table></div>
<h3 id="xml-plist-blkx-array-entry"><a class="header" href="#xml-plist-blkx-array-entry">XML plist blkx array entry</a></h3>
<p>A blkx array entry contains the following key-value pairs:</p>
<div class="table-wrapper"><table><thead><th>Identifier</th><th>Description</th></thead><tr><td>Attributes</td><td>string that contains a hexadecimal formatted integer value</td></tr>
<tr><td>CFName</td><td>string</td></tr>
<tr><td>Data</td><td>string that contains base-64 encoded data of a <a href="udif.html#udif_block_table">block table</a></td></tr>
<tr><td>ID</td><td>string that contains a decimal formatted integer value</td></tr>
<tr><td>Name</td><td>string</td></tr>
</table></div>
<h2 id="block-table"><a class="header" href="#block-table"><a name="udif_block_table"></a>Block table</a></h2>
<p>The block table (BLKXTable) is of variable size and consists of:</p>
<ul>
<li>block table header</li>
<li>block table entries</li>
</ul>
<h3 id="the-block-table-header"><a class="header" href="#the-block-table-header">The block table header</a></h3>
<p>The block table header is 204 bytes in size and consists of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>4</td><td>"mish"</td><td>Signature</td></tr>
<tr><td>4</td><td>4</td><td>1</td><td>Format version</td></tr>
<tr><td>8</td><td>8</td><td></td><td>Start sector, which contains the sector number relative to the start of the media data</td></tr>
<tr><td>16</td><td>8</td><td></td><td>Number of sectors</td></tr>
<tr><td>24</td><td>8</td><td></td><td>Unknown (DataOffset), which seems to be always 0</td></tr>
<tr><td>32</td><td>4</td><td></td><td>Unknown (BuffersNeeded)</td></tr>
<tr><td>36</td><td>4</td><td></td><td>Unknown (BlockDescriptors). Does this value correspond to the number of block table entries?</td></tr>
<tr><td>40</td><td>4</td><td>0</td><td>Unknown (reserved)</td></tr>
<tr><td>44</td><td>4</td><td>0</td><td>Unknown (reserved)</td></tr>
<tr><td>48</td><td>4</td><td>0</td><td>Unknown (reserved)</td></tr>
<tr><td>52</td><td>4</td><td>0</td><td>Unknown (reserved)</td></tr>
<tr><td>56</td><td>4</td><td>0</td><td>Unknown (reserved)</td></tr>
<tr><td>60</td><td>4</td><td>0</td><td>Unknown (reserved)</td></tr>
<tr><td>64</td><td>4</td><td></td><td>Checksum type</td></tr>
<tr><td>68</td><td>4</td><td></td><td>Checksum size</td></tr>
<tr><td>72</td><td>128</td><td></td><td>Checksum</td></tr>
<tr><td>200</td><td>4</td><td></td><td>Number of entries</td></tr>
</table></div>
<h3 id="block-table-entry"><a class="header" href="#block-table-entry">Block table entry</a></h3>
<p>The block table entry (BLKXChunkEntry) is 40 bytes in size and consists of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>4</td><td></td><td><a href="udif.html#udif_block_table_entry_types">Entry type</a></td></tr>
<tr><td>4</td><td>4</td><td></td><td>Unknown (comment)</td></tr>
<tr><td>8</td><td>8</td><td></td><td>Start sector, which contains the sector number relative to the start of the start sector of the block table</td></tr>
<tr><td>16</td><td>8</td><td></td><td>Number of sectors</td></tr>
<tr><td>24</td><td>8</td><td></td><td>Data offset, which contains the byte offset relative to the start of the UDIF image file</td></tr>
<tr><td>32</td><td>8</td><td></td><td>Data size, which contain the number of bytes of data stored, which is 0 for sparse data</td></tr>
</table></div>
<h4 id="udif-block-table-entry-types"><a class="header" href="#udif-block-table-entry-types"><a name="udif_block_table_entry_types"></a>UDIF block table entry types</a></h4>
<div class="table-wrapper"><table><thead><th>Value</th><th>Identifier</th><th>Description</th></thead><tr><td>0x00000000</td><td></td><td>Unknown (sparse)</td></tr>
<tr><td>0x00000001</td><td></td><td>Uncompressed (raw) data</td></tr>
<tr><td>0x00000002</td><td></td><td>Sparse (used for Apple_Free)</td></tr>
<tr><td></td><td></td><td></td></tr>
<tr><td>0x7ffffffe</td><td></td><td>Comment</td></tr>
<tr><td></td><td></td><td></td></tr>
<tr><td>0x80000004</td><td></td><td>ADC compressed data</td></tr>
<tr><td>0x80000005</td><td></td><td>zlib compressed data</td></tr>
<tr><td>0x80000006</td><td></td><td>bzip2 compressed data</td></tr>
<tr><td>0x80000007</td><td></td><td>LZFSE compressed data</td></tr>
<tr><td>0x80000008</td><td></td><td>LZMA compressed data</td></tr>
<tr><td></td><td></td><td></td></tr>
<tr><td>0xffffffff</td><td></td><td>Block table entries terminator</td></tr>
</table></div>
<h2 id="udif-comment"><a class="header" href="#udif-comment">UDIF comment</a></h2>
<p>TODO: complete section</p>
<h2 id="udif-data-fork"><a class="header" href="#udif-data-fork">UDIF data fork</a></h2>
<p>TODO: complete section</p>
<h2 id="udif-resource-fork"><a class="header" href="#udif-resource-fork">UDIF resource fork</a></h2>
<p>TODO: complete section</p>
<h2 id="notes-3"><a class="header" href="#notes-3">Notes</a></h2>
<pre><code>Is the maximum compressed chunk size 2048 sectors?
</code></pre>
<pre><code>Comment seems to reference compressed data but has no size or number of sectors
value.
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="virtual-hard-disk-vhd-image-format"><a class="header" href="#virtual-hard-disk-vhd-image-format">Virtual Hard Disk (VHD) image format</a></h1>
<p>The Virtual Hard Disk (VHD) format is used by Microsoft vitualization products
as one of its image format. It is both used the store hard disk images and
snapshots.</p>
<h2 id="overview-5"><a class="header" href="#overview-5">Overview</a></h2>
<p>There are multiple types of VHD images, namely:</p>
<ul>
<li>Fixed-size VHD image</li>
<li>Dynamic-size (or sparse) VHD image</li>
<li>Differential (or differencing) VHD image</li>
</ul>
<h3 id="fixed-size-hard-disk-image"><a class="header" href="#fixed-size-hard-disk-image">Fixed-size hard disk image</a></h3>
<p>A fixed-size VHD image consists of:</p>
<ul>
<li>data</li>
<li>file footer</li>
</ul>
<blockquote>
<p>Note that a fixed-size VHD image is equivalent to a raw storage media image
with an additional footer.</p>
</blockquote>
<h3 id="dynamic-size-or-sparse-hard-disk-image"><a class="header" href="#dynamic-size-or-sparse-hard-disk-image">Dynamic-size (or sparse) hard disk image</a></h3>
<p>A dynamic-size (or sparse) VHD image consists of:</p>
<ul>
<li>copy of file footer</li>
<li>dynamic disk header</li>
<li>block allocation table</li>
<li>data in blocks</li>
<li>file footer</li>
</ul>
<h3 id="differential-hard-disk-image"><a class="header" href="#differential-hard-disk-image">Differential hard disk image</a></h3>
<p>A differential (or differencing) VHD image consists of:</p>
<ul>
<li>copy of file footer</li>
<li>dynamic disk header</li>
<li>block allocation table</li>
<li>data in blocks</li>
<li>file footer</li>
</ul>
<h3 id="characteristics-4"><a class="header" href="#characteristics-4">Characteristics</a></h3>
<div class="table-wrapper"><table><thead><th>Characteristics</th><th>Description</th></thead><tr><td>Byte order</td><td>big-endian</td></tr>
<tr><td>Date and time values</td><td>Number of seconds since January 1, 2000 00:00:00 UTC</td></tr>
<tr><td>Character strings</td><td>UCS-2 big-endian, which allows for unpaired Unicode surrogates such as "U+d800" and "U+dc00"</td></tr>
</table></div>
<p>The number of bytes per sector is 512.</p>
<h3 id="undo-disk-image"><a class="header" href="#undo-disk-image">Undo disk image</a></h3>
<p>Virtual PC has a feature to create "Undo Disks". This undo disk feature stores
a differential hard disk image in files named something similar like:</p>
<pre><code>VirtualPCUndo_&lt;name&gt;_0_0_hhmmssMMDDYYYY.vud
</code></pre>
<p>Where the date and time seems to be stored in UTC and &lt;name&gt; represents the
name of the parent image.</p>
<h2 id="file-footer-1"><a class="header" href="#file-footer-1">File footer</a></h2>
<p>The file footer is 512 bytes in size and consists of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>8</td><td>"conectix"</td><td>Signature (also referred to as cookie)</td></tr>
<tr><td>8</td><td>4</td><td></td><td>Features</td></tr>
<tr><td>12</td><td>4</td><td>0x00010000</td><td>Format version, where the upper 16-bit are the major version and the lower 16-bit the minor version</td></tr>
<tr><td>16</td><td>8</td><td></td><td>Next offset, which contains the offset to the next (metadata) structure. The offset is relative from the start of the file. It should only be set in dynamic and differential disk images. In fixed disk images it should be set to 0xffffffffffffffff (-1).</td></tr>
<tr><td>24</td><td>4</td><td></td><td>Modification time, which contains the number of seconds since January 1, 2000 00:00:00 UTC</td></tr>
<tr><td>28</td><td>4</td><td></td><td>Creator application</td></tr>
<tr><td>32</td><td>4</td><td></td><td>Creator version, where the upper 16-bit are the major version and the lower 16-bit the minor version</td></tr>
<tr><td>36</td><td>4</td><td></td><td>Creator (host) operating system</td></tr>
<tr><td>40</td><td>8</td><td></td><td>Disk size, which contains the size of the disk in bytes</td></tr>
<tr><td>48</td><td>8</td><td></td><td>Data size, which contains the size of the data in bytes</td></tr>
<tr><td>56</td><td>4</td><td></td><td>Disk geometry</td></tr>
<tr><td>60</td><td>4</td><td></td><td>Disk type</td></tr>
<tr><td>64</td><td>4</td><td></td><td>Checksum</td></tr>
<tr><td>68</td><td>16</td><td></td><td>Identifier, which contains a big-endian UUID</td></tr>
<tr><td>84</td><td>1</td><td></td><td>Saved state, which contains a flag to indicate the image is in saved state.</td></tr>
<tr><td>85</td><td>427</td><td>0</td><td>Unknown (Reserved should contain 0-byte values)</td></tr>
</table></div>
<blockquote>
<p>Note that the checksum is a one's complement of the sum of all the bytes in
the file footer without the checksum field.</p>
</blockquote>
<h3 id="features"><a class="header" href="#features">Features</a></h3>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0.0</td><td>1 bit</td><td></td><td>Is temporary disk, which indicates that this disk is a candidate for deletion on shutdown</td></tr>
<tr><td>0.1</td><td>1 bit</td><td></td><td>Unknown (Reserved, must be set to 1)</td></tr>
<tr><td>0.2</td><td>30 bits</td><td></td><td>Unknown (Reserved, must be set to 0)</td></tr>
</table></div>
<p>A value of 0 represents no features are enabled.</p>
<h3 id="creator-application"><a class="header" href="#creator-application">Creator application</a></h3>
<div class="table-wrapper"><table><thead><th>Value</th><th>Identifier</th><th>Description</th></thead><tr><td>"d2v\x00"</td><td></td><td>Disk2vhd</td></tr>
<tr><td>"qemu"</td><td></td><td>Qemu</td></tr>
<tr><td>"vpc\x20"</td><td></td><td>Virtual PC</td></tr>
<tr><td>"vs\x20\x20"</td><td></td><td>Virtual Server</td></tr>
<tr><td>"win\x20"</td><td></td><td>Windows (Disk Management)</td></tr>
</table></div>
<h3 id="creator-host-operating-system"><a class="header" href="#creator-host-operating-system">Creator host operating system</a></h3>
<div class="table-wrapper"><table><thead><th>Value</th><th>Identifier</th><th>Description</th></thead><tr><td>"Mac\x20"</td><td></td><td>Macintosh</td></tr>
<tr><td>"Wi2k"</td><td></td><td>Windows</td></tr>
</table></div>
<h3 id="disk-geometry"><a class="header" href="#disk-geometry">Disk geometry</a></h3>
<p>The disk geometry is 4 bytes in size and consists of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>2</td><td></td><td>Number of cylinders</td></tr>
<tr><td>2</td><td>1</td><td></td><td>Number of heads</td></tr>
<tr><td>3</td><td>1</td><td></td><td>Number of sectors per track (cylinder)</td></tr>
</table></div>
<h3 id="disk-type"><a class="header" href="#disk-type">Disk type</a></h3>
<div class="table-wrapper"><table><thead><th>Value</th><th>Identifier</th><th>Description</th></thead><tr><td>0</td><td></td><td>None</td></tr>
<tr><td>1</td><td></td><td>Unknown (Deprecated)</td></tr>
<tr><td>2</td><td></td><td>Fixed hard disk</td></tr>
<tr><td>3</td><td></td><td>Dynamic hard disk</td></tr>
<tr><td>4</td><td></td><td>Differential hard disk</td></tr>
<tr><td>5</td><td></td><td>Unknown (Deprecated)</td></tr>
<tr><td>6</td><td></td><td>Unknown (Deprecated)</td></tr>
</table></div>
<h2 id="dynamic-disk-header"><a class="header" href="#dynamic-disk-header">Dynamic disk header</a></h2>
<p>The dynamic disk header is 1024 bytes in size and consists of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>8</td><td>"cxsparse"</td><td>Signature (Cookie)</td></tr>
<tr><td>8</td><td>8</td><td></td><td>Next offset, which contains the offset to the next (metadata) structure. The offset is relative from the start of the file. Currently this is unused and should be set to 0xffffffffffffffff (-1).</td></tr>
<tr><td>16</td><td>8</td><td></td><td>Block allocation table offset, whic contains the offset to the block allocation table structure. The offset is relative from the start of the file.</td></tr>
<tr><td>24</td><td>4</td><td>0x00010000</td><td>Format version, where the upper 16-bit are the major version and the lower 16-bit the minor version</td></tr>
<tr><td>28</td><td>4</td><td></td><td>Number of blocks, which contains the maximum number of block allocation table entries</td></tr>
<tr><td>32</td><td>4</td><td></td><td>Block size. The block size must be a power-of-two multitude of the sector size and does not include the size of the sector bitmap. The default block size is 4096 x 512-byte sectors (2 MB).</td></tr>
<tr><td>36</td><td>4</td><td></td><td>Checksum</td></tr>
<tr><td>40</td><td>16</td><td></td><td>Parent identifier, which contains a big-endian UUID that identifies the parent image. Only used by differential hard disk images.</td></tr>
<tr><td>56</td><td>4</td><td></td><td>Parent last modification time, which contains the number of seconds since January 1, 2000 00:00:00 UTC. Only used by differential hard disk images.</td></tr>
<tr><td>60</td><td>4</td><td>0</td><td>Unknown (Reserved should contain 0-byte values)</td></tr>
<tr><td>64</td><td>512</td><td></td><td>Parent name, which contains an UCS-2 big-endian string. Only used by differential hard disk images.</td></tr>
<tr><td>576</td><td>8 x 24 = 192</td><td></td><td>Array of parent locator entries. Only used by differential hard disk images.</td></tr>
<tr><td>768</td><td>256</td><td>0</td><td>Unknown (Reserved should contain 0-byte values)</td></tr>
</table></div>
<p>The maximum number of block allocation table entries should match the maximum
possible number of blocks in the disk.</p>
<blockquote>
<p>Note that the parent name can also contain a full path, e.g. in .avhd files.
The part segments are separated by the \ character.</p>
</blockquote>
<blockquote>
<p>Note that the checksum is a one's complement of the sum of all the bytes in
the file dynamic disk header without the checksum field.</p>
</blockquote>
<h3 id="parent-locator-entry"><a class="header" href="#parent-locator-entry">Parent locator entry</a></h3>
<p>The parent locator entry is 24 bytes in size and consists of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>4</td><td></td><td>Locator platform code</td></tr>
<tr><td>4</td><td>4</td><td></td><td>Platform data space, which contains the number of 512-byte sectors needed to store the parent hard disk locator</td></tr>
<tr><td>8</td><td>4</td><td></td><td>Locator data size</td></tr>
<tr><td>12</td><td>4</td><td>0</td><td>Unknown (Reserved should contain 0-byte values)</td></tr>
<tr><td>16</td><td>8</td><td></td><td>Locator data offset, which contains the offset to the locator data. The offset is relative from the start of the file.</td></tr>
</table></div>
<h4 id="locator-platform-code"><a class="header" href="#locator-platform-code">Locator platform code</a></h4>
<div class="table-wrapper"><table><thead><th>Value</th><th>Identifier</th><th>Description</th></thead><tr><td>0</td><td></td><td>None</td></tr>
<tr><td></td><td></td><td></td></tr>
<tr><td>"Mac\x20"</td><td></td><td>Mac OS alias stored as a blob</td></tr>
<tr><td>"MacX"</td><td></td><td>File URL with UTF-8 encoding conforming to RFC 2396</td></tr>
<tr><td></td><td></td><td></td></tr>
<tr><td>"W2ku"</td><td></td><td>Absolute Windows path, which contains an UCS-2 big-endian string</td></tr>
<tr><td>"W2ru"</td><td></td><td>Windows path relative to the differential image, which contains an UCS-2 big-endian string</td></tr>
<tr><td>"Wi2k"</td><td></td><td>Unknown (Deprecated)</td></tr>
<tr><td>"Wi2r"</td><td></td><td>Unknown (Deprecated)</td></tr>
</table></div>
<h2 id="block-allocation-table"><a class="header" href="#block-allocation-table">Block allocation table</a></h2>
<p>The block allocation table is only used in dynamic and differential disk images.</p>
<p>The block allocation table consists of 32-bit entries. The entries represent
the sector number where the data block starts or unused when set to
0xffffffff (-1).</p>
<pre><code>if block allocation table entry == 0xffffffff (-1):
        block is sparse or stored in parent
else:
        file offset = ( block allocation table entry * 512 ) + sector bitmap size
</code></pre>
<p>Unused block in a dynamic disk are sparse and should be filled with zero byte
values. In a differential disk the block is stored in the parent disk image.</p>
<h2 id="data-blocks"><a class="header" href="#data-blocks">Data blocks</a></h2>
<p>Data blocks are only used in dynamic and differential disk images.</p>
<p>A data block consists of:</p>
<ul>
<li>sector bitmap</li>
<li>sector data</li>
</ul>
<pre><code>size of bitmap (in bytes) = block size / ( 512 * 8 )
</code></pre>
<p>The size of the bitmap is rounded up to the next multitude of the sector size.</p>
<h3 id="sector-bitmap"><a class="header" href="#sector-bitmap">Sector bitmap</a></h3>
<p>In dynamic disk images the sector bitmap indicates which sectors contain data
(bit set to 1) or are sparse (bit set to 0).</p>
<p>In differential disk images the sector bitmap indicates which sectors are stored
within the image (bit set to 1) or in the parent (bit set to 0).</p>
<p>The bitmap is padded to a 512-byte sector boundary.</p>
<p>The bitmap is stored on a per-byte basis with the MSB represents the first bit
in the bitmap.</p>
<h2 id="references-2"><a class="header" href="#references-2">References</a></h2>
<ul>
<li><a href="https://www.microsoft.com/en-us/download/details.aspx?id=23850">VHD Specifications</a>, by Microsoft</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="virtual-hard-disk-version-2-vhdx-image-format"><a class="header" href="#virtual-hard-disk-version-2-vhdx-image-format">Virtual Hard Disk version 2 (VHDX) image format</a></h1>
<p>The Virtual Hard Disk version 2 (VHDX) format is used by Microsoft vitualization
products as one of its image formats. It is both used the store hard disk images
and snapshots.</p>
<h2 id="overview-6"><a class="header" href="#overview-6">Overview</a></h2>
<p>A VHDX image file consist of:</p>
<ul>
<li>file header</li>
<li>2x image headers</li>
<li>2x region tables</li>
<li>log or metadata journal</li>
<li>block allocation table (BAT) region</li>
<li>metadata region
<ul>
<li>metadata table</li>
<li>metadata items</li>
</ul>
</li>
<li>image (content) data</li>
</ul>
<p>The elements are stored in 64 KiB (65536 bytes) aligned blocks</p>
<h3 id="characteristics-5"><a class="header" href="#characteristics-5">Characteristics</a></h3>
<div class="table-wrapper"><table><thead><th>Characteristics</th><th>Description</th></thead><tr><td>Byte order</td><td>little-endian</td></tr>
<tr><td>Date and time values</td><td>N/A</td></tr>
<tr><td>Character strings</td><td>UCS-2 little-endian, which allows for unpaired Unicode surrogates such as "U+d800" and "U+dc00"</td></tr>
</table></div>
<p>The number of bytes per sector is 512 or 4096 depending on the logical sector size.</p>
<h2 id="file-hader"><a class="header" href="#file-hader">File hader</a></h2>
<p>The file header of (file type identifier) is 64 KiB (65536 bytes) in size and
consists of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>8</td><td>"vhdxfile"</td><td>Signature</td></tr>
<tr><td>8</td><td>512</td><td></td><td>Creator application and version, with contains an UCS-2 little-endian string with end-of-string character</td></tr>
<tr><td>520</td><td>65016</td><td></td><td>Unknown (reserved)</td></tr>
</table></div>
<h2 id="image-header"><a class="header" href="#image-header">Image header</a></h2>
<p>The image header is 4 KiB (4096 bytes) in size and consists of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>4</td><td>"head"</td><td>Signature</td></tr>
<tr><td>4</td><td>4</td><td></td><td>Checksum</td></tr>
<tr><td>8</td><td>8</td><td></td><td>Sequence number</td></tr>
<tr><td>16</td><td>16</td><td></td><td>File write identifier, which contains a GUID</td></tr>
<tr><td>32</td><td>16</td><td></td><td>Data write identifier, which contains a GUID</td></tr>
<tr><td>48</td><td>16</td><td></td><td>Log identifier, which contains a GUID</td></tr>
<tr><td>64</td><td>2</td><td></td><td>Log format version</td></tr>
<tr><td>66</td><td>2</td><td>1</td><td>Format version</td></tr>
<tr><td>68</td><td>4</td><td></td><td>Log size, which according to MS-VHDX this value must be a multitude of 1 MiB</td></tr>
<tr><td>72</td><td>8</td><td></td><td>Log offset, which according to MS-VHDX this value must be a multitude of 1 MiB and greater than or equal to 1 MiB</td></tr>
<tr><td>80</td><td>4016</td><td>0</td><td>Unknown (reserved), which according to MS-VHDX this value must be set to 0</td></tr>
</table></div>
<h3 id="checksum-calculation"><a class="header" href="#checksum-calculation">Checksum calculation</a></h3>
<p>The CRC32-C algorithm with the Castagnoli polynomial (0x1edc6f41) and initial
value of 0 is used to calculate the checksum.</p>
<p>The checksum is calculated over the 4 KiB bytes of data of the image header,
where the image header checkum value is considered to be 0 during calculation.</p>
<h2 id="region-table"><a class="header" href="#region-table">Region table</a></h2>
<p>The region table is stored in a block of 64 KiB (65536 bytes) and consists of:</p>
<ul>
<li>region table header</li>
<li>0 or more region table entries</li>
<li>Unknown (reserved)</li>
</ul>
<p>TODO: determine if 0 entries is actually supported</p>
<h3 id="region-table-header"><a class="header" href="#region-table-header">Region table header</a></h3>
<p>The region table header is 16 bytes in size and consists of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>4</td><td>"regi"</td><td>Signature</td></tr>
<tr><td>4</td><td>4</td><td></td><td>Checksum</td></tr>
<tr><td>8</td><td>4</td><td></td><td>Number of table entries, which according to MS-VHDX this value must be less than or equal to 2047</td></tr>
<tr><td>12</td><td>4</td><td>0</td><td>Unknown (reserved), which according to MS-VHDX this value must be set to 0</td></tr>
</table></div>
<p>The CRC32-C algorithm with the Castagnoli polynomial (0x1edc6f41) and initial
value of 0 is used to calculate the checksum.</p>
<p>The checksum is calculated over the 64 KiB bytes of data of the region table
where the image header checkum value is considered to be 0 during calculation.</p>
<h3 id="region-table-entry"><a class="header" href="#region-table-entry">Region table entry</a></h3>
<p>The region table entry is 32 bytes in size and consists of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>16</td><td></td><td><a href="vhdx.html#region_type_identifiers">Region type identifier</a>, which contains a GUID</td></tr>
<tr><td>16</td><td>8</td><td></td><td>Region data offset, which contains an offset relative to the start of the file. According to MS-VHDX this value must be a multitude of 1 MiB and greater than or equal to 1 MiB</td></tr>
<tr><td>24</td><td>4</td><td></td><td>Region data size, which according to MS-VHDX this value must be a multitude of 1 MiB</td></tr>
<tr><td>28</td><td>4</td><td></td><td>Is required flag, which contains 1 to indicate the region type needs to be supported.</td></tr>
</table></div>
<h3 id="region-type-identifiers"><a class="header" href="#region-type-identifiers"><a name="region_type_identifiers"></a>Region type identifiers</a></h3>
<div class="table-wrapper"><table><thead><th>Value</th><th>Identifier</th><th>Description</th></thead><tr><td>2dc27766-f623-4200-9d64-115e9bfd4a08</td><td></td><td>Block allocation table (BAT) region</td></tr>
<tr><td>8b7ca206-4790-4b9a-b8fe-575f050f886e</td><td></td><td>Metadata region</td></tr>
</table></div>
<h2 id="metadata-region"><a class="header" href="#metadata-region">Metadata region</a></h2>
<p>The metadata region contains:</p>
<ul>
<li>metadata table</li>
<li>metadata items</li>
</ul>
<h3 id="metadata-table"><a class="header" href="#metadata-table">Metadata table</a></h3>
<p>The metadata table is stored in a block of 64 KiB (65536 bytes) and consists of:</p>
<ul>
<li>metadata table header</li>
<li>0 or more metadata table entries</li>
<li>Unknown (reserved)</li>
</ul>
<p>TODO: determine if 0 entries is actually supported</p>
<h4 id="metadata-table-header"><a class="header" href="#metadata-table-header">Metadata table header</a></h4>
<p>The metadata table header is 32 bytes in size and consists of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>8</td><td>"metadata"</td><td>Signature</td></tr>
<tr><td>8</td><td>2</td><td>0</td><td>Unknown (reserved), which according to MS-VHDX this value must be set to 0</td></tr>
<tr><td>10</td><td>2</td><td></td><td>Number of table entries, which according to MS-VHDX this value must be less than or equal to 2047</td></tr>
<tr><td>12</td><td>20</td><td>0</td><td>Unknown (reserved), which according to MS-VHDX this value must be set to 0</td></tr>
</table></div>
<h4 id="metadata-table-entry"><a class="header" href="#metadata-table-entry">Metadata table entry</a></h4>
<p>The metdata table entry is 32 bytes in size and consists of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>16</td><td></td><td><a href="vhdx.html#metdata_item_identifiers">Metadata item identifier</a>, which contains a GUID</td></tr>
<tr><td>16</td><td>4</td><td></td><td>Metadata item offset, which contains an offset relative to the start of the metadata region. According to MS-VHDX this value must be greater than 64 KiB</td></tr>
<tr><td>20</td><td>4</td><td></td><td>Metadata item size</td></tr>
<tr><td>24</td><td>8</td><td></td><td>Unknown</td></tr>
</table></div>
<p>TODO: describe last 8 bytes</p>
<div class="table-wrapper"><table><thead><th>Value</th><th>Identifier</th><th>Description</th></thead><tr><td>0x00000001</td><td>IsUser</td><td></td></tr>
<tr><td>0x00000002</td><td>IsVirtualDisk</td><td></td></tr>
<tr><td>0x00000004</td><td>IsRequired</td><td></td></tr>
</table></div>
<h3 id="metadata-items"><a class="header" href="#metadata-items">Metadata items</a></h3>
<h4 id="metadata-item-identifiers"><a class="header" href="#metadata-item-identifiers"><a name="metdata_item_identifiers"></a>Metadata item identifiers</a></h4>
<div class="table-wrapper"><table><thead><th>Value</th><th>Identifier</th><th>Description</th></thead><tr><td>2fa54224-cd1b-4876-b211-5dbed83bf4b8</td><td></td><td>Virtual disk size</td></tr>
<tr><td>8141bf1d-a96f-4709-ba47-f233a8faab5f</td><td></td><td>Logical sector size</td></tr>
<tr><td>a8d35f2d-b30b-454d-abf7-d3d84834ab0c</td><td></td><td>Parent locator</td></tr>
<tr><td>beca12ab-b2e6-4523-93ef-c309e000c746</td><td></td><td>Virtual disk identifier</td></tr>
<tr><td>caa16737-fa36-4d43-b3b6-33f0aa44e76b</td><td></td><td>File parameters</td></tr>
<tr><td>cda348c7-445d-4471-9cc9-e9885251c556</td><td></td><td>Physical sector size</td></tr>
</table></div>
<h4 id="file-parameters-metadata-item"><a class="header" href="#file-parameters-metadata-item">File parameters metadata item</a></h4>
<p>The file parameters metadata item is 8 bytes in size and consists of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>4</td><td></td><td>Block size, which according to MS-VHDX this value must be a power of 2 and greater than or equal to 1 MiB and not greater than 256 MiB</td></tr>
<tr><td>4.0</td><td>1 bit</td><td></td><td>Blocks remain allocated flag, which is used to indicate the file is a fixed-size image</td></tr>
<tr><td>4.1</td><td>1 bit</td><td></td><td>Has parent flag, which indicates if the VHDX file contains a differential image that has a parent image</td></tr>
<tr><td>4.2</td><td>30 bits</td><td>0</td><td>Unknown (reserved), which according to MS-VHDX this value must be set to 0</td></tr>
</table></div>
<h4 id="logical-sector-size-metadata-item"><a class="header" href="#logical-sector-size-metadata-item">Logical sector size metadata item</a></h4>
<p>The logical sector size metadata item is 4 bytes in size and consists of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>4</td><td></td><td>Logical sector size, which according to MS-VHDX this value must be either 512 or 4096</td></tr>
</table></div>
<h4 id="parent-locator-metadata-item"><a class="header" href="#parent-locator-metadata-item">Parent locator metadata item</a></h4>
<p>The parent locator metadata item is of variable size and consits of:</p>
<ul>
<li>parent locator header</li>
<li>0 or more parent locator entry</li>
<li>parent locator key and value data</li>
</ul>
<p>TODO: determine if 0 entries is actually supported</p>
<h5 id="parent-locator-header"><a class="header" href="#parent-locator-header">Parent locator header</a></h5>
<p>The parent locator header is 20 bytes in size and consists of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>16</td><td></td><td>Parent locator type indicator, which contains the GUID: b04aefb7-d19e-4a81-b789-25b8e9445913</td></tr>
<tr><td>16</td><td>2</td><td>0</td><td>Unknown (reserved), which according to MS-VHDX this value must be set to 0</td></tr>
<tr><td>18</td><td>2</td><td></td><td>Number of entries (or key-value pairs)</td></tr>
</table></div>
<h5 id="parent-locator-entry-1"><a class="header" href="#parent-locator-entry-1">Parent locator entry</a></h5>
<p>The parent locator entry is 12 bytes in size and consists of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>4</td><td></td><td>Key data offset, which contains the offset relative from the start of the parent locator header</td></tr>
<tr><td>4</td><td>4</td><td></td><td>Value data offset, which contains the offset relative from the start of the parent locator header</td></tr>
<tr><td>8</td><td>2</td><td></td><td>Key data size</td></tr>
<tr><td>10</td><td>2</td><td></td><td>Value data size</td></tr>
</table></div>
<h5 id="parent-locator-key-and-value-data"><a class="header" href="#parent-locator-key-and-value-data">Parent locator key and value data</a></h5>
<p>A parent locator key or value is stored as UCS-2 little-endian string without
end-of-string character.</p>
<p>Known keys are:</p>
<div class="table-wrapper"><table><thead><th>Value</th><th>Description</th></thead><tr><td>absolute_win32_path</td><td>The value contains an absolute drive Windows path "\?\c:\file.vhdx"</td></tr>
<tr><td>parent_linkage</td><td>The value contains a string of a GUID. This GUID should correspond to the data write identifier of the parent image</td></tr>
<tr><td>parent_linkage2</td><td>The value contains a string of a GUID</td></tr>
<tr><td>relative_path</td><td>The value contains a relative Windows path "..\file.vhdx"</td></tr>
<tr><td>volume_path</td><td>The value contains an absolute volume Windows path with "\?\Volume{%GUID%}\file.vhdx"</td></tr>
</table></div>
<h4 id="physical-sector-size-metadata-item"><a class="header" href="#physical-sector-size-metadata-item">Physical sector size metadata item</a></h4>
<p>The physical sector size metadata item is 4 bytes in size and consists of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>4</td><td></td><td>Physical sector size, which according to MS-VHDX this value must be either 512 or 4096</td></tr>
</table></div>
<h4 id="virtual-disk-identifier-metadata-item"><a class="header" href="#virtual-disk-identifier-metadata-item">Virtual disk identifier metadata item</a></h4>
<p>The virtual disk identifier metadata item is 16 bytes in size and consists of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>16</td><td></td><td>Virtual disk identifier, which contains a GUID</td></tr>
</table></div>
<blockquote>
<p>Note that in contrast to VHD (version 1) the virtual disk identifier does
not change between a differential image and its parent. The data write
identifier seems to be used instead.</p>
</blockquote>
<h4 id="virtual-disk-size-metadata-item"><a class="header" href="#virtual-disk-size-metadata-item">Virtual disk size metadata item</a></h4>
<p>The virtual disk size metadata item is 8 bytes in size and consists of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>8</td><td></td><td>Virtual disk size</td></tr>
</table></div>
<h2 id="block-allocation-table-bat-region"><a class="header" href="#block-allocation-table-bat-region">Block allocation table (BAT) region</a></h2>
<p>The block allocation table (BAT) region contains the block allocation table.
The entries of this table describe the location of either blocks containing
image content data (or payload blocks) or blocks containing a sector bitmap.</p>
<p>The size of an individual sector bitmap block is 1 MiB which allows for <code>2^23</code>
sectors to be represented by the bitmap.</p>
<p>Block allocation table (BAT) entries are grouped in chunks. The size of a chunk
can be calculated as following:</p>
<pre><code>number of entries per chunk = ( 2^23 * logical sector size ) / block size
</code></pre>
<p>The block allocation table (BAT) consists of:</p>
<ul>
<li>one or more chunks containing:
<ul>
<li>number of entries per chunk x BAT entry describing image content data</li>
<li>1 x BAT entry describing the a sector bitmap</li>
</ul>
</li>
</ul>
<p>Unused BAT entries are filled with 0-byte values.</p>
<p>The block allocation table (BAT) of:</p>
<ul>
<li>a fixed-size image does not contain sector bitmap entries;</li>
<li>a dynamic-size image does contain sector bitmap entries, although according to MS-VHDX are not used;</li>
<li>a differential image does contain sector bitmap entries.</li>
</ul>
<h3 id="block-allocation-table-bat-entry"><a class="header" href="#block-allocation-table-bat-entry">Block allocation table (BAT) entry</a></h3>
<p>The block allocation table (BAT) entry is 64 bits in size and consists of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0.0</td><td>3 bits</td><td></td><td>Block state</td></tr>
<tr><td>0.3</td><td>17 bits</td><td>0</td><td>Unknown (reserved), which according to MS-VHDX this value must be set to 0</td></tr>
<tr><td>2.4</td><td>44 bits</td><td></td><td>Block offset, which contains the offset relative from the start of the file as a multitude of 1 MiB</td></tr>
</table></div>
<h3 id="block-states"><a class="header" href="#block-states">Block states</a></h3>
<h4 id="payload-block-states"><a class="header" href="#payload-block-states">Payload block states</a></h4>
<div class="table-wrapper"><table><thead><th>Value</th><th>Identifier</th><th>Description</th></thead><tr><td>0</td><td>PAYLOAD_BLOCK_NOT_PRESENT</td><td>Block is new and therefore not (yet) stored in the file</td></tr>
<tr><td>1</td><td>PAYLOAD_BLOCK_UNDEFINED</td><td>Block is not stored in the file</td></tr>
<tr><td>2</td><td>PAYLOAD_BLOCK_ZERO</td><td>Block is sparse and therefore filled with 0-byte values</td></tr>
<tr><td>3</td><td>PAYLOAD_BLOCK_UNMAPPED</td><td>Block has been unmapped</td></tr>
<tr><td></td><td></td><td></td></tr>
<tr><td>6</td><td>PAYLOAD_BLOCK_FULLY_PRESENT</td><td>Block is stored in the file</td></tr>
<tr><td>7</td><td>PAYLOAD_BLOCK_PARTIALLY_PRESENT</td><td>Block is stored in the parent</td></tr>
</table></div>
<h4 id="sector-bitmap-block-states"><a class="header" href="#sector-bitmap-block-states">Sector bitmap block states</a></h4>
<div class="table-wrapper"><table><thead><th>Value</th><th>Identifier</th><th>Description</th></thead><tr><td>0</td><td>SB_BLOCK_NOT_PRESENT</td><td>Block is new and therefore not (yet) stored in the file</td></tr>
<tr><td></td><td></td><td></td></tr>
<tr><td>6</td><td>SB_BLOCK_PRESENT</td><td>Block is stored in the file</td></tr>
</table></div>
<h3 id="sector-bitmap-1"><a class="header" href="#sector-bitmap-1">Sector bitmap</a></h3>
<p>In differential disk images the sector bitmap indicates which sectors are stored
within the image (bit set to 1) or in the parent (bit set to 0).</p>
<p>The bitmap is stored in a 1 MiB block.</p>
<p>The bitmap is stored on a per-byte basis with the LSB represents the first bit
in the bitmap.</p>
<h2 id="log-metadata-journal"><a class="header" href="#log-metadata-journal">Log (metadata journal)</a></h2>
<p>TODO: complete section</p>
<p>The log serves as metadata journal is of variable size and consist of contiguous
circular (ring) buffer that contains log entries.</p>
<h3 id="log-entry"><a class="header" href="#log-entry">Log entry</a></h3>
<p>TODO: complete section</p>
<p>4 KiB (4096 bytes) in size</p>
<h4 id="log-entry-header"><a class="header" href="#log-entry-header">Log entry header</a></h4>
<p>TODO: complete section</p>
<h4 id="zero-descriptor"><a class="header" href="#zero-descriptor">Zero descriptor</a></h4>
<p>TODO: complete section</p>
<h4 id="data-descriptor"><a class="header" href="#data-descriptor">Data descriptor</a></h4>
<p>TODO: complete section</p>
<h4 id="data-sector"><a class="header" href="#data-sector">Data sector</a></h4>
<p>TODO: complete section</p>
<h2 id="references-3"><a class="header" href="#references-3">References</a></h2>
<ul>
<li><a href="https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-vhdx/83e061f8-f6e2-4de1-91bd-5d518a43d477">MS-VHDX: Virtual Hard Disk v2 (VHDX) File Format</a>, by Microsoft</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="volume-system-formats"><a class="header" href="#volume-system-formats">Volume system formats</a></h1>
<p>A volume (or logical drive) is a single continous accessible storage area,
typically containing a file system. A volume system format is used to manage
the storage of one or more volumes.</p>
<blockquote>
<p>Note that although related, a volume is a different concept as a partition.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="apple-partition-map-apm-format"><a class="header" href="#apple-partition-map-apm-format">Apple Partition Map (APM) format</a></h1>
<p>The Apple Partition Map (APM) format is used on Motorola based Macintosh
computers. On Intel based Macintosh computers the <a href="gpt.html">GUID Partition Table (GPT) format</a>
is used.</p>
<h2 id="overview-7"><a class="header" href="#overview-7">Overview</a></h2>
<p>An Apple Partition Map (APM) consists of:</p>
<ul>
<li>a drive descriptor</li>
<li>partition map entry of type "Apple_partition_map"</li>
<li>zero or more partition map entries</li>
</ul>
<h3 id="characteristics-6"><a class="header" href="#characteristics-6">Characteristics</a></h3>
<div class="table-wrapper"><table><thead><th>Characteristics</th><th>Description</th></thead><tr><td>Byte order</td><td>big-endian</td></tr>
<tr><td>Date and time values</td><td>N/A</td></tr>
<tr><td>Character strings</td><td>ASCII</td></tr>
</table></div>
<h3 id="terminology-1"><a class="header" href="#terminology-1">Terminology</a></h3>
<div class="table-wrapper"><table><thead><th>Term</th><th>Description</th></thead><tr><td>Physical block</td><td>A fixed location on the storage media defined by the storage media.</td></tr>
<tr><td>Logical block</td><td>An abstract location on the storage media defined by software.</td></tr>
</table></div>
<h2 id="the-drive-descriptor"><a class="header" href="#the-drive-descriptor">The drive descriptor</a></h2>
<p>The driver descriptor identifies the device drivers installed on a storage
medium. The driver descriptor can contain refer to multiple device drivers.
Every device driver is stored in a separate partition.</p>
<p>The drive descriptor is situated in the first block of the storage medium. This
block is referred to as the device driver block. The driver descriptor block is
not considered part of any partition.</p>
<p>The drive descriptor is 512 bytes in size and consists of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>2</td><td>"\x45\x52" or "ER"</td><td>Signature</td></tr>
<tr><td>2</td><td>2</td><td></td><td>The block size of the device in bytes</td></tr>
<tr><td>4</td><td>4</td><td></td><td>The number of blocks on the device</td></tr>
<tr><td>8</td><td>2</td><td></td><td>Device type (Reserved)</td></tr>
<tr><td>10</td><td>2</td><td></td><td>Device identifier (Reserved)</td></tr>
<tr><td>12</td><td>4</td><td></td><td>Device data (Reserved)</td></tr>
<tr><td>16</td><td>2</td><td></td><td>The number of driver descriptors</td></tr>
<tr><td>18</td><td>8</td><td></td><td>The first device driver descriptor</td></tr>
<tr><td>26</td><td>484</td><td></td><td>Additional driver descriptors, where unused entries are 16-bit integer values filled with 0</td></tr>
</table></div>
<h3 id="the-device-driver-descriptor"><a class="header" href="#the-device-driver-descriptor">The device driver descriptor</a></h3>
<p>The device driver descriptor is 8 bytes in size and consists of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>4</td><td></td><td>Start block of the device driver</td></tr>
<tr><td>4</td><td>2</td><td></td><td>Device driver number of blocks</td></tr>
<tr><td>6</td><td>2</td><td></td><td>Operating system type, where is 1 represents "Mac OS"</td></tr>
</table></div>
<h2 id="the-partition-map"><a class="header" href="#the-partition-map">The partition map</a></h2>
<p>The partition map is stored after the drive descriptor. The partition map
consists of multiple entries that must be stored continuously. The partition
map itself is considered a partition therefore the first entry in the partition
map describes the partition map itself.</p>
<h3 id="the-partition-map-entry"><a class="header" href="#the-partition-map-entry">The partition map entry</a></h3>
<p>A partition map entry is 512 bytes in size and consists of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>2</td><td>"\x50\x4d" or "PM"</td><td>Signature</td></tr>
<tr><td>2</td><td>2</td><td>0x00</td><td>Unknown (Reserved)</td></tr>
<tr><td>4</td><td>4</td><td></td><td>Total number of entries in the partition map</td></tr>
<tr><td>8</td><td>4</td><td></td><td>Partition start sector</td></tr>
<tr><td>12</td><td>4</td><td></td><td>Partition number of sectors</td></tr>
<tr><td>16</td><td>32</td><td></td><td>Partition name, which contains an ASCII string</td></tr>
<tr><td>48</td><td>32</td><td></td><td><a href="apm.html#partition_types">Partition type</a>, which contains an ASCII string</td></tr>
<tr><td>80</td><td>4</td><td></td><td>Data area start sector</td></tr>
<tr><td>84</td><td>4</td><td></td><td>Data area number of sectors</td></tr>
<tr><td>88</td><td>4</td><td></td><td><a href="apm.html#status_flags">Status flags</a></td></tr>
<tr><td>92</td><td>4</td><td></td><td>Boot code start sector</td></tr>
<tr><td>96</td><td>4</td><td></td><td>Boot code number of sectors</td></tr>
<tr><td>100</td><td>4</td><td></td><td>Boot code address</td></tr>
<tr><td>104</td><td>4</td><td></td><td>Unknown (Reserved)</td></tr>
<tr><td>108</td><td>4</td><td></td><td>Boot code entry point</td></tr>
<tr><td>112</td><td>4</td><td></td><td>Unknown (Reserved)</td></tr>
<tr><td>116</td><td>4</td><td></td><td>Boot code checksum</td></tr>
<tr><td>120</td><td>16</td><td></td><td>Processor type</td></tr>
<tr><td>136</td><td>( 188 x 2 ) = 376</td><td>0x00</td><td>Unknown (Reserved)</td></tr>
</table></div>
<blockquote>
<p>Note that the partition name can be empty.</p>
</blockquote>
<h3 id="partition-types"><a class="header" href="#partition-types"><a name="partition_types"></a>Partition types</a></h3>
<p>The partition types consist of the following values:</p>
<div class="table-wrapper"><table><thead><th>Value</th><th>Identifier</th><th>Description</th></thead><tr><td>"Apple_Boot"</td><td></td><td></td></tr>
<tr><td>"Apple_Boot_RAID"</td><td></td><td></td></tr>
<tr><td>"Apple_Bootstrap"</td><td></td><td></td></tr>
<tr><td>"Apple_Driver"</td><td></td><td></td></tr>
<tr><td>"Apple_Driver43"</td><td></td><td></td></tr>
<tr><td>"Apple_Driver43_CD"</td><td></td><td></td></tr>
<tr><td>"Apple_Driver_ATA"</td><td></td><td></td></tr>
<tr><td>"Apple_Driver_ATAPI"</td><td></td><td></td></tr>
<tr><td>"Apple_Driver_IOKit"</td><td></td><td></td></tr>
<tr><td>"Apple_Driver_OpenFirmware"</td><td></td><td></td></tr>
<tr><td>"Apple_Extra"</td><td></td><td></td></tr>
<tr><td>"Apple_Free"</td><td></td><td></td></tr>
<tr><td>"Apple_FWDriver"</td><td></td><td></td></tr>
<tr><td>"Apple_HFS"</td><td></td><td></td></tr>
<tr><td>"Apple_HFSX"</td><td></td><td></td></tr>
<tr><td>"Apple_Loader"</td><td></td><td></td></tr>
<tr><td>"Apple_MDFW"</td><td></td><td></td></tr>
<tr><td>"Apple_MFS"</td><td></td><td></td></tr>
<tr><td>"Apple_partition_map"</td><td></td><td></td></tr>
<tr><td>"Apple_Patches"</td><td></td><td></td></tr>
<tr><td>"Apple_PRODOS"</td><td></td><td></td></tr>
<tr><td>"Apple_RAID"</td><td></td><td></td></tr>
<tr><td>"Apple_Rhapsody_UFS"</td><td></td><td></td></tr>
<tr><td>"Apple_Scratch"</td><td></td><td></td></tr>
<tr><td>"Apple_Second"</td><td></td><td></td></tr>
<tr><td>"Apple_UFS"</td><td></td><td></td></tr>
<tr><td>"Apple_UNIX_SVR2"</td><td></td><td></td></tr>
<tr><td>"Apple_Void"</td><td></td><td></td></tr>
<tr><td>"Be_BFS"</td><td></td><td></td></tr>
<tr><td>"MFS"</td><td></td><td></td></tr>
</table></div>
<h3 id="status-flags"><a class="header" href="#status-flags"><a name="status_flags"></a>Status flags</a></h3>
<p>The partition status flags consist of the following values:</p>
<div class="table-wrapper"><table><thead><th>Value</th><th>Identifier</th><th>Description</th></thead><tr><td>0x00000001</td><td></td><td>Is valid</td></tr>
<tr><td>0x00000002</td><td></td><td>Is allocated</td></tr>
<tr><td>0x00000004</td><td></td><td>Is in use</td></tr>
<tr><td>0x00000008</td><td></td><td>Contains boot information</td></tr>
<tr><td>0x00000010</td><td></td><td>Is readable</td></tr>
<tr><td>0x00000020</td><td></td><td>Is writable</td></tr>
<tr><td>0x00000040</td><td></td><td>Boot code is position independent</td></tr>
<tr><td></td><td></td><td></td></tr>
<tr><td>0x00000100</td><td></td><td>Contains a chain-compatible driver</td></tr>
<tr><td>0x00000200</td><td></td><td>Contains a real driver</td></tr>
<tr><td>0x00000400</td><td></td><td>Contains a chain driver</td></tr>
<tr><td></td><td></td><td></td></tr>
<tr><td>0x40000000</td><td></td><td>Automatic mount at startup</td></tr>
<tr><td>0x80000000</td><td></td><td>Is startup partition</td></tr>
</table></div>
<blockquote>
<p>Note that the "is in use" status flags does not appear to be used consistently.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="guid-partition-table-gpt-format"><a class="header" href="#guid-partition-table-gpt-format">GUID Partition Table (GPT) format</a></h1>
<p>The GUID Partition Table (GPT) is a partitioning schema that is the successor
to the <a href="mbr.html">Master Boot Record (MBR) Partition Table</a> for Intel x86 based
computers.</p>
<h2 id="overview-8"><a class="header" href="#overview-8">Overview</a></h2>
<p>A GUID Partition Table (GPT) consists of:</p>
<ul>
<li>A protective or hybrid Master Boot Record (MBR) stored in block (LBA) 0</li>
<li>A GPT partition table header stored in block (LBA) 1</li>
<li>GPT partition entries stored in blocks (LBA) 2 - 33</li>
<li>paritions area
<ul>
<li>GPT partitions</li>
<li>MBR partitions if hybrid MBR/GPT</li>
</ul>
</li>
<li>backup GPT partition entries (typically stored the blocks (LBA) before the last block -33 - -2)</li>
<li>A backup GPT partition table header (typically stored in the last block (LBA) -1)</li>
</ul>
<p>The GPT partition table header signature can be used to determine the block
(LBA) (or sector) size.</p>
<h3 id="characteristics-7"><a class="header" href="#characteristics-7">Characteristics</a></h3>
<div class="table-wrapper"><table><thead><th>Characteristics</th><th>Description</th></thead><tr><td>Byte order</td><td>little-endian</td></tr>
<tr><td>Date and time values</td><td>N/A</td></tr>
<tr><td>Character strings</td><td>UTF-16 little-endian without byte order mark (BOM)</td></tr>
</table></div>
<h2 id="master-boot-record-mbr"><a class="header" href="#master-boot-record-mbr">Master Boot Record (MBR)</a></h2>
<h3 id="hybrid-master-boot-record-mbr"><a class="header" href="#hybrid-master-boot-record-mbr">Hybrid Master Boot Record (MBR)</a></h3>
<p>In hybrid configuration both GPT and MBR are used concurrently. Depending on
the operating system one might have precedence over the other.</p>
<h3 id="protective-master-boot-record-mbr"><a class="header" href="#protective-master-boot-record-mbr">Protective Master Boot Record (MBR)</a></h3>
<p>The Protective Master Boot Record (MBR) is an MBR with a single partition of
type "EFI GPT protective partition" (0xee) that allocated as much of the drive
as possible.</p>
<h2 id="gpt-partition-table-header"><a class="header" href="#gpt-partition-table-header">GPT partition table header</a></h2>
<p>The GPT partition table header is 92 bytes in size and consists of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>8</td><td>"EFI PART"</td><td>Signature</td></tr>
<tr><td>8</td><td>2</td><td>0</td><td>Minor format version</td></tr>
<tr><td>10</td><td>2</td><td>1</td><td>Major format version</td></tr>
<tr><td>12</td><td>4</td><td>92</td><td>Header data size, which contains the size of the GPT partition table header data</td></tr>
<tr><td>16</td><td>4</td><td></td><td>Header data checksum</td></tr>
<tr><td>20</td><td>4</td><td>0</td><td>Unknown (Reserved)</td></tr>
<tr><td>24</td><td>8</td><td></td><td>Partition header block number (LBA)</td></tr>
<tr><td>32</td><td>8</td><td></td><td>Backup partition header block number (LBA)</td></tr>
<tr><td>40</td><td>8</td><td></td><td>Partitions area start block number (LBA)</td></tr>
<tr><td>48</td><td>8</td><td></td><td>Partitions area end block number (LBA), where the block number is included in the partitions area block range</td></tr>
<tr><td>56</td><td>16</td><td></td><td>Disk identifier (GUID)</td></tr>
<tr><td>72</td><td>8</td><td></td><td>Partition entries start block number (LBA)</td></tr>
<tr><td>80</td><td>4</td><td></td><td>Number of partition entries</td></tr>
<tr><td>84</td><td>4</td><td>128</td><td>Partition entry data size</td></tr>
<tr><td>88</td><td>4</td><td></td><td>Partition entries data checksum</td></tr>
<tr><td>92</td><td>...</td><td>0</td><td>Unknown (Reserved)</td></tr>
</table></div>
<blockquote>
<p>Note that the partition entries start block number (LBA) of the backup
partition table header will point to the backup partition entries.</p>
</blockquote>
<blockquote>
<p>Note that the number of partition entries value contains the number of
available partition entries not the number of used partition entries. Empty
partition entries have a unused entry partition type identifier.</p>
</blockquote>
<h3 id="checksum-calculation-1"><a class="header" href="#checksum-calculation-1">Checksum calculation</a></h3>
<p>The <a href="https://www.ietf.org/rfc/rfc1952.txt">CRC-32 algorithm</a> with polynominal
0x04c11db7 and initial value of 0 is used to calculate the checksums.</p>
<p>The checksum is calculated over the 92 bytes of the table header data, where the
header data checkum value is considered to be 0 during calculation.</p>
<h2 id="gpt-partition-entries"><a class="header" href="#gpt-partition-entries">GPT partition entries</a></h2>
<h3 id="gpt-partition-entry"><a class="header" href="#gpt-partition-entry">GPT Partition entry</a></h3>
<p>The GPT partition entry is 128 bytes in size and consists of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>16</td><td></td><td><a href="gpt.html#partition_types">Partition type</a> identifier (GUID)</td></tr>
<tr><td>16</td><td>16</td><td></td><td>Partition identifier (GUID)</td></tr>
<tr><td>32</td><td>8</td><td></td><td>Partition start block number (LBA)</td></tr>
<tr><td>40</td><td>8</td><td></td><td>Partition end block number (LBA), where the block number is included in the partition block range</td></tr>
<tr><td>48</td><td>8</td><td></td><td><a href="gpt.html#partition_attribute_flags">Attribute flags</a></td></tr>
<tr><td>56</td><td>72</td><td></td><td>Partition name, which contains a UTF-16 little-endian string</td></tr>
</table></div>
<h3 id="partition-types-1"><a class="header" href="#partition-types-1"><a name="partition_types"></a>Partition types</a></h3>
<div class="table-wrapper"><table><thead><th>Value</th><th>Identifier</th><th>Description</th></thead><tr><td>00000000-0000-0000-0000-000000000000</td><td></td><td>Unused entry</td></tr>
<tr><td>024dee41-33e7-11d3-9d69-0008c781f39f</td><td></td><td>MBR partition scheme</td></tr>
<tr><td>c12a7328-f81f-11d2-ba4b-00a0c93ec93b</td><td></td><td>EFI System partition</td></tr>
<tr><td>21686148-6449-6e6f-744e-656564454649</td><td></td><td>BIOS boot partition</td></tr>
<tr><td>d3bfe2de-3daf-11df-ba40-e3a556d89593</td><td></td><td>Intel Fast Flash (iFFS) partition (for Intel Rapid Start technology)</td></tr>
<tr><td>f4019732-066e-4e12-8273-346c5641494f</td><td></td><td>Sony boot partition</td></tr>
<tr><td>bfbfafe7-a34f-448a-9a5b-6213eb736c22</td><td></td><td>Lenovo boot partition</td></tr>
<tr><td colspan="3"> <em>Windows</em></tr>
<tr><td>e3c9e316-0b5c-4db8-817d-f92df00215ae</td><td></td><td>Microsoft Reserved Partition (MSR)</td></tr>
<tr><td>ebd0a0a2-b9e5-4433-87c0-68b6b72699c7</td><td></td><td>Basic data partition</td></tr>
<tr><td>5808c8aa-7e8f-42e0-85d2-e1e90434cfb3</td><td></td><td>Logical Disk Manager (LDM) metadata partition</td></tr>
<tr><td>af9b60a0-1431-4f62-bc68-3311714a69ad</td><td></td><td>Logical Disk Manager data partition</td></tr>
<tr><td>de94bba4-06d1-4d40-a16a-bfd50179d6ac</td><td></td><td>Windows Recovery Environment</td></tr>
<tr><td>37affc90-ef7d-4e96-91c3-2d7ae055b174</td><td></td><td>IBM General Parallel File System (GPFS) partition</td></tr>
<tr><td>e75caf8f-f680-4cee-afa3-b001e56efc2d</td><td></td><td>Storage Spaces partition</td></tr>
<tr><td colspan="3"> <em>HP-UX</em></tr>
<tr><td>75894c1e-3aeb-11d3-b7c1-7b03a0000000</td><td></td><td>Data partition</td></tr>
<tr><td>e2a1e728-32e3-11d6-a682-7b03a0000000</td><td></td><td>Service Partition</td></tr>
<tr><td colspan="3"> <em>Linux</em></tr>
<tr><td>0fc63daf-8483-4772-8e79-3d69d8477de4</td><td></td><td>Linux filesystem data</td></tr>
<tr><td>a19d880f-05fc-4d3b-a006-743f0f84911e</td><td></td><td>RAID partition</td></tr>
<tr><td>44479540-f297-41b2-9af7-d131d5f0458a</td><td></td><td>Root partition (x86)</td></tr>
<tr><td>4f68bce3-e8cd-4db1-96e7-fbcaf984b709</td><td></td><td>Root partition (x86-64)</td></tr>
<tr><td>69dad710-2ce4-4e3c-b16c-21a1d49abed3</td><td></td><td>Root partition (32-bit ARM)</td></tr>
<tr><td>b921b045-1df0-41c3-af44-4c6f280d3fae</td><td></td><td>Root partition (64-bit ARM/AArch64)</td></tr>
<tr><td>0657fd6d-a4ab-43c4-84e5-0933c84b4f4f</td><td></td><td>Swap partition</td></tr>
<tr><td>e6d6d379-f507-44c2-a23c-238f2a3df928</td><td></td><td>Logical Volume Manager (LVM) partition</td></tr>
<tr><td>933ac7e1-2eb4-4f13-b844-0e14e2aef915</td><td></td><td>/home partition</td></tr>
<tr><td>3b8f8425-20e0-4f3b-907f-1a25a76f98e8</td><td></td><td>/srv (server data) partition</td></tr>
<tr><td>7ffec5c9-2d00-49b7-8941-3ea10a5586b7</td><td></td><td>Plain dm-crypt partition</td></tr>
<tr><td>ca7d7ccb-63ed-4c53-861c-1742536059cc</td><td></td><td>LUKS partition</td></tr>
<tr><td>8da63339-0007-60c0-c436-083ac8230908</td><td></td><td>Reserved</td></tr>
<tr><td colspan="3"> <em>FreeBSD</em></tr>
<tr><td>83bd6b9d-7f41-11dc-be0b-001560b84f0f</td><td></td><td>Boot partition</td></tr>
<tr><td>516e7cb4-6ecf-11d6-8ff8-00022d09712b</td><td></td><td>Data partition</td></tr>
<tr><td>516e7cb5-6ecf-11d6-8ff8-00022d09712b</td><td></td><td>Swap partition</td></tr>
<tr><td>516e7cb6-6ecf-11d6-8ff8-00022d09712b</td><td></td><td>Unix File System (UFS) partition</td></tr>
<tr><td>516e7cb8-6ecf-11d6-8ff8-00022d09712b</td><td></td><td>Vinum volume manager partition</td></tr>
<tr><td>516e7cba-6ecf-11d6-8ff8-00022d09712b</td><td></td><td>ZFS partition</td></tr>
<tr><td colspan="3"> <em>Darwin / Mac OS</em></tr>
<tr><td>48465300-0000-11aa-aa11-00306543ecac</td><td></td><td>Hierarchical File System Plus (HFS+) partition</td></tr>
<tr><td>7c3457ef-0000-11aa-aa11-00306543ecac</td><td></td><td>Apple APFS</td></tr>
<tr><td>55465300-0000-11aa-aa11-00306543ecac</td><td></td><td>Apple UFS container</td></tr>
<tr><td>6a898cc3-1dd2-11b2-99a6-080020736631</td><td></td><td>ZFS</td></tr>
<tr><td>52414944-0000-11aa-aa11-00306543ecac</td><td></td><td>Apple RAID partition</td></tr>
<tr><td>52414944-5f4f-11aa-aa11-00306543ecac</td><td></td><td>Apple RAID partition, offline</td></tr>
<tr><td>426f6f74-0000-11aa-aa11-00306543ecac</td><td></td><td>Apple Boot partition (Recovery HD)</td></tr>
<tr><td>4c616265-6c00-11aa-aa11-00306543ecac</td><td></td><td>Apple Label</td></tr>
<tr><td>5265636f-7665-11aa-aa11-00306543ecac</td><td></td><td>Apple TV Recovery partition</td></tr>
<tr><td>53746f72-6167-11aa-aa11-00306543ecac</td><td></td><td>Apple Core Storage (i.e. Lion FileVault) partition</td></tr>
<tr><td>b6fa30da-92d2-4a9a-96f1-871ec6486200</td><td></td><td>SoftRAID_Status</td></tr>
<tr><td>2e313465-19b9-463f-8126-8a7993773801</td><td></td><td>SoftRAID_Scratch</td></tr>
<tr><td>fa709c7e-65b1-4593-bfd5-e71d61de9b02</td><td></td><td>SoftRAID_Volume</td></tr>
<tr><td>bbba6df5-f46f-4a89-8f59-8765b2727503</td><td></td><td>SoftRAID_Cache</td></tr>
<tr><td colspan="3"> <em>Solaris / illumos</em></tr>
<tr><td>6a82cb45-1dd2-11b2-99a6-080020736631</td><td></td><td>Boot partition</td></tr>
<tr><td>6a85cf4d-1dd2-11b2-99a6-080020736631</td><td></td><td>Root partition</td></tr>
<tr><td>6a87c46f-1dd2-11b2-99a6-080020736631</td><td></td><td>Swap partition</td></tr>
<tr><td>6a8b642b-1dd2-11b2-99a6-080020736631</td><td></td><td>Backup partition</td></tr>
<tr><td>6a898cc3-1dd2-11b2-99a6-080020736631</td><td></td><td>/usr partition</td></tr>
<tr><td>6a8ef2e9-1dd2-11b2-99a6-080020736631</td><td></td><td>/var partition</td></tr>
<tr><td>6a90ba39-1dd2-11b2-99a6-080020736631</td><td></td><td>/home partition</td></tr>
<tr><td>6a9283a5-1dd2-11b2-99a6-080020736631</td><td></td><td>Alternate sector</td></tr>
<tr><td>6a8d2ac7-1dd2-11b2-99a6-080020736631</td><td></td><td>Reserved partition</td></tr>
<tr><td>6a945a3b-1dd2-11b2-99a6-080020736631</td><td></td><td>Reserved partition</td></tr>
<tr><td>6a96237f-1dd2-11b2-99a6-080020736631</td><td></td><td>Reserved partition</td></tr>
<tr><td>6a9630d1-1dd2-11b2-99a6-080020736631</td><td></td><td>Reserved partition</td></tr>
<tr><td>6a980767-1dd2-11b2-99a6-080020736631</td><td></td><td>Reserved partition</td></tr>
<tr><td colspan="3"> <em>NetBSD</em></tr>
<tr><td>49f48d32-b10e-11dc-b99b-0019d1879648</td><td></td><td>Swap partition</td></tr>
<tr><td>49f48d5a-b10e-11dc-b99b-0019d1879648</td><td></td><td>FFS partition</td></tr>
<tr><td>49f48d82-b10e-11dc-b99b-0019d1879648</td><td></td><td>LFS partition</td></tr>
<tr><td>49f48daa-b10e-11dc-b99b-0019d1879648</td><td></td><td>RAID partition</td></tr>
<tr><td>2db519c4-b10f-11dc-b99b-0019d1879648</td><td></td><td>Concatenated partition</td></tr>
<tr><td>2db519ec-b10f-11dc-b99b-0019d1879648</td><td></td><td>Encrypted partition</td></tr>
<tr><td colspan="3"> <em>Chrome OS</em></tr>
<tr><td>fe3a2a5d-4f32-41a7-b725-accc3285a309</td><td></td><td>Chrome OS kernel</td></tr>
<tr><td>3cb8e202-3b7e-47dd-8a3c-7ff2a13cfcec</td><td></td><td>Chrome OS rootfs</td></tr>
<tr><td>2e0a753d-9e48-43b0-8337-b15192cb1b5e</td><td></td><td>Chrome OS future use</td></tr>
<tr><td colspan="3"> <em>Container Linux by CoreOS</em></tr>
<tr><td>5dfbf5f4-2848-4bac-aa5e-0d9a20b745a6</td><td></td><td>/usr partition (coreos-usr)</td></tr>
<tr><td>3884dd41-8582-4404-b9a8-e9b84f2df50e</td><td></td><td>Resizable rootfs (coreos-resize)</td></tr>
<tr><td>c95dc21a-df0e-4340-8d7b-26cbfa9a03e0</td><td></td><td>OEM customizations (coreos-reserved)</td></tr>
<tr><td>be9067b9-ea49-4f15-b4f6-f36f8c9e1818</td><td></td><td>Root filesystem on RAID (coreos-root-raid)</td></tr>
<tr><td colspan="3"> <em>Haiku</em></tr>
<tr><td>42465331-3ba3-10f1-802a-4861696b7521</td><td></td><td>Haiku BFS</td></tr>
<tr><td colspan="3"> <em>MidnightBSD</em></tr>
<tr><td>85d5e45e-237c-11e1-b4b3-e89a8f7fc3a7</td><td></td><td>Boot partition</td></tr>
<tr><td>85d5e45a-237c-11e1-b4b3-e89a8f7fc3a7</td><td></td><td>Data partition</td></tr>
<tr><td>85d5e45b-237c-11e1-b4b3-e89a8f7fc3a7</td><td></td><td>Swap partition</td></tr>
<tr><td>0394ef8b-237e-11e1-b4b3-e89a8f7fc3a7</td><td></td><td>Unix File System (UFS) partition</td></tr>
<tr><td>85d5e45c-237c-11e1-b4b3-e89a8f7fc3a7</td><td></td><td>Vinum volume manager partition</td></tr>
<tr><td>85d5e45d-237c-11e1-b4b3-e89a8f7fc3a7</td><td></td><td>ZFS partition</td></tr>
<tr><td colspan="3"> <em>Ceph</em></tr>
<tr><td>45b0969e-9b03-4f30-b4c6-b4b80ceff106</td><td></td><td>Journal</td></tr>
<tr><td>45b0969e-9b03-4f30-b4c6-5ec00ceff106</td><td></td><td>dm-crypt journal</td></tr>
<tr><td>4fbd7e29-9d25-41b8-afd0-062c0ceff05d</td><td></td><td>OSD</td></tr>
<tr><td>4fbd7e29-9d25-41b8-afd0-5ec00ceff05d</td><td></td><td>dm-crypt OSD</td></tr>
<tr><td>89c57f98-2fe5-4dc0-89c1-f3ad0ceff2be</td><td></td><td>Disk in creation</td></tr>
<tr><td>89c57f98-2fe5-4dc0-89c1-5ec00ceff2be</td><td></td><td>dm-crypt disk in creation</td></tr>
<tr><td>cafecafe-9b03-4f30-b4c6-b4b80ceff106</td><td></td><td>Block</td></tr>
<tr><td>30cd0809-c2b2-499c-8879-2d6b78529876</td><td></td><td>Block DB</td></tr>
<tr><td>5ce17fce-4087-4169-b7ff-056cc58473f9</td><td></td><td>Block write-ahead log</td></tr>
<tr><td>fb3aabf9-d25f-47cc-bf5e-721d1816496b</td><td></td><td>Lockbox for dm-crypt keys</td></tr>
<tr><td>4fbd7e29-8ae0-4982-bf9d-5a8d867af560</td><td></td><td>Multipath OSD</td></tr>
<tr><td>45b0969e-8ae0-4982-bf9d-5a8d867af560</td><td></td><td>Multipath journal</td></tr>
<tr><td>cafecafe-8ae0-4982-bf9d-5a8d867af560</td><td></td><td>Multipath block</td></tr>
<tr><td>7f4a666a-16f3-47a2-8445-152ef4d03f6c</td><td></td><td>Multipath block</td></tr>
<tr><td>ec6d6385-e346-45dc-be91-da2a7c8b3261</td><td></td><td>Multipath block DB</td></tr>
<tr><td>01b41e1b-002a-453c-9f17-88793989ff8f</td><td></td><td>Multipath block write-ahead log</td></tr>
<tr><td>cafecafe-9b03-4f30-b4c6-5ec00ceff106</td><td></td><td>dm-crypt block</td></tr>
<tr><td>93b0052d-02d9-4d8a-a43b-33a3ee4dfbc3</td><td></td><td>dm-crypt block DB</td></tr>
<tr><td>306e8683-4fe2-4330-b7c0-00a917c16966</td><td></td><td>dm-crypt block write-ahead log</td></tr>
<tr><td>45b0969e-9b03-4f30-b4c6-35865ceff106</td><td></td><td>dm-crypt LUKS journal</td></tr>
<tr><td>cafecafe-9b03-4f30-b4c6-35865ceff106</td><td></td><td>dm-crypt LUKS block</td></tr>
<tr><td>166418da-c469-4022-adf4-b30afd37f176</td><td></td><td>dm-crypt LUKS block DB</td></tr>
<tr><td>86a32090-3647-40b9-bbbd-38d8c573aa86</td><td></td><td>dm-crypt LUKS block write-ahead log</td></tr>
<tr><td>4fbd7e29-9d25-41b8-afd0-35865ceff05d</td><td></td><td>dm-crypt LUKS OSD</td></tr>
<tr><td colspan="3"> <em>OpenBSD</em></tr>
<tr><td>824cc7a0-36a8-11e3-890a-952519ad3f61</td><td></td><td>Data partition</td></tr>
<tr><td colspan="3"> <em>QNX</em></tr>
<tr><td>cef5a9ad-73bc-4601-89f3-cdeeeee321a1</td><td></td><td>Power-safe (QNX6) file system</td></tr>
<tr><td colspan="3"> <em>Plan 9</em></tr>
<tr><td>c91818f9-8025-47af-89d2-f030d7000c2c</td><td></td><td>Plan 9 partition</td></tr>
<tr><td colspan="3"> <em>VMware ESX</em></tr>
<tr><td>9d275380-40ad-11db-bf97-000c2911d1b8</td><td></td><td>vmkcore (coredump partition)</td></tr>
<tr><td>aa31e02a-400f-11db-9590-000c2911d1b8</td><td></td><td>VMFS filesystem partition</td></tr>
<tr><td>9198effc-31c0-11db-8f78-000c2911d1b8</td><td></td><td>VMware Reserved</td></tr>
<tr><td colspan="3"> <em>Android-IA</em></tr>
<tr><td>2568845d-2332-4675-bc39-8fa5a4748d15</td><td></td><td>Bootloader</td></tr>
<tr><td>114eaffe-1552-4022-b26e-9b053604cf84</td><td></td><td>Bootloader2</td></tr>
<tr><td>49a4d17f-93a3-45c1-a0de-f50b2ebe2599</td><td></td><td>Boot</td></tr>
<tr><td>4177c722-9e92-4aab-8644-43502bfd5506</td><td></td><td>Recovery</td></tr>
<tr><td>ef32a33b-a409-486c-9141-9ffb711f6266</td><td></td><td>Misc</td></tr>
<tr><td>20ac26be-20b7-11e3-84c5-6cfdb94711e9</td><td></td><td>Metadata</td></tr>
<tr><td>38f428e6-d326-425d-9140-6e0ea133647c</td><td></td><td>System</td></tr>
<tr><td>a893ef21-e428-470a-9e55-0668fd91a2d9</td><td></td><td>Cache</td></tr>
<tr><td>dc76dda9-5ac1-491c-af42-a82591580c0d</td><td></td><td>Data</td></tr>
<tr><td>ebc597d0-2053-4b15-8b64-e0aac75f4db1</td><td></td><td>Persistent</td></tr>
<tr><td>c5a0aeec-13ea-11e5-a1b1-001e67ca0c3c</td><td></td><td>Vendor</td></tr>
<tr><td>bd59408b-4514-490d-bf12-9878d963f378</td><td></td><td>Config</td></tr>
<tr><td>8f68cc74-c5e5-48da-be91-a0c8c15e9c80</td><td></td><td>Factory</td></tr>
<tr><td>9fdaa6ef-4b3f-40d2-ba8d-bff16bfb887b</td><td></td><td>Factory (alt)</td></tr>
<tr><td>767941d0-2085-11e3-ad3b-6cfdb94711e9</td><td></td><td>Fastboot / Tertiary</td></tr>
<tr><td>ac6d7924-eb71-4df8-b48d-e267b27148ff</td><td></td><td>OEM</td></tr>
<tr><td colspan="3"> <em>Android 6.0+ ARM</em></tr>
<tr><td>19a710a2-b3ca-11e4-b026-10604b889dcf</td><td></td><td>Android Meta</td></tr>
<tr><td>193d1ea4-b3ca-11e4-b075-10604b889dcf</td><td></td><td>Android EXT</td></tr>
<tr><td colspan="3"> <em>Open Network Install Environment (ONIE)</em></tr>
<tr><td>7412f7d5-a156-4b13-81dc-867174929325</td><td></td><td>Boot</td></tr>
<tr><td>d4e6e2cd-4469-46f3-b5cb-1bff57afc149</td><td></td><td>Config</td></tr>
<tr><td colspan="3"> <em>PowerPC</em></tr>
<tr><td>9e1a2d38-c612-4316-aa26-8b49521e5a8b</td><td></td><td>PReP boot</td></tr>
<tr><td colspan="3"> <em>freedesktop.org OSes (Linux, etc.)</em></tr>
<tr><td>bc13c2ff-59e6-4262-a352-b275fd6f7172</td><td></td><td>Shared boot loader configuration</td></tr>
<tr><td colspan="3"> <em>Atari TOS</em></tr>
<tr><td>734e5afe-f61a-11e6-bc64-92361f002671</td><td></td><td>Basic data partition (GEM, BGM, F32)</td></tr>
</table></div>
<h3 id="partition-attribute-flags"><a class="header" href="#partition-attribute-flags"><a name="partition_attribute_flags"></a>Partition attribute flags</a></h3>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0.0</td><td>1 bit</td><td></td><td>Partition is required by the platform, e.g. an OEM partition</td></tr>
<tr><td>0.1</td><td>1 bit</td><td></td><td>EFI firmware should ignore the content of the partition</td></tr>
<tr><td>0.2</td><td>1 bit</td><td></td><td>Partition contains bootable legacy BIOS, equivalent to MBR active flag</td></tr>
<tr><td>0.3</td><td>45 bits</td><td></td><td>Unknown (Reserved)</td></tr>
<tr><td>6.0</td><td>16 bits</td><td></td><td>Flags specific to the partition type</td></tr>
</table></div>
<h4 id="microsoft-basic-partition-type-attribute-flags"><a class="header" href="#microsoft-basic-partition-type-attribute-flags">Microsoft basic partition type attribute flags</a></h4>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>7.4</td><td>1 bit</td><td></td><td>Partition is read-only</td></tr>
<tr><td>7.5</td><td>1 bit</td><td></td><td>Partition is a shadow copy (of another partition)</td></tr>
<tr><td>7.6</td><td>1 bit</td><td></td><td>Partition is hidden</td></tr>
<tr><td>7.7</td><td>1 bit</td><td></td><td>Partition should not have a drive letter assigned (no auto-mount)</td></tr>
</table></div>
<h4 id="chromeos-partition-type-attribute-flags"><a class="header" href="#chromeos-partition-type-attribute-flags">ChromeOS partition type attribute flags</a></h4>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>6.0</td><td>4 bits</td><td></td><td>Priority, where 15 is thehighest priority, 1 is the lowest and 0 indicates the partition is not bootable</td></tr>
<tr><td>6.4</td><td>4 bits</td><td></td><td>Number of tries to attempt to boot from the partition</td></tr>
<tr><td>7.0</td><td>1 bit</td><td></td><td>Partition was previously successfully booted from</td></tr>
</table></div><div style="break-before: page; page-break-before: always;"></div><h1 id="master-boot-record-mbr-partition-table-format"><a class="header" href="#master-boot-record-mbr-partition-table-format">Master Boot Record (MBR) partition table format</a></h1>
<p>The Master Boot Record (MBR) partition table is mainly used on the family of
Intel x86 based computers.</p>
<h2 id="overview-9"><a class="header" href="#overview-9">Overview</a></h2>
<p>A MBR partition table consists of:</p>
<ul>
<li>Master Boot Record (MBR)</li>
<li>Extended Partition Records (EPRs)</li>
</ul>
<h3 id="characteristics-8"><a class="header" href="#characteristics-8">Characteristics</a></h3>
<div class="table-wrapper"><table><thead><th>Characteristics</th><th>Description</th></thead><tr><td>Byte order</td><td>little-endian</td></tr>
<tr><td>Date and time values</td><td>N/A</td></tr>
<tr><td>Character strings</td><td>N/A</td></tr>
</table></div>
<h3 id="terminology-2"><a class="header" href="#terminology-2">Terminology</a></h3>
<div class="table-wrapper"><table><thead><th>Term</th><th>Description</th></thead><tr><td>Physical block</td><td>A fixed location on the storage media defined by the storage media.</td></tr>
<tr><td>Logical block</td><td>An abstract location on the storage media defined by software.</td></tr>
</table></div>
<h3 id="sector-sizes"><a class="header" href="#sector-sizes">Sector size(s)</a></h3>
<p>Traditionally the size of sector is 512 bytes, but modern hard disk drives use
4096 bytes. The linux fdisk utility supports sector sizes of: 512, 1024, 2048
and 4096.</p>
<p>The location of of the "boot signature" of the MBR does not indicate the sector
size. Methods to derive the sector size from the data:</p>
<ul>
<li>check the "boot signature" of the first EPR, if present</li>
<li>check the content of well known partition types</li>
</ul>
<h2 id="cylinder-head-sector-chs-address"><a class="header" href="#cylinder-head-sector-chs-address">Cylinder Head Sector (CHS) address</a></h2>
<p>The Cylinder Head Sector (CHS) address is 24 bits in size and consists of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0.0 </td><td>8 bits</td><td></td><td>Head</td></tr>
<tr><td>1.0 </td><td>6 bits</td><td></td><td>Sector</td></tr>
<tr><td>1.5</td><td>10 bits</td><td></td><td>Cylinder</td></tr>
</table></div>
<p>The logical block address (LBA) can be determined from the CHS with the
following calculation:</p>
<pre><code>LBA = ( ( ( cylinder * heads per cylinder ) + head ) * sectors per track ) + sector - 1
</code></pre>
<h2 id="the-master-boot-record-mbr"><a class="header" href="#the-master-boot-record-mbr">The Master Boot Record (MBR)</a></h2>
<p>The Master Boot Record (MBR) is a data structure that describes the properties
of the storage medium and its partitions.</p>
<p>The classical MBR can only contain 4 partition table entries. Additional
partition entries must be stored using extended partition records (EPR). The
classical MBR has evolved into different variants like:</p>
<ul>
<li>The modern MBR</li>
<li>The Advanced Active Partitions (AAP) MBR</li>
<li>The NEWLDR MBR</li>
<li>The AST/NEC MS-DOS and SpeedStor MBR</li>
<li>The Disk Manager MBR</li>
</ul>
<h3 id="the-classical-mbr"><a class="header" href="#the-classical-mbr">The classical MBR</a></h3>
<p>The classical MBR is 512 bytes in size and consists of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>446</td><td></td><td>The boot (loader) code</td></tr>
<tr><td>446</td><td>16</td><td></td><td>Partition table entry 1</td></tr>
<tr><td>462</td><td>16</td><td></td><td>Partition table entry 2</td></tr>
<tr><td>478</td><td>16</td><td></td><td>Partition table entry 3</td></tr>
<tr><td>494</td><td>16</td><td></td><td>Partition table entry 4</td></tr>
<tr><td>510</td><td>2</td><td>"\x55\xaa"</td><td>The (boot) signature</td></tr>
</table></div>
<h3 id="the-modern-mbr"><a class="header" href="#the-modern-mbr">The modern MBR</a></h3>
<p>The modern MBR is 512 bytes in size and consists of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>218</td><td></td><td>The first part of the boot (loader) code</td></tr>
<tr><td colspan="4"> <em>Disk timestamp</em> used by Microsoft Windows 95, 98 and ME</tr>
<tr><td><strong>218</strong></td><td><strong>2</strong></td><td><strong>0x0000</strong></td><td>Unknown (Reserved)</td></tr>
<tr><td><strong>220</strong></td><td><strong>1</strong></td><td></td><td>Unknown (Original physical drive), which contains a value that ranges from 0x80 to 0xff, where 0x80 is the first drive, 0x81 the second, etc.</td></tr>
<tr><td><strong>221</strong></td><td><strong>1</strong></td><td></td><td><strong>Seconds</strong>, which contains a value that ranges from 0 to 59</td></tr>
<tr><td><strong>222</strong></td><td><strong>1</strong></td><td></td><td><strong>Minutes</strong>, which contains a value that ranges from 0 to 59</td></tr>
<tr><td><strong>223</strong></td><td><strong>1</strong></td><td></td><td><strong>Hours</strong>, which contains a value that ranges from 0 to 23</td></tr>
<tr><td colspan="4"> <em>Without disk identity</em></tr>
<tr><td>224</td><td>222</td><td></td><td>The second part of the boot (loader) code</td></tr>
<tr><td colspan="4"> <em>With disk identity</em>, used by UEFI, Microsoft Windows NT or later</tr>
<tr><td>224</td><td>216</td><td></td><td>The second part of the boot (loader) code</td></tr>
<tr><td><strong>440</strong></td><td><strong>4</strong></td><td></td><td><strong>Disk identity (signature)</strong></td></tr>
<tr><td><strong>444</strong></td><td><strong>2</strong></td><td><strong>0x0000</strong> or <strong>0x5a5a</strong></td><td><strong>copy-protection marker</strong></td></tr>
<tr><td colspan="4"> <em>Common</em></tr>
<tr><td>446</td><td>16</td><td></td><td>Partition table entry 1</td></tr>
<tr><td>462</td><td>16</td><td></td><td>Partition table entry 2</td></tr>
<tr><td>478</td><td>16</td><td></td><td>Partition table entry 3</td></tr>
<tr><td>494</td><td>16</td><td></td><td>Partition table entry 4</td></tr>
<tr><td>510</td><td>2</td><td>"\x55\xaa"</td><td>The (boot) signature</td></tr>
</table></div>
<h2 id="the-extended-partition-record"><a class="header" href="#the-extended-partition-record">The extended partition record</a></h2>
<p>The extended partition record (EPR) (also referred to as extended boot record
(EBR)) starts with a 64 byte (extended) partition record (EPR) like the MBR.
This partition table contains information about the logical partition (volume)
and additional extended partition tables.</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>446</td><td>0x00</td><td>Unknown (Unused), which should contain zero bytes</td></tr>
<tr><td>446</td><td>16</td><td></td><td>Partition table entry 1</td></tr>
<tr><td>462</td><td>16</td><td></td><td>Partition table entry 2, which should contain an extended partition</td></tr>
<tr><td>478</td><td>16</td><td>0x00</td><td>Partition table entry 3, which should be unused and contain zero bytes</td></tr>
<tr><td>494</td><td>16</td><td>0x00</td><td>Partition table entry 4, which should be unused and contain zero bytes</td></tr>
<tr><td>510</td><td>2</td><td>"\x55\xaa"</td><td>Signature</td></tr>
</table></div>
<p>The second partition entry contains an extended partition which points to the
next EPR. The LBA addresses in the EPR are relative to the start of the first
EPR.</p>
<p>The first EPR typically has a <a href="mbr.html#partition_types">partition type</a> of 0x05 but
certain version of Windows are known to use a partition type 0x0f, such as
Windows 98.</p>
<h2 id="the-partition-table-entry"><a class="header" href="#the-partition-table-entry">The partition table entry</a></h2>
<p>The partition table entry is 16 bytes in size and consists of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>1</td><td></td><td><a href="mbr.html#partition_flags">Partition flags</a></td></tr>
<tr><td>1</td><td>3</td><td></td><td>The partition start address, which contains a CHS relative from the start of the harddisk</td></tr>
<tr><td>4</td><td>1</td><td></td><td><a href="mbr.html#partition_types">Partition type</a></td></tr>
<tr><td>5</td><td>3</td><td></td><td>The partition end address, which contains a CHS relative from the start of the harddisk</td></tr>
<tr><td>8</td><td>4</td><td></td><td>The partition start address, which contains a LBA (sectors) relative from the start of the harddisk</td></tr>
<tr><td>12</td><td>4</td><td></td><td>Size of the partition in number of sectors</td></tr>
</table></div>
<h3 id="partition-flags"><a class="header" href="#partition-flags"><a name="partition_flags"></a>Partition flags</a></h3>
<p>The partition flags consist of the following values:</p>
<div class="table-wrapper"><table><thead><th>Value</th><th>Identifier</th><th>Description</th></thead><tr><td>0x80</td><td></td><td>Partition is boot-able</td></tr>
</table></div>
<h3 id="partition-types-2"><a class="header" href="#partition-types-2"><a name="partition_types"></a>Partition types</a></h3>
<p>The partition types consist of the following values:</p>
<div class="table-wrapper"><table><thead><th>Value</th><th>Identifier</th><th>Description</th></thead><tr><td>0x00</td><td></td><td>Empty</td></tr>
<tr><td>0x01</td><td></td><td>FAT12 (CHS)</td></tr>
<tr><td>0x02</td><td></td><td>XENIX root</td></tr>
<tr><td>0x02</td><td></td><td>XENIX user</td></tr>
<tr><td>0x04</td><td></td><td>FAT16 (16 MiB -32 MiB CHS)</td></tr>
<tr><td>0x05</td><td></td><td>Extended (CHS)</td></tr>
<tr><td>0x06</td><td></td><td>FAT16 (32 MiB - 2 GiB CHS)</td></tr>
<tr><td>0x07</td><td></td><td>HPFS/NTFS</td></tr>
<tr><td>0x08</td><td></td><td>AIX</td></tr>
<tr><td>0x09</td><td></td><td>AIX bootable</td></tr>
<tr><td>0x0a</td><td></td><td>OS/2 Boot Manager</td></tr>
<tr><td>0x0b</td><td></td><td>FAT32 (CHS)</td></tr>
<tr><td>0x0c</td><td></td><td>FAT32 (LBA)</td></tr>
<tr><td></td><td></td><td></td></tr>
<tr><td>0x0e</td><td></td><td>FAT16 (32 MiB - 2 GiB LBA)</td></tr>
<tr><td>0x0f</td><td></td><td>Extended (LBA)</td></tr>
<tr><td>0x10</td><td></td><td>OPUS</td></tr>
<tr><td>0x11</td><td></td><td>Hidden FAT12 (CHS)</td></tr>
<tr><td>0x12</td><td></td><td>Compaq diagnostics</td></tr>
<tr><td></td><td></td><td></td></tr>
<tr><td>0x14</td><td></td><td>Hidden FAT16 (16 MiB - 32 MiB CHS)</td></tr>
<tr><td></td><td></td><td></td></tr>
<tr><td>0x16</td><td></td><td>Hidden FAT16 (32 MiB - 2 GiB CHS)</td></tr>
<tr><td>0x17</td><td></td><td>Hidden HPFS/NTFS</td></tr>
<tr><td>0x18</td><td></td><td>AST SmartSleep</td></tr>
<tr><td></td><td></td><td></td></tr>
<tr><td>0x1b</td><td></td><td>Hidden FAT32 (CHS)</td></tr>
<tr><td>0x1c</td><td></td><td>Hidden FAT32 (LBA)</td></tr>
<tr><td></td><td></td><td></td></tr>
<tr><td>0x1e</td><td></td><td>Hidden FAT16 (32 MiB - 2 GiB LBA)</td></tr>
<tr><td></td><td></td><td></td></tr>
<tr><td>0x24</td><td></td><td>NEC DOS</td></tr>
<tr><td></td><td></td><td></td></tr>
<tr><td>0x27</td><td></td><td>Unknown (PackardBell recovery/installation partition)</td></tr>
<tr><td></td><td></td><td></td></tr>
<tr><td>0x39</td><td></td><td>Plan 9</td></tr>
<tr><td></td><td></td><td></td></tr>
<tr><td>0x3c</td><td></td><td>PartitionMagic recovery</td></tr>
<tr><td></td><td></td><td></td></tr>
<tr><td>0x40</td><td></td><td>Venix 80286</td></tr>
<tr><td>0x41</td><td></td><td>PPC PReP Boot</td></tr>
<tr><td>0x42</td><td></td><td>SFS or LDM: Microsoft MBR (Dynamic Disk)</td></tr>
<tr><td></td><td></td><td></td></tr>
<tr><td>0x4d</td><td></td><td>QNX4.x</td></tr>
<tr><td>0x4e</td><td></td><td>QNX4.x 2nd part</td></tr>
<tr><td>0x4f</td><td></td><td>QNX4.x 3rd part</td></tr>
<tr><td>0x50</td><td></td><td>OnTrack DM</td></tr>
<tr><td>0x51</td><td></td><td>OnTrack DM6 Aux1</td></tr>
<tr><td>0x52</td><td></td><td>CP/M</td></tr>
<tr><td>0x53</td><td></td><td>OnTrack DM6 Aux3</td></tr>
<tr><td>0x54</td><td></td><td>OnTrackDM6</td></tr>
<tr><td>0x55</td><td></td><td>EZ-Drive</td></tr>
<tr><td>0x56</td><td></td><td>Golden Bow</td></tr>
<tr><td></td><td></td><td></td></tr>
<tr><td>0x5c</td><td></td><td>Priam Edisk</td></tr>
<tr><td></td><td></td><td></td></tr>
<tr><td>0x61</td><td></td><td>SpeedStor</td></tr>
<tr><td></td><td></td><td></td></tr>
<tr><td>0x63</td><td></td><td>GNU HURD or SysV</td></tr>
<tr><td>0x64</td><td></td><td>Novell Netware 286</td></tr>
<tr><td>0x65</td><td></td><td>Novell Netware 386</td></tr>
<tr><td></td><td></td><td></td></tr>
<tr><td>0x70</td><td></td><td>DiskSecure Multi-Boot</td></tr>
<tr><td></td><td></td><td></td></tr>
<tr><td>0x75</td><td></td><td>PC/IX</td></tr>
<tr><td></td><td></td><td></td></tr>
<tr><td>0x78</td><td></td><td>XOSL</td></tr>
<tr><td></td><td></td><td></td></tr>
<tr><td>0x80</td><td></td><td>Old Minix</td></tr>
<tr><td>0x81</td><td></td><td>Minix / old Linux</td></tr>
<tr><td>0x82</td><td></td><td>Solaris x86 or Linux swap</td></tr>
<tr><td>0x83</td><td></td><td>Linux</td></tr>
<tr><td>0x84</td><td></td><td>Hibernation or OS/2 hidden C: drive</td></tr>
<tr><td>0x85</td><td></td><td>Linux extended</td></tr>
<tr><td>0x86</td><td></td><td>NTFS volume set</td></tr>
<tr><td>0x87</td><td></td><td>NTFS volume set</td></tr>
<tr><td></td><td></td><td></td></tr>
<tr><td>0x8e</td><td></td><td>Linux LVM</td></tr>
<tr><td></td><td></td><td></td></tr>
<tr><td>0x93</td><td></td><td>Amoeba</td></tr>
<tr><td>0x94</td><td></td><td>Amoeba BBT</td></tr>
<tr><td></td><td></td><td></td></tr>
<tr><td>0x9f</td><td></td><td>BSD/OS</td></tr>
<tr><td>0xa0</td><td></td><td>IBM Thinkpad hibernation</td></tr>
<tr><td>0xa1</td><td></td><td>Hibernation</td></tr>
<tr><td></td><td></td><td></td></tr>
<tr><td>0xa5</td><td></td><td>FreeBSD</td></tr>
<tr><td>0xa6</td><td></td><td>OpenBSD</td></tr>
<tr><td>0xa7</td><td></td><td>NeXTSTEP</td></tr>
<tr><td>0xa8</td><td></td><td>Mac OS X</td></tr>
<tr><td>0xa9</td><td></td><td>NetBSD</td></tr>
<tr><td></td><td></td><td></td></tr>
<tr><td>0xab</td><td></td><td>Mac OS X Boot</td></tr>
<tr><td></td><td></td><td></td></tr>
<tr><td>0xaf</td><td></td><td>Mac OS X</td></tr>
<tr><td></td><td></td><td></td></tr>
<tr><td>0xb7</td><td></td><td>BSDI</td></tr>
<tr><td>0xb8</td><td></td><td>BSDI swap</td></tr>
<tr><td></td><td></td><td></td></tr>
<tr><td>0xbb</td><td></td><td>Boot Wizard hidden</td></tr>
<tr><td></td><td></td><td></td></tr>
<tr><td>0xc1</td><td></td><td>DRDOS/sec (FAT-12)</td></tr>
<tr><td></td><td></td><td></td></tr>
<tr><td>0xc4</td><td></td><td>DRDOS/sec (FAT-16 &lt; 32M)</td></tr>
<tr><td></td><td></td><td></td></tr>
<tr><td>0xc6</td><td></td><td>DRDOS/sec (FAT-16)</td></tr>
<tr><td>0xc7</td><td></td><td>Syrinx</td></tr>
<tr><td></td><td></td><td></td></tr>
<tr><td>0xda</td><td></td><td>Non-FS data</td></tr>
<tr><td>0xdb</td><td></td><td>CP/M / CTOS / ...</td></tr>
<tr><td></td><td></td><td></td></tr>
<tr><td>0xde</td><td></td><td>Dell Utility</td></tr>
<tr><td>0xdf</td><td></td><td>BootIt</td></tr>
<tr><td></td><td></td><td></td></tr>
<tr><td>0xe1</td><td></td><td>DOS access</td></tr>
<tr><td></td><td></td><td></td></tr>
<tr><td>0xe3</td><td></td><td>DOS R/O</td></tr>
<tr><td>0xe4</td><td></td><td>SpeedStor</td></tr>
<tr><td></td><td></td><td></td></tr>
<tr><td>0xeb</td><td></td><td>BeOS</td></tr>
<tr><td></td><td></td><td></td></tr>
<tr><td>0xee</td><td></td><td>EFI GPT protective partition</td></tr>
<tr><td>0xef</td><td></td><td>EFI system partition (FAT)</td></tr>
<tr><td>0xf0</td><td></td><td>Linux/PA-RISC boot</td></tr>
<tr><td>0xf1</td><td></td><td>SpeedStor</td></tr>
<tr><td>0xf2</td><td></td><td>DOS secondary</td></tr>
<tr><td></td><td></td><td></td></tr>
<tr><td>0xf4</td><td></td><td>SpeedStor</td></tr>
<tr><td></td><td></td><td></td></tr>
<tr><td>0xfb</td><td></td><td>VMWare file system</td></tr>
<tr><td>0xfc</td><td></td><td>VMWare swap</td></tr>
<tr><td>0xfd</td><td></td><td>Linux RAID auto-detect</td></tr>
<tr><td>0xfe</td><td></td><td>LANstep</td></tr>
<tr><td>0xff</td><td></td><td>BBT</td></tr>
</table></div><div style="break-before: page; page-break-before: always;"></div><h1 id="file-system-formats"><a class="header" href="#file-system-formats">File system formats</a></h1>
<p>A file system format is used to manage the storage of one or more files.</p>
<h2 id="terminology-3"><a class="header" href="#terminology-3">Terminology</a></h2>
<h3 id="file-entry"><a class="header" href="#file-entry">File entry</a></h3>
<p>A file entry (or file system entry) is an object that represent an element within
the file system such as a file or directory. It typically includes metadata such
as the file name, size, permissions, date and time values, and location of the
content on storage media.</p>
<h3 id="data-fork-or-data-stream"><a class="header" href="#data-fork-or-data-stream">Data fork (or data stream)</a></h3>
<p>TODO</p>
<h3 id="extended-attribute-1"><a class="header" href="#extended-attribute-1">Extended attribute</a></h3>
<p>TODO</p>
<h3 id="reparse-point"><a class="header" href="#reparse-point">Reparse point</a></h3>
<p>NTFS and ReFS use reparse points to extend the file system.</p>
<ul>
<li>https://learn.microsoft.com/en-us/windows/win32/fileio/reparse-points</li>
<li>https://en.wikipedia.org/wiki/NTFS_reparse_point</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="extended-file-system-ext-format"><a class="header" href="#extended-file-system-ext-format">Extended File System (ext) format</a></h1>
<p>The Extended File System (ext) is one of the more common file system used in
Linux.</p>
<p>There are multiple version of ext.</p>
<div class="table-wrapper"><table><thead><th>Version</th><th>Remarks</th></thead><tr><td>1</td><td>Introduced in April 1992</td></tr>
<tr><td>2</td><td>Introduced in January 1993</td></tr>
<tr><td>3</td><td>Introduced in November 2001, which featured journaling, dynamic growth and large directory indexing (HTree)</td></tr>
<tr><td>4</td><td>Introduces in October 2006 as unstable and becmae stable in October 2008, which featured extents and improved timestamps</td></tr>
</table></div>
<h2 id="overview-10"><a class="header" href="#overview-10">Overview</a></h2>
<p>An Extended File System (ext) consists of:</p>
<ul>
<li>one or more block groups</li>
</ul>
<h3 id="characteristics-9"><a class="header" href="#characteristics-9">Characteristics</a></h3>
<div class="table-wrapper"><table><thead><th>Characteristics</th><th>Description</th></thead><tr><td>Byte order</td><td>little-endian, with the exception of UUID values that are stored in big-endian.</td></tr>
<tr><td>Date and time values</td><td>number of seconds since January 1, 1970 00:00:00 (POSIX epoch), disregarding leap seconds. Or number of nanoseconds, when extra precision is enabled. Date and time values are stored in UTC.</td></tr>
<tr><td>Character strings</td><td>UTF-8 or a narrow character (Single Byte Character (SBC) or Multi Byte Character (MBC)) stored using a system defined codepage.</td></tr>
</table></div>
<h2 id="block-group"><a class="header" href="#block-group">Block group</a></h2>
<p>A block group consists of:</p>
<ul>
<li>optional 1024 bytes of boot code or zero bytes (at offset: 0)</li>
<li>optional superblock</li>
<li>optional group descriptor table</li>
<li>block bitmap</li>
<li>inode bitmap</li>
<li>allocated and unallocated blocks</li>
</ul>
<p>The primary superblock is stored at offset 1024 relative from the start of the
volume. Backup superblocks are stored at offset 1024 relative from the start of
the block group if block size &lt;= 1024 or otherwise at offset 0 from the start
of the block group.</p>
<p>The group descriptor table is stored in the block after the superblock.</p>
<p>The ext2 revision 0 stores a copy at the start of every block group, along with
backups of the group descriptor table. Later revisions can reduce the number of
backup copies by only putting backups in specific groups (sparse superblock
feature EXT2_FEATURE_RO_COMPAT_SPARSE_SUPER).</p>
<blockquote>
<p>Note backup superblocks can be empty (filled with 0-byte values) or contain
remnant data on an Android ext file system with sparse_super.</p>
</blockquote>
<blockquote>
<p>Note that not all values in a backup superblock and backup group descriptor
tables always match those of the primary superblock and group descriptor
table.</p>
</blockquote>
<h3 id="flex-block-groups"><a class="header" href="#flex-block-groups">Flex block groups</a></h3>
<p>Flex (or flexible) block groups are a set of block groups that treated as
a single logical block group. Metadata such as the superblock, group
descriptors, data block bitmaps spans the entire logical block group and
not the individual block groups part of the set.</p>
<h3 id="meta-block-groups"><a class="header" href="#meta-block-groups">Meta block groups</a></h3>
<p>Meta block groups (META_BG) are a set (or cluster) of block groups, for which
its group descriptor structures can be stored in a single block.</p>
<p>The first meta block group value in the superblock indicates what the first</p>
<p>meta block group value is 256, and the number of group descriptors that can be
stored in a single block 64, then the group descriptors for the block groups
[0, 16383] are stored in the group descriptor table after the primary
superblock and corresponding locations of backups.</p>
<p>Successive group descriptor tables, for example [16384, 16447], are stored in
the first block group of a meta block group and backups in the second and last
block groups of the meta block group.</p>
<h3 id="blocks"><a class="header" href="#blocks">Blocks</a></h3>
<p>The volume is devided in blocks:</p>
<pre><code>block offset = block number x block size
</code></pre>
<p>The block size is defined in the superblock.</p>
<h2 id="the-superblock"><a class="header" href="#the-superblock">The superblock</a></h2>
<h3 id="the-ext2-superblock"><a class="header" href="#the-ext2-superblock">The ext2 superblock</a></h3>
<p>The ext2 superblock is 208 bytes in size and consists of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>4</td><td></td><td>Number of inodes</td></tr>
<tr><td>4</td><td>4</td><td></td><td>Number of blocks</td></tr>
<tr><td>8</td><td>4</td><td></td><td>Number of reserved blocks. Reserved blocks are used to prevent the file system from filling up.</td></tr>
<tr><td>12</td><td>4</td><td></td><td>Number of unallocated blocks</td></tr>
<tr><td>16</td><td>4</td><td></td><td>Number of unallocated inodes</td></tr>
<tr><td>20</td><td>4</td><td></td><td>First data block number. The block number is relative from the start of the volume</td></tr>
<tr><td>24</td><td>4</td><td></td><td>Block size, which contains the number of bits to shift 1024 to the MSB (left)</td></tr>
<tr><td>28</td><td>4</td><td></td><td>Fragment size, which contains the number of bits to shift 1024 to the MSB (left)</td></tr>
<tr><td>32</td><td>4</td><td></td><td>Number of blocks per block group</td></tr>
<tr><td>36</td><td>4</td><td></td><td>Number of fragments per block group</td></tr>
<tr><td>40</td><td>4</td><td></td><td>Number of inodes per block group</td></tr>
<tr><td>44</td><td>4</td><td></td><td>Last mount time, which contains the number of seconds since January 1, 1970 00:00:00 UTC (POSIX epoch)</td></tr>
<tr><td>48</td><td>4</td><td></td><td>Last written time, which contains the number of seconds since January 1, 1970 00:00:00 UTC (POSIX epoch)</td></tr>
<tr><td>52</td><td>2</td><td></td><td>The (current) mount count</td></tr>
<tr><td>54</td><td>2</td><td></td><td>Maximum mount count</td></tr>
<tr><td>56</td><td>2</td><td>"\x53\xef"</td><td>Signature</td></tr>
<tr><td>58</td><td>2</td><td></td><td><a href="ext.html#file_system_state_flags">File system state flags</a></td></tr>
<tr><td>60</td><td>2</td><td></td><td><a href="ext.html#error_handling_status">Error-handling status</a></td></tr>
<tr><td>62</td><td>2</td><td></td><td>Minor format revision</td></tr>
<tr><td>64</td><td>4</td><td></td><td>Last consistency check time, which contains the number of seconds since January 1, 1970 00:00:00 UTC (POSIX epoch)</td></tr>
<tr><td>68</td><td>4</td><td></td><td>Consistency check interval, which which contains the number of seconds since January 1, 1970 00:00:00 UTC (POSIX epoch)</td></tr>
<tr><td>72</td><td>4</td><td></td><td><a href="ext.html#creator_operating_system">Creator operating system</a></td></tr>
<tr><td>76</td><td>4</td><td></td><td><a href="ext.html#format_revisision">Format revision</a></td></tr>
<tr><td>80</td><td>2</td><td></td><td>Reserved block owner (or user) identifier (UID)</td></tr>
<tr><td>82</td><td>2</td><td></td><td>Reserved block group identifier (GID)</td></tr>
<tr><td colspan="4"> <em>Dynamic inode information, if major version is EXT2_DYNAMIC_REV</em></tr>
<tr><td>84</td><td>4</td><td></td><td>First non-reserved inode</td></tr>
<tr><td>88</td><td>2</td><td></td><td>Inode size. Note that the inode size must be a power of 2 larger or equal to 128, the maximum supported by mke2fs is 1024</td></tr>
<tr><td>90</td><td>2</td><td></td><td>Block group, which contains a block group number</td></tr>
<tr><td>92</td><td>4</td><td></td><td><a href="ext.html#compatible_feature_flags">Compatible feature flags</a></td></tr>
<tr><td>96</td><td>4</td><td></td><td><a href="ext.html#incompatible_feature_flags">Incompatible feature flags</a></td></tr>
<tr><td>100</td><td>4</td><td></td><td><a href="ext.html#read_only_compatible_feature_flags">Read-only compatible feature flags</a></td></tr>
<tr><td>104</td><td>16</td><td></td><td>File system identifier, which contains a big-endian UUID</td></tr>
<tr><td>120</td><td>16</td><td></td><td>Volume label, which contains a narrow character string without end-of-string character</td></tr>
<tr><td>136</td><td>64</td><td></td><td>Last mount path, which contains a narrow character string without end-of-string character</td></tr>
<tr><td>200</td><td>4</td><td></td><td>Algorithm usage bitmap</td></tr>
<tr><td colspan="4"> <em>Performance hints, if EXT2_COMPAT_PREALLOC is set</em></tr>
<tr><td>204</td><td>1</td><td></td><td>Number of pre-allocated blocks per file</td></tr>
<tr><td>205</td><td>1</td><td></td><td>Number of pre-allocated blocks per directory</td></tr>
<tr><td>206</td><td>2</td><td></td><td>Unknown (padding)</td></tr>
</table></div>
<h3 id="the-ext3-superblock"><a class="header" href="#the-ext3-superblock">The ext3 superblock</a></h3>
<p>The ext3 superblock is 336 bytes in size and consists of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>4</td><td></td><td>Number of inodes</td></tr>
<tr><td>4</td><td>4</td><td></td><td>Number of blocks</td></tr>
<tr><td>8</td><td>4</td><td></td><td>Number of reserved blocks. Reserved blocks are used to prevent the file system from filling up.</td></tr>
<tr><td>12</td><td>4</td><td></td><td>Number of unallocated blocks</td></tr>
<tr><td>16</td><td>4</td><td></td><td>Number of unallocated inodes</td></tr>
<tr><td>20</td><td>4</td><td></td><td>First data block number. The block number is relative from the start of the volume</td></tr>
<tr><td>24</td><td>4</td><td></td><td>Block size, which contains the number of bits to shift 1024 to the MSB (left)</td></tr>
<tr><td>28</td><td>4</td><td></td><td>Fragment size, which contains the number of bits to shift 1024 to the MSB (left)</td></tr>
<tr><td>32</td><td>4</td><td></td><td>Number of blocks per block group</td></tr>
<tr><td>36</td><td>4</td><td></td><td>Number of fragments per block group</td></tr>
<tr><td>40</td><td>4</td><td></td><td>Number of inodes per block group, which can be 0 in combination with EXT3_FEATURE_INCOMPAT_JOURNAL_DEV</td></tr>
<tr><td>44</td><td>4</td><td></td><td>Last mount time, which contains the number of seconds since January 1, 1970 00:00:00 UTC (POSIX epoch)</td></tr>
<tr><td>48</td><td>4</td><td></td><td>Last written time, which contains the number of seconds since January 1, 1970 00:00:00 UTC (POSIX epoch)</td></tr>
<tr><td>52</td><td>2</td><td></td><td>The (current) mount count</td></tr>
<tr><td>54</td><td>2</td><td></td><td>Maximum mount count</td></tr>
<tr><td>56</td><td>2</td><td>"\x53\xef"</td><td>Signature</td></tr>
<tr><td>58</td><td>2</td><td></td><td><a href="ext.html#file_system_state_flags">File system state flags</a></td></tr>
<tr><td>60</td><td>2</td><td></td><td><a href="ext.html#error_handling_status">Error-handling status</a></td></tr>
<tr><td>62</td><td>2</td><td></td><td>Minor format revision</td></tr>
<tr><td>64</td><td>4</td><td></td><td>Last consistency check time, which contains the number of seconds since January 1, 1970 00:00:00 UTC (POSIX epoch)</td></tr>
<tr><td>68</td><td>4</td><td></td><td>Consistency check interval, which which contains the number of seconds since January 1, 1970 00:00:00 UTC (POSIX epoch)</td></tr>
<tr><td>72</td><td>4</td><td></td><td><a href="ext.html#creator_operating_system">Creator operating system</a></td></tr>
<tr><td>76</td><td>4</td><td></td><td><a href="ext.html#format_revisision">Format revision</a></td></tr>
<tr><td>80</td><td>2</td><td></td><td>Reserved block owner (or user) identifier (UID)</td></tr>
<tr><td>82</td><td>2</td><td></td><td>Reserved block group identifier (GID)</td></tr>
<tr><td colspan="4"> <em>Dynamic inode information, if major version is EXT2_DYNAMIC_REV</em></tr>
<tr><td>84</td><td>4</td><td></td><td>First non-reserved inode</td></tr>
<tr><td>88</td><td>2</td><td></td><td>Inode size. Note that the inode size must be a power of 2 larger or equal to 128, the maximum supported by mke2fs is 1024</td></tr>
<tr><td>90</td><td>2</td><td></td><td>Block group, which contains a block group number</td></tr>
<tr><td>92</td><td>4</td><td></td><td><a href="ext.html#compatible_feature_flags">Compatible feature flags</a></td></tr>
<tr><td>96</td><td>4</td><td></td><td><a href="ext.html#incompatible_feature_flags">Incompatible feature flags</a></td></tr>
<tr><td>100</td><td>4</td><td></td><td><a href="ext.html#read_only_compatible_feature_flags">Read-only compatible feature flags</a></td></tr>
<tr><td>104</td><td>16</td><td></td><td>File system identifier, which contains a big-endian UUID</td></tr>
<tr><td>120</td><td>16</td><td></td><td>Volume label, which contains a narrow character string without end-of-string character</td></tr>
<tr><td>136</td><td>64</td><td></td><td>Last mount path, which contains a narrow character string without end-of-string character</td></tr>
<tr><td>200</td><td>4</td><td></td><td>Algorithm usage bitmap</td></tr>
<tr><td colspan="4"> <em>Performance hints, if EXT2_COMPAT_PREALLOC is set</em></tr>
<tr><td>204</td><td>1</td><td></td><td>Number of pre-allocated blocks per file</td></tr>
<tr><td>205</td><td>1</td><td></td><td>Number of pre-allocated blocks per directory</td></tr>
<tr><td>206</td><td>2</td><td></td><td>Unknown (padding)</td></tr>
<tr><td colspan="4"> <em>Journalling support, if EXT3_FEATURE_COMPAT_HAS_JOURNAL is set</em></tr>
<tr><td>208</td><td>16</td><td></td><td>Journal identifier, which contains a big-endian UUID</td></tr>
<tr><td>224</td><td>4</td><td></td><td>Journal inode</td></tr>
<tr><td>228</td><td>4</td><td></td><td>Unknown (Journal device)</td></tr>
<tr><td>232</td><td>4</td><td></td><td>Unknown (Head of orphan inode list). The orphan inode list is a list of inodes to delete.</td></tr>
<tr><td>236</td><td>4 x 4</td><td></td><td>hash-tree seed</td></tr>
<tr><td>252</td><td>1</td><td></td><td>Default hash version</td></tr>
<tr><td>253</td><td>1</td><td></td><td>Journal backup type</td></tr>
<tr><td>254</td><td>2</td><td></td><td>Group descriptor size</td></tr>
<tr><td>256</td><td>4</td><td></td><td>Default mount options</td></tr>
<tr><td>260</td><td>4</td><td></td><td>First meta block group (or metablock)</td></tr>
<tr><td>264</td><td>4</td><td></td><td>File system creation time, which contains the number of seconds since January 1, 1970 00:00:00 UTC (POSIX epoch)</td></tr>
<tr><td>268</td><td>17 x 4</td><td></td><td>Backup journal inodes</td></tr>
</table></div>
<h3 id="the-ext4-superblock"><a class="header" href="#the-ext4-superblock">The ext4 superblock</a></h3>
<p>The superblock is 1024 bytes in size and consists of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>4</td><td></td><td>Number of inodes</td></tr>
<tr><td>4</td><td>4</td><td></td><td>Number of blocks, which contains the lower 32-bit of the value</td></tr>
<tr><td>8</td><td>4</td><td></td><td>Number of reserved blocks, which contains the lower 32-bit of the value. Reserved blocks are used to prevent the file system from filling up.</td></tr>
<tr><td>12</td><td>4</td><td></td><td>Number of unallocated blocks, which contains the lower 32-bit of the value</td></tr>
<tr><td>16</td><td>4</td><td></td><td>Number of unallocated inodes, which contains the lower 32-bit of the value</td></tr>
<tr><td>20</td><td>4</td><td></td><td>Root group block number. The block number is relative from the start of the volume</td></tr>
<tr><td>24</td><td>4</td><td></td><td>Block size, which contains the number of bits to shift 1024 to the most-significant-bit (MSB)</td></tr>
<tr><td>28</td><td>4</td><td></td><td>Fragment size, which contains the number of bits to shift 1024 to the most-significant-bit (MSB)</td></tr>
<tr><td>32</td><td>4</td><td></td><td>Number of blocks per block group</td></tr>
<tr><td>36</td><td>4</td><td></td><td>Number of fragments per block group</td></tr>
<tr><td>40</td><td>4</td><td></td><td>Number of inodes per block group, which can be 0 in combination with EXT4_FEATURE_INCOMPAT_JOURNAL_DEV</td></tr>
<tr><td>44</td><td>4</td><td></td><td>Last mount time, which contains the number of seconds since January 1, 1970 00:00:00 UTC (POSIX epoch)</td></tr>
<tr><td>48</td><td>4</td><td></td><td>Last written time, which contains the number of seconds since January 1, 1970 00:00:00 UTC (POSIX epoch)</td></tr>
<tr><td>52</td><td>2</td><td></td><td>The (current) mount count</td></tr>
<tr><td>54</td><td>2</td><td></td><td>Maximum mount count</td></tr>
<tr><td>56</td><td>2</td><td>"\x53\xef"</td><td>Signature</td></tr>
<tr><td>58</td><td>2</td><td></td><td><a href="ext.html#file_system_state_flags">File system state flags</a></td></tr>
<tr><td>60</td><td>2</td><td></td><td><a href="ext.html#error_handling_status">Error-handling status</a></td></tr>
<tr><td>62</td><td>2</td><td></td><td>Minor format revision</td></tr>
<tr><td>64</td><td>4</td><td></td><td>Last consistency check time, which contains the number of seconds since January 1, 1970 00:00:00 UTC (POSIX epoch)</td></tr>
<tr><td>68</td><td>4</td><td></td><td>Consistency check interval, which which contains the number of seconds since January 1, 1970 00:00:00 UTC (POSIX epoch)</td></tr>
<tr><td>72</td><td>4</td><td></td><td><a href="ext.html#creator_operating_system">Creator operating system</a></td></tr>
<tr><td>76</td><td>4</td><td></td><td><a href="ext.html#format_revisision">Format revision</a></td></tr>
<tr><td>80</td><td>2</td><td></td><td>Reserved block owner (or user) identifier (UID)</td></tr>
<tr><td>82</td><td>2</td><td></td><td>Reserved block group identifier (GID)</td></tr>
<tr><td colspan="4"> <em>Dynamic inode information, if major version is EXT2_DYNAMIC_REV</em></tr>
<tr><td>84</td><td>4</td><td></td><td>First non-reserved inode</td></tr>
<tr><td>88</td><td>2</td><td></td><td>Inode size. Note that the inode size must be a power of 2 larger or equal to 128, the maximum supported by mke2fs is 1024</td></tr>
<tr><td>90</td><td>2</td><td></td><td>Block group</td></tr>
<tr><td>92</td><td>4</td><td></td><td><a href="ext.html#compatible_feature_flags">Compatible feature flags</a></td></tr>
<tr><td>96</td><td>4</td><td></td><td><a href="ext.html#incompatible_feature_flags">Incompatible feature flags</a></td></tr>
<tr><td>100</td><td>4</td><td></td><td><a href="ext.html#read_only_compatible_feature_flags">Read-only compatible feature flags</a></td></tr>
<tr><td>104</td><td>16</td><td></td><td>File system identifier, which contains a big-endian UUID</td></tr>
<tr><td>120</td><td>16</td><td></td><td>Volume label, which contains a narrow character string without end-of-string character</td></tr>
<tr><td>136</td><td>64</td><td></td><td>Last mount path, which contains a narrow character string without end-of-string character</td></tr>
<tr><td>200</td><td>4</td><td></td><td>Algorithm usage bitmap</td></tr>
<tr><td colspan="4"> <em>Performance hints, if EXT2_COMPAT_PREALLOC is set</em></tr>
<tr><td>204</td><td>1</td><td></td><td>Number of pre-allocated blocks per file</td></tr>
<tr><td>205</td><td>1</td><td></td><td>Number of pre-allocated blocks per directory</td></tr>
<tr><td>206</td><td>2</td><td></td><td>Unknown (padding)</td></tr>
<tr><td colspan="4"> <em>Journalling support, if EXT3_FEATURE_COMPAT_HAS_JOURNAL is set</em></tr>
<tr><td>208</td><td>16</td><td></td><td>Journal identifier, which contains a big-endian UUID</td></tr>
<tr><td>224</td><td>4</td><td></td><td>Journal inode</td></tr>
<tr><td>228</td><td>4</td><td></td><td>Unknown (Journal device)</td></tr>
<tr><td>232</td><td>4</td><td></td><td>Unknown (Head of orphan inode list). The orphan inode list is a list of inodes to delete.</td></tr>
<tr><td>236</td><td>4 x 4</td><td></td><td>hash-tree seed</td></tr>
<tr><td>252</td><td>1</td><td></td><td>Default hash version</td></tr>
<tr><td>253</td><td>1</td><td></td><td>Journal backup type</td></tr>
<tr><td>254</td><td>2</td><td></td><td>Group descriptor size</td></tr>
<tr><td>256</td><td>4</td><td></td><td>Default mount options</td></tr>
<tr><td>260</td><td>4</td><td></td><td>First meta block group (or metablock)</td></tr>
<tr><td>264</td><td>4</td><td></td><td>File system creation time, which contains the number of seconds since January 1, 1970 00:00:00 UTC (POSIX epoch)</td></tr>
<tr><td>268</td><td>17 x 4</td><td></td><td>Backup journal inodes</td></tr>
<tr><td colspan="4"> <em>If 64-bit support (EXT4_FEATURE_INCOMPAT_64BIT) is enabled</em></tr>
<tr><td>336</td><td>4</td><td></td><td>Number of blocks, which contains the upper 32-bit of the value</td></tr>
<tr><td>340</td><td>4</td><td></td><td>Number of reserved blocks, which contains the upper 32-bit of the value</td></tr>
<tr><td>344</td><td>4</td><td></td><td>Number of unallocated blocks, which contains the upper 32-bit of the value</td></tr>
<tr><td>348</td><td>2</td><td></td><td>Minimum inode size</td></tr>
<tr><td>350</td><td>2</td><td></td><td>Reserved inode size</td></tr>
<tr><td>352</td><td>4</td><td></td><td>Miscellaneous flags</td></tr>
<tr><td>356</td><td>2</td><td></td><td>RAID stride</td></tr>
<tr><td>358</td><td>2</td><td></td><td>Multiple mount protection (MMP) update interval in seconds</td></tr>
<tr><td>360</td><td>8</td><td></td><td>Block for multi-mount protection</td></tr>
<tr><td>368</td><td>4</td><td></td><td>Unknown (blocks on all data disks (N*stride))</td></tr>
<tr><td>372</td><td>1</td><td></td><td>Number of block groups per flex block group, which is stored as: 2 ^ value</td></tr>
<tr><td>373</td><td>1</td><td></td><td><a href="ext.html#checksum_type">Checksum type</a></td></tr>
<tr><td>374</td><td>1</td><td></td><td>Unknown (encryption level)</td></tr>
<tr><td>375</td><td>1</td><td></td><td>Unknown (padding)</td></tr>
<tr><td>376</td><td>8</td><td></td><td>Unknown (s_kbytes_written)</td></tr>
<tr><td>384</td><td>4</td><td></td><td>Inode number of active snapshot</td></tr>
<tr><td>388</td><td>4</td><td></td><td>Identifier of active snapshot</td></tr>
<tr><td>392</td><td>8</td><td></td><td>Unknown (reserved s_snapshot_r_blocks_count)</td></tr>
<tr><td>400</td><td>4</td><td></td><td>Inode number of snapshot list head</td></tr>
<tr><td>404</td><td>4</td><td></td><td>Unknown (s_error_count)</td></tr>
<tr><td>408</td><td>4</td><td></td><td>Unknown (s_first_error_time)</td></tr>
<tr><td>412</td><td>4</td><td></td><td>Unknown (s_first_error_ino)</td></tr>
<tr><td>416</td><td>8</td><td></td><td>Unknown (s_first_error_block)</td></tr>
<tr><td>424</td><td>32</td><td></td><td>Unknown (s_first_error_func)</td></tr>
<tr><td>456</td><td>4</td><td></td><td>Unknown (s_first_error_line)</td></tr>
<tr><td>460</td><td>4</td><td></td><td>Unknown (s_last_error_time)</td></tr>
<tr><td>464</td><td>4</td><td></td><td>Unknown (s_last_error_ino)</td></tr>
<tr><td>468</td><td>4</td><td></td><td>Unknown (s_last_error_line)</td></tr>
<tr><td>472</td><td>8</td><td></td><td>Unknown (s_last_error_block)</td></tr>
<tr><td>480</td><td>32</td><td></td><td>Unknown (s_last_error_func)</td></tr>
<tr><td>512</td><td>64</td><td></td><td>Unknown (s_mount_opts)</td></tr>
<tr><td>576</td><td>4</td><td></td><td>Unknown (s_usr_quota_inum)</td></tr>
<tr><td>580</td><td>4</td><td></td><td>Unknown (s_grp_quota_inum)</td></tr>
<tr><td>584</td><td>4</td><td></td><td>Unknown (s_overhead_clusters)</td></tr>
<tr><td>588</td><td>2 x 4</td><td></td><td>Unknown (s_backup_bgs)</td></tr>
<tr><td>596</td><td>4</td><td></td><td>Unknown (s_encrypt_algos)</td></tr>
<tr><td>600</td><td>16</td><td></td><td>Unknown (s_encrypt_pw_salt)</td></tr>
<tr><td>616</td><td>4</td><td></td><td>Unknown (s_lpf_ino)</td></tr>
<tr><td>620</td><td>4</td><td></td><td>Unknown (s_prj_quota_inum)</td></tr>
<tr><td>624</td><td>4</td><td></td><td>Metadata checksum seed</td></tr>
<tr><td>628</td><td>1</td><td></td><td>Unknown (s_wtime_hi)</td></tr>
<tr><td>629</td><td>1</td><td></td><td>Unknown (s_mtime_hi)</td></tr>
<tr><td>630</td><td>1</td><td></td><td>Unknown (s_mkfs_time_hi)</td></tr>
<tr><td>631</td><td>1</td><td></td><td>Unknown (s_lastcheck_hi)</td></tr>
<tr><td>632</td><td>1</td><td></td><td>Unknown (s_first_error_time_hi)</td></tr>
<tr><td>633</td><td>1</td><td></td><td>Unknown (s_last_error_time_hi)</td></tr>
<tr><td>634</td><td>1</td><td></td><td>Unknown (s_first_error_errcode)</td></tr>
<tr><td>635</td><td>1</td><td></td><td>Unknown (s_last_error_errcode)</td></tr>
<tr><td>636</td><td>2</td><td></td><td>Unknown (s_encoding)</td></tr>
<tr><td>638</td><td>2</td><td></td><td>Unknown (s_encoding_flags)</td></tr>
<tr><td>640</td><td>4</td><td></td><td>Unknown (s_orphan_file_inum)</td></tr>
<tr><td>644</td><td>94 x 4 = 376</td><td></td><td>Unknown (reserved)</td></tr>
<tr><td>1020</td><td>4</td><td></td><td>Checksum</td></tr>
</table></div>
<p>If checksum type is CRC-32C, the checksum is stored as 0xffffffff - CRC-32C.</p>
<blockquote>
<p>Note that some versions of mkfs.ext set the file system creation time even for
ext2 and when EXT3_FEATURE_COMPAT_HAS_JOURNAL is not set.</p>
</blockquote>
<p>TODO: Is the only way to determine the file system version the compatibility and equivalent flags?</p>
<h3 id="checksum-calculation-2"><a class="header" href="#checksum-calculation-2">Checksum calculation</a></h3>
<p>If checksum type is CRC-32C, the CRC32-C algorithm with the Castagnoli
polynomial (0x1edc6f41) and initial value of 0 is used to calculate the
checksum.</p>
<p>The checksum is calculated over the 1020 bytes of data of the suberblock.</p>
<h3 id="metadata-checksum-seed-calculation"><a class="header" href="#metadata-checksum-seed-calculation">Metadata checksum seed calculation</a></h3>
<p>If checksum type is CRC-32C, the CRC32-C algorithm with the Castagnoli
polynomial (0x1edc6f41) and initial value of 0 is used to calculate the
checksum.</p>
<p>The checksum is calculated over:</p>
<ul>
<li>the 16 byte file system identifier in the superblock</li>
</ul>
<p>If EXT4_FEATURE_INCOMPAT_CSUM_SEED is set the metadata checksum seed value
stored in the superblock should be used instead of calculating it based on the
file system identifier.</p>
<p>If checksum type is CRC-32C, the metadata checksum seed is stored as
0xffffffff - CRC-32C.</p>
<h3 id="file-system-state-flags"><a class="header" href="#file-system-state-flags"><a name="file_system_state_flags"></a>File system state flags</a></h3>
<div class="table-wrapper"><table><thead><th>Value</th><th>Identifier</th><th>Description</th></thead><tr><td>0x0001</td><td></td><td>Is clean</td></tr>
<tr><td>0x0002</td><td></td><td>Has errors</td></tr>
<tr><td>0x0004</td><td></td><td>Recovering orphan inodes</td></tr>
</table></div>
<h3 id="error-handling-status"><a class="header" href="#error-handling-status"><a name="error_handling_status"></a>Error-handling status</a></h3>
<div class="table-wrapper"><table><thead><th>Value</th><th>Identifier</th><th>Description</th></thead><tr><td>1</td><td></td><td>Continue</td></tr>
<tr><td>2</td><td></td><td>Remount as read-only</td></tr>
<tr><td>3</td><td></td><td>Panic</td></tr>
</table></div>
<h3 id="creator-operating-system"><a class="header" href="#creator-operating-system"><a name="creator_operating_system"></a>Creator operating system</a></h3>
<div class="table-wrapper"><table><thead><th>Value</th><th>Identifier</th><th>Description</th></thead><tr><td>0</td><td></td><td>Linux</td></tr>
<tr><td>1</td><td></td><td>GNU Hurd</td></tr>
<tr><td>2</td><td></td><td>Masix</td></tr>
<tr><td>3</td><td></td><td>FreeBSD</td></tr>
<tr><td>4</td><td></td><td>Lites</td></tr>
</table></div>
<h3 id="format-revision"><a class="header" href="#format-revision"><a name="format_revisision"></a>Format revision</a></h3>
<div class="table-wrapper"><table><thead><th>Value</th><th>Identifier</th><th>Description</th></thead><tr><td>0</td><td>EXT2_GOOD_OLD_REV</td><td>Original version with a fixed inode size of 128 bytes</td></tr>
<tr><td>1</td><td>EXT2_DYNAMIC_REV</td><td>Version with dynamic inode size support</td></tr>
</table></div>
<h3 id="compatible-feature-flags-1"><a class="header" href="#compatible-feature-flags-1"><a name="compatible_feature_flags"></a>Compatible feature flags</a></h3>
<div class="table-wrapper"><table><thead><th>Value</th><th>Identifier</th><th>Description</th></thead><tr><td>0x00000001</td><td>EXT2_COMPAT_PREALLOC</td><td>Pre-allocate directory blocks, which is intended to reduce fragmentation.</td></tr>
<tr><td>0x00000002</td><td>EXT2_FEATURE_COMPAT_IMAGIC_INODES</td><td>Has AFS server inodes.</td></tr>
<tr><td>0x00000004</td><td>EXT3_FEATURE_COMPAT_HAS_JOURNAL</td><td>Has a journal.</td></tr>
<tr><td>0x00000008</td><td>EXT2_FEATURE_COMPAT_EXT_ATTR</td><td>Has extended attributes.</td></tr>
<tr><td>0x00000010</td><td>EXT2_FEATURE_COMPAT_RESIZE_INO, EXT2_FEATURE_COMPAT_RESIZE_INODE</td><td>Is resizeable, the file system has reserved GDT blocks for expansion, which also requires RO_COMPAT_SPARSE_SUPER</td></tr>
<tr><td>0x00000020</td><td>EXT2_FEATURE_COMPAT_DIR_INDEX</td><td>Has indexed directories</td></tr>
<tr><td>0x00000040</td><td>COMPAT_LAZY_BG</td><td>Unknown (Lazy block group)</td></tr>
<tr><td>0x00000080</td><td>COMPAT_EXCLUDE_INODE</td><td>Unknown (Exclude inode), which is not yet implemented and intended for a future file system snapshot feature</td></tr>
<tr><td>0x00000100</td><td>COMPAT_EXCLUDE_BITMAP</td><td>Unknown (Exclude bitmap), which is not yet implemented and intended for a future file system snapshot feature</td></tr>
<tr><td>0x00000200</td><td>EXT4_FEATURE_COMPAT_SPARSE_SUPER2</td><td>Has sparse superblock version 2</td></tr>
<tr><td>0x00000400</td><td>EXT4_FEATURE_COMPAT_FAST_COMMIT</td><td>Unknown (fast commit)</td></tr>
<tr><td>0x00000800</td><td>EXT4_FEATURE_COMPAT_STABLE_INODES</td><td>Unknown (stable inodes)</td></tr>
<tr><td>0x00001000</td><td>EXT4_FEATURE_COMPAT_ORPHAN_FILE</td><td>Has orphan file.</td></tr>
</table></div>
<blockquote>
<p>Note that EXT2_FEATURE_COMPAT_, EXT3_FEATURE_COMPAT_, EXT4_FEATURE_COMPAT_ and
COMPAT_ can be used interchangeably.</p>
</blockquote>
<h3 id="incompatible-feature-flags-1"><a class="header" href="#incompatible-feature-flags-1"><a name="incompatible_feature_flags"></a>Incompatible feature flags</a></h3>
<div class="table-wrapper"><table><thead><th>Value</th><th>Identifier</th><th>Description</th></thead><tr><td>0x00000001</td><td>EXT2_FEATURE_INCOMPAT_COMPRESSION</td><td>Has compression, which is not yet implemented</td></tr>
<tr><td>0x00000002</td><td>EXT2_FEATURE_INCOMPAT_FILETYPE</td><td>Directory entry has file type</td></tr>
<tr><td>0x00000004</td><td>EXT3_FEATURE_INCOMPAT_RECOVER</td><td>Needs recovery</td></tr>
<tr><td>0x00000008</td><td>EXT3_FEATURE_INCOMPAT_JOURNAL_DEV</td><td>Journal device</td></tr>
<tr><td>0x00000010</td><td>EXT2_FEATURE_INCOMPAT_META_BG</td><td>Has meta (or metadata) block groups</td></tr>
<tr><td></td><td></td><td></td></tr>
<tr><td>0x00000040</td><td>EXT4_FEATURE_INCOMPAT_EXTENTS</td><td>Has extents</td></tr>
<tr><td>0x00000080</td><td>EXT4_FEATURE_INCOMPAT_64BIT</td><td>Has 64-bit support, which supports more than 2^32 blocks</td></tr>
<tr><td>0x00000100</td><td>EXT4_FEATURE_INCOMPAT_MMP</td><td>Multiple mount protection</td></tr>
<tr><td>0x00000200</td><td>EXT4_FEATURE_INCOMPAT_FLEX_BG</td><td>Has flex (or flexible) block groups</td></tr>
<tr><td>0x00000400</td><td>EXT4_FEATURE_INCOMPAT_EA_INODE</td><td>Has large inodes, which are larger than 128 bytes.</td></tr>
<tr><td></td><td></td><td></td></tr>
<tr><td>0x00001000</td><td>EXT4_FEATURE_INCOMPAT_DIRDATA</td><td>Data in directory entry, which is not yet implemented</td></tr>
<tr><td>0x00002000</td><td>EXT4_FEATURE_INCOMPAT_CSUM_SEED, EXT4_FEATURE_INCOMPAT_BG_USE_META_CSUM</td><td>Initial metadata checksum value (or seed) is stored in the superblock</td></tr>
<tr><td>0x00004000</td><td>EXT4_FEATURE_INCOMPAT_LARGEDIR</td><td>Large directory &gt;2GB or 3-level hash tree (HTree).</td></tr>
<tr><td>0x00008000</td><td>EXT4_FEATURE_INCOMPAT_INLINE_DATA</td><td>Has data stored in inode.</td></tr>
<tr><td>0x00010000</td><td>EXT4_FEATURE_INCOMPAT_ENCRYPT</td><td>Has encrypted inodes.</td></tr>
<tr><td>0x00020000</td><td>EXT4_FEATURE_INCOMPAT_CASEFOLD</td><td>Hash case folding</td></tr>
</table></div>
<blockquote>
<p>Note that EXT2_FEATURE_INCOMPAT_, EXT3_FEATURE_INCOMPAT_,
EXT4_FEATURE_INCOMPAT_ and INCOMPAT_ can be used interchangeably.</p>
</blockquote>
<h3 id="read-only-compatible-feature-flags"><a class="header" href="#read-only-compatible-feature-flags"><a name="read_only_compatible_feature_flags"></a>Read-only compatible feature flags</a></h3>
<div class="table-wrapper"><table><thead><th>Value</th><th>Identifier</th><th>Description</th></thead><tr><td>0x00000001</td><td>EXT2_FEATURE_RO_COMPAT_SPARSE_SUPER</td><td>Has sparse superblocks and group descriptor tables. If set a superblock is stored in block groups 0, 1 and those that are powers of 3, 5 and 7. If not set a superblock is stored in every block group.</td></tr>
<tr><td>0x00000002</td><td>EXT2_FEATURE_RO_COMPAT_LARGE_FILE</td><td>Contains large files.</td></tr>
<tr><td>0x00000004</td><td>EXT2_FEATURE_RO_COMPAT_BTREE_DIR</td><td>Intended for hash-tree directory (or directory B-tree), which is not yet implemented</td></tr>
<tr><td>0x00000008</td><td>EXT4_FEATURE_RO_COMPAT_HUGE_FILE</td><td>Has huge file support.</td></tr>
<tr><td>0x00000010</td><td>EXT4_FEATURE_RO_COMPAT_GDT_CSUM</td><td>Has group descriptors with checksums.</td></tr>
<tr><td>0x00000020</td><td>EXT4_FEATURE_RO_COMPAT_DIR_NLINK</td><td>The ext3 32000 subdirectory limit does not apply. A directory's number of links will be set to 1 if it is incremented past 64999.</td></tr>
<tr><td>0x00000040</td><td>EXT4_FEATURE_RO_COMPAT_EXTRA_ISIZE</td><td>Has large inodes. The size of an inode can be larger than 128 bytes.</td></tr>
<tr><td>0x00000080</td><td>EXT4_FEATURE_RO_COMPAT_HAS_SNAPSHOT</td><td>Has snapshots, which is not yet implemented and intended for a future file system snapshot feature</td></tr>
<tr><td>0x00000100</td><td>EXT4_FEATURE_RO_COMPAT_QUOTA</td><td>Quota is handled transactionally with the journal.</td></tr>
<tr><td>0x00000200</td><td>EXT4_FEATURE_RO_COMPAT_BIGALLOC</td><td>Has big block allocation bitmaps. Block allocation bitmaps are tracked in units of clusters (of blocks) instead of blocks.</td></tr>
<tr><td>0x00000400</td><td>EXT4_FEATURE_RO_COMPAT_METADATA_CSUM</td><td>File system metadata has checksums.</td></tr>
<tr><td>0x00000800</td><td>EXT4_FEATURE_RO_COMPAT_REPLICA</td><td>Supports replicas.</td></tr>
<tr><td>0x00001000</td><td>EXT4_FEATURE_RO_COMPAT_READONLY</td><td>Read-only file system image.</td></tr>
<tr><td>0x00002000</td><td>EXT4_FEATURE_RO_COMPAT_PROJECT</td><td>File system tracks project quotas.</td></tr>
<tr><td>0x00004000</td><td>EXT4_FEATURE_RO_COMPAT_SHARED_BLOCKS</td><td>File system has (read-only) shared blocks.</td></tr>
<tr><td>0x00008000</td><td>EXT4_FEATURE_RO_COMPAT_VERITY</td><td>Unknown (Verity inodes may be present on the filesystem)</td></tr>
<tr><td>0x00010000</td><td>EXT4_FEATURE_RO_COMPAT_ORPHAN_PRESENT</td><td>Orphan file may be non-empty.</td></tr>
</table></div>
<blockquote>
<p>Note that EXT2_FEATURE_RO_COMPAT_, EXT3_FEATURE_RO_COMPAT_,
EXT4_FEATURE_RO_COMPAT_ and RO_COMPAT_ can be used interchangeably.</p>
</blockquote>
<blockquote>
<p>Note that in some ext file systems used by ChromeOS it has been observed that
the upper 8-bits of the read-only compatible feature flags are set as in
0xff000003. debugfs identifies these as FEATURE_R24 - FEATURE_R31.</p>
</blockquote>
<h3 id="checksum-types"><a class="header" href="#checksum-types"><a name="checksum_types"></a>Checksum types</a></h3>
<div class="table-wrapper"><table><thead><th>Value</th><th>Identifier</th><th>Description</th></thead><tr><td>1</td><td>EXT4_CRC32C_CHKSUM</td><td>CRC-32C (or CRC32-C), which uses the Castagnoli polynomial (0x1edc6f41)</td></tr>
</table></div>
<h2 id="the-group-descriptor-table"><a class="header" href="#the-group-descriptor-table">The group descriptor table</a></h2>
<p>The group descriptor table is stored in the block following the superblock.</p>
<p>The group descriptor table consist of:</p>
<ul>
<li>one or more group descriptors</li>
</ul>
<h3 id="the-ext2-and-ext3-group-descriptor"><a class="header" href="#the-ext2-and-ext3-group-descriptor">The ext2 and ext3 group descriptor</a></h3>
<p>The ext2 and ext3 group descriptor is 32 bytes in size and consists of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>4</td><td></td><td>Block bitmap block number. The block number is relative from the start of the volume</td></tr>
<tr><td>4</td><td>4</td><td></td><td>Inode bitmap block number. The block number is relative from the start of the volume</td></tr>
<tr><td>8</td><td>4</td><td></td><td>Inode table block number. The block number is relative from the start of the volume</td></tr>
<tr><td>12</td><td>2</td><td></td><td>Number of unallocated blocks</td></tr>
<tr><td>14</td><td>2</td><td></td><td>Number of unallocated inodes</td></tr>
<tr><td>16</td><td>2</td><td></td><td>Number of directories</td></tr>
<tr><td>18</td><td>2</td><td></td><td>Unknown (padding)</td></tr>
<tr><td>20</td><td>3 x 4</td><td></td><td>Unknown (reserved)</td></tr>
</table></div>
<blockquote>
<p>Note that it has been observed that implementations that support ext4 can set
a value in the padding. It is currently assumed that this value contains
<a href="ext.html#block_group_flags">block group flags</a>.</p>
</blockquote>
<h3 id="the-ext4-group-descriptor"><a class="header" href="#the-ext4-group-descriptor">The ext4 group descriptor</a></h3>
<p>The ext4 group descriptor is 68 bytes in size and consists of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>4</td><td></td><td>Block bitmap block number, which contains the lower 32-bit of the value. The block number is relative from the start of the volume</td></tr>
<tr><td>4</td><td>4</td><td></td><td>Inode bitmap block number, which contains the lower 32-bit of the value. The block number is relative from the start of the volume</td></tr>
<tr><td>8</td><td>4</td><td></td><td>Inode table block number, which contains the lower 32-bit of the value. The block number is relative from the start of the volume</td></tr>
<tr><td>12</td><td>2</td><td></td><td>Number of unallocated blocks, which contains the lower 16-bit of the value</td></tr>
<tr><td>14</td><td>2</td><td></td><td>Number of unallocated inodes, which contains the lower 16-bit of the value</td></tr>
<tr><td>16</td><td>2</td><td></td><td>Number of directories, which contains the lower 16-bit of the value</td></tr>
<tr><td>18</td><td>2</td><td></td><td><a href="ext.html#block_group_flags">Block group flags</a></td></tr>
<tr><td>20</td><td>4</td><td></td><td>Exclude bitmap block number, which contains the lower 32-bit of the value. The block number is relative from the start of the volume</td></tr>
<tr><td>24</td><td>2</td><td></td><td>Block bitmap checksum, which contains the lower 16-bit of the value</td></tr>
<tr><td>26</td><td>2</td><td></td><td>Inode bitmap checksum, which contains the lower 16-bit of the value</td></tr>
<tr><td>28</td><td>2</td><td></td><td>Number of unused inodes, which contains the lower 16-bit of the value</td></tr>
<tr><td>30</td><td>2</td><td></td><td>Checksum</td></tr>
<tr><td colspan="4"> <em>If 64-bit support (EXT4_FEATURE_INCOMPAT_64BIT) is enabled and group descriptor size &gt; 32</em></tr>
<tr><td>32</td><td>4</td><td></td><td>Block bitmap block number, which contains the upper 32-bit of the value. The block number is relative from the start of the volume</td></tr>
<tr><td>36</td><td>4</td><td></td><td>Inode bitmap block number, which contains the upper 32-bit of the value. The block number is relative from the start of the volume</td></tr>
<tr><td>40</td><td>4</td><td></td><td>Inode table block number, which contains the upper 32-bit of the value. The block number is relative from the start of the volume</td></tr>
<tr><td>44</td><td>2</td><td></td><td>Number of unallocated blocks, which contains the upper 16-bit of the value</td></tr>
<tr><td>46</td><td>2</td><td></td><td>Number of unallocated inodes, which contains the upper 16-bit of the value</td></tr>
<tr><td>48</td><td>2</td><td></td><td>Number of directories, which contains the upper 16-bit of the value</td></tr>
<tr><td>50</td><td>2</td><td></td><td>Number of unused inodes, which contains the upper 16-bit of the value</td></tr>
<tr><td>52</td><td>4</td><td></td><td>Exclude bitmap block number, which contains the upper 32-bit of the value. The block number is relative from the start of the volume</td></tr>
<tr><td>56</td><td>2</td><td></td><td>Block bitmap checksum, which contains the upper 16-bit of the value</td></tr>
<tr><td>60</td><td>2</td><td></td><td>Inode bitmap checksum, which contains the upper 16-bit of the value</td></tr>
<tr><td>64</td><td>4</td><td></td><td>Unknown (padding)</td></tr>
</table></div>
<p>If checksum type is CRC-32C, the checksum is stored as the lower 16-bits of
0xffffffff - CRC-32C, otherwise the checksum is stored as a CRC-16.</p>
<h3 id="checksum-calculation-3"><a class="header" href="#checksum-calculation-3">Checksum calculation</a></h3>
<p>If checksum type is CRC-32C, the CRC32-C algorithm with the Castagnoli
polynomial (0x1edc6f41) and initial value of 0 is used to calculate the
checksum.</p>
<p>The checksum is calculated over:</p>
<ul>
<li>the 16 byte file system identifier in the superblock</li>
<li>the group number as a 32-bit little-endian integer</li>
<li>the data of the group descriptor with the checksum set to 0-byte values</li>
</ul>
<p>TODO: describe the block bitmap checksum calculation: crc32c(s_uuid+grp_num+bbitmap)</p>
<p>TODO: describe the inode bitmap checksum calculation: crc32c(s_uuid+grp_num+ibitmap)</p>
<h3 id="block-group-flags"><a class="header" href="#block-group-flags"><a name="block_group_flags"></a>Block group flags</a></h3>
<div class="table-wrapper"><table><thead><th>Value</th><th>Identifier</th><th>Description</th></thead><tr><td>0x0001</td><td>EXT4_BG_INODE_UNINIT</td><td>The inode table and bitmap are not initialized</td></tr>
<tr><td>0x0002</td><td>EXT4_BG_BLOCK_UNINIT</td><td>The block bitmap is not initialized</td></tr>
<tr><td>0x0004</td><td>EXT4_BG_INODE_ZEROED</td><td>The inode table is filled with 0</td></tr>
</table></div>
<h2 id="direct-and-indirect-blocks"><a class="header" href="#direct-and-indirect-blocks">Direct and indirect blocks</a></h2>
<p>Direct blocks are blocks that part of the data stream of a file entry.</p>
<p>A direct block number is 0 that is part of the data stream represents a sparse
data block.</p>
<p>Indirect blocks are blocks that refer to blocks containing direct or indirect
block numbers. There are multiple levels of indirect block:</p>
<ul>
<li>indirect blocks (level 1), that refer to direct blocks</li>
<li>double indirect blocks (level 2), that refer to indirect blocks</li>
<li>triple indirect blocks (level 3), that refer to double indirect blocks</li>
</ul>
<p>An indirect block number is 0 that is part of the data stream represents sparse
data blocks.</p>
<h2 id="extents"><a class="header" href="#extents">Extents</a></h2>
<p>Extents were introduced in ext4 and are controlled by
EXT4_FEATURE_INCOMPAT_EXTENTS.</p>
<p>Extents form an extent B-Tree, where:</p>
<ul>
<li><a href="ext.html#ext4_extent_index">extent indexes</a> are stored in the branch nodes and</li>
<li><a href="ext.html#ext4_extent_descriptor">extent descriptors</a> are stored in the leaf nodes.</li>
</ul>
<p>An extents B-tree node consists of:</p>
<ul>
<li>extents header</li>
<li>extents entries</li>
<li>extents footer</li>
</ul>
<blockquote>
<p>Note that inodes can have an implicit last sparse extent if the the inode
data size is greater than the total data size defined by the extent
descriptors.</p>
</blockquote>
<h3 id="the-ext4-extents-header"><a class="header" href="#the-ext4-extents-header"><a name="ext4_extents_header"></a>The ext4 extents header</a></h3>
<p>The ext4 extents header (ext4_extent_header) is 12 bytes in size and consists of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>2</td><td>"\x0a\xf3"</td><td>Signature</td></tr>
<tr><td>2</td><td>2</td><td></td><td>Number of entries</td></tr>
<tr><td>4</td><td>2</td><td></td><td>Maximum number of entries</td></tr>
<tr><td>6</td><td>2</td><td></td><td>Depth, where 0 reprensents a leaf node and 1 to 5 different levels of branch nodes.</td></tr>
<tr><td>8</td><td>4</td><td></td><td>Generation, which is used by Lustre, but not by standard ext4.</td></tr>
</table></div>
<h3 id="the-ext4-extent-descriptor"><a class="header" href="#the-ext4-extent-descriptor"><a name="ext4_extent_descriptor"></a>The ext4 extent descriptor</a></h3>
<p>The ext4 extent descriptor (ext4_extent) is 12 bytes in size and consists of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>4</td><td></td><td>Logical block number</td></tr>
<tr><td>4</td><td>2</td><td></td><td>Number of blocks</td></tr>
<tr><td>6</td><td>2</td><td></td><td>Upper 16-bits of physical block number</td></tr>
<tr><td>8</td><td>4</td><td></td><td>Lower 32-bits of physical block number</td></tr>
</table></div>
<p>If number of blocks &gt; 32768 the extent is considered "uninitialized" which is
(as far as currently known) comparable to extent being sparse. The number of
blocks of the sparse extent can be determined as following:</p>
<pre><code>sparse_number_of_blocks = number_of_blocks - 32768
</code></pre>
<blockquote>
<p>Note that sparse extents can exist between the extent descriptors. In such a
case the logical block number will not align with the information from the
previous extent descriptors.</p>
</blockquote>
<blockquote>
<p>Note that the native Linux ext implementation expects the extents to be stored
in order of logical block number.</p>
</blockquote>
<h3 id="the-ext4-extents-index"><a class="header" href="#the-ext4-extents-index"><a name="ext4_extent_index"></a>The ext4 extents index</a></h3>
<p>The ext4 extent index (ext4_extent_idx) is 12 bytes in size and consists of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>4</td><td></td><td>Logical block number, which contains the first logical block number of next depth extents block</td></tr>
<tr><td>4</td><td>4</td><td></td><td>Lower 32-bits of physical block number, which contains the block number of the next depth extents block</td></tr>
<tr><td>8</td><td>2</td><td></td><td>Upper 16-bits of physical block number, which contains the block number of the next depth extents block</td></tr>
<tr><td>10</td><td>2</td><td></td><td>Unknown (unused)</td></tr>
</table></div>
<h3 id="the-ext4-extents-footer"><a class="header" href="#the-ext4-extents-footer">The ext4 extents footer</a></h3>
<p>The ext4 extents footer (ext4_extent_tail) is 4 bytes in size and consists of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>4</td><td></td><td>Checksum of an extents block, which contains a CRC32</td></tr>
</table></div>
<h2 id="the-inode"><a class="header" href="#the-inode">The inode</a></h2>
<blockquote>
<p>Note that the size of the inode is defined in the superblock when dynamic
inode information is present.</p>
</blockquote>
<blockquote>
<p>Note that an ext4 inode can be used on ext2 formatted file system. Seen in
combination with format revision 1 and inode size &gt; 128 created by mkfs.ext2.</p>
</blockquote>
<h3 id="the-ext2-inode"><a class="header" href="#the-ext2-inode">The ext2 inode</a></h3>
<p>The ext2 inode is 128 bytes in size and consists of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>2</td><td></td><td><a href="ext.html#file_mode">File mode</a>, which contains file type and permissions</td></tr>
<tr><td>2</td><td>2</td><td></td><td>Lower 16-bits of owner (or user) identifier (UID)</td></tr>
<tr><td>4</td><td>4</td><td></td><td>Data size</td></tr>
<tr><td>8</td><td>4</td><td></td><td>(last) access time, which contains the number of seconds since January 1, 1970 00:00:00 UTC (POSIX epoch)</td></tr>
<tr><td>12</td><td>4</td><td></td><td>(last) inode change time, which contains the number of seconds since January 1, 1970 00:00:00 UTC (POSIX epoch)</td></tr>
<tr><td>16</td><td>4</td><td></td><td>(last) modification time, which contains the number of seconds since January 1, 1970 00:00:00 UTC (POSIX epoch)</td></tr>
<tr><td>20</td><td>4</td><td></td><td>Deletion time, which contains the number of seconds since January 1, 1970 00:00:00 UTC (POSIX epoch)</td></tr>
<tr><td>24</td><td>2</td><td></td><td>Lower 16-bits of group identifier (GID)</td></tr>
<tr><td>26</td><td>2</td><td></td><td>Number of (hard) links</td></tr>
<tr><td>28</td><td>4</td><td></td><td>Numer of blocks</td></tr>
<tr><td>32</td><td>4</td><td></td><td><a href="ext.html#inode_flags">Flags</a></td></tr>
<tr><td>36</td><td>4</td><td></td><td>Unknown (reserved)</td></tr>
<tr><td>40</td><td>12 x 4</td><td></td><td>Array of direct block numbers. A block number is relative from the start of the volume</td></tr>
<tr><td>88</td><td>4</td><td></td><td>Indirect block number. A block number is relative from the start of the volume</td></tr>
<tr><td>92</td><td>4</td><td></td><td>Double indirect block number. A block number is relative from the start of the volume</td></tr>
<tr><td>96</td><td>4</td><td></td><td>Triple indirect block number. A block number is relative from the start of the volume</td></tr>
<tr><td>100</td><td>4</td><td></td><td>NFS generation number</td></tr>
<tr><td>104</td><td>4</td><td></td><td>File ACL (or extended attributes) block number</td></tr>
<tr><td>108</td><td>4</td><td></td><td>Unknown (Directory ACL)</td></tr>
<tr><td>112</td><td>4</td><td></td><td>Fragment block address</td></tr>
<tr><td>116</td><td>1</td><td></td><td>Fragment block index</td></tr>
<tr><td>117</td><td>1</td><td></td><td>Fragment size</td></tr>
<tr><td>118</td><td>2</td><td></td><td>Unknown (padding)</td></tr>
<tr><td>120</td><td>2</td><td></td><td>Upper 16-bits of owner (or user) identifier (UID)</td></tr>
<tr><td>122</td><td>2</td><td></td><td>Upper 16-bits of group identifier (GID)</td></tr>
<tr><td>124</td><td>4</td><td></td><td>Unknown (reserved)</td></tr>
</table></div>
<blockquote>
<p>Note that for a character and block device the first 2 bytes of the array of
direct block numbers contain the minor and major device number respectively.</p>
</blockquote>
<blockquote>
<p>Note that if the inode size is larger than 128 bytes, the additional data can
be stored using an ext4 inode extension.</p>
</blockquote>
<h3 id="the-ext3-inode"><a class="header" href="#the-ext3-inode">The ext3 inode</a></h3>
<p>The ext3 inode is 132 bytes in size and consists of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>2</td><td></td><td><a href="ext.html#file_mode">File mode</a>, which contains file type and permissions</td></tr>
<tr><td>2</td><td>2</td><td></td><td>Lower 16-bits of owner (or user) identifier (UID)</td></tr>
<tr><td>4</td><td>4</td><td></td><td>Data size</td></tr>
<tr><td>8</td><td>4</td><td></td><td>(last) access time, which contains the number of seconds since January 1, 1970 00:00:00 UTC (POSIX epoch)</td></tr>
<tr><td>12</td><td>4</td><td></td><td>(last) inode change time, which contains the number of seconds since January 1, 1970 00:00:00 UTC (POSIX epoch)</td></tr>
<tr><td>16</td><td>4</td><td></td><td>(last) modification time, which contains the number of seconds since January 1, 1970 00:00:00 UTC (POSIX epoch)</td></tr>
<tr><td>20</td><td>4</td><td></td><td>Deletion time, which contains the number of seconds since January 1, 1970 00:00:00 UTC (POSIX epoch)</td></tr>
<tr><td>24</td><td>2</td><td></td><td>Lower 16-bits of group identifier (GID)</td></tr>
<tr><td>26</td><td>2</td><td></td><td>Number of (hard) links</td></tr>
<tr><td>28</td><td>4</td><td></td><td>Numer of blocks</td></tr>
<tr><td>32</td><td>4</td><td></td><td><a href="ext.html#inode_flags">Flags</a></td></tr>
<tr><td>36</td><td>4</td><td></td><td>Unknown (reserved)</td></tr>
<tr><td>40</td><td>12 x 4</td><td></td><td>Array of direct block numbers. A block number is relative from the start of the volume</td></tr>
<tr><td>88</td><td>4</td><td></td><td>Indirect block number. A block number is relative from the start of the volume</td></tr>
<tr><td>92</td><td>4</td><td></td><td>Double indirect block number. A block number is relative from the start of the volume</td></tr>
<tr><td>96</td><td>4</td><td></td><td>Triple indirect block number. A block number is relative from the start of the volume</td></tr>
<tr><td>100</td><td>4</td><td></td><td>NFS generation number</td></tr>
<tr><td>104</td><td>4</td><td></td><td>File ACL (or extended attributes) block number</td></tr>
<tr><td>108</td><td>4</td><td></td><td>Unknown (Directory ACL)</td></tr>
<tr><td>112</td><td>4</td><td></td><td>Fragment block address</td></tr>
<tr><td>116</td><td>1</td><td></td><td>Fragment block index</td></tr>
<tr><td>117</td><td>1</td><td></td><td>Fragment size</td></tr>
<tr><td>118</td><td>2</td><td></td><td>Unknown (padding)</td></tr>
<tr><td>120</td><td>2</td><td></td><td>Upper 16-bits of owner (or user) identifier (UID)</td></tr>
<tr><td>122</td><td>2</td><td></td><td>Upper 16-bits of group identifier (GID)</td></tr>
<tr><td>124</td><td>4</td><td></td><td>Unknown (reserved)</td></tr>
<tr><td colspan="4"> <em>Extension (if inode size &gt; 128)</em></tr>
<tr><td>128</td><td>2</td><td></td><td>Extended inode size</td></tr>
<tr><td>130</td><td>2</td><td></td><td>Unknown (padding)</td></tr>
</table></div>
<blockquote>
<p>Note that for a character and block device the first 2 bytes of the array of
direct block numbers contain the minor and major device number respectively.</p>
</blockquote>
<blockquote>
<p>Note that if the inode size is larger than 128 bytes, the additional data can
be stored using an ext4 inode extension.</p>
</blockquote>
<h3 id="the-ext4-inode"><a class="header" href="#the-ext4-inode">The ext4 inode</a></h3>
<p>The ext4 inode is 160 bytes in size and consists of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>2</td><td></td><td><a href="ext.html#file_mode">File mode</a>, which contains file type and permissions</td></tr>
<tr><td>2</td><td>2</td><td></td><td>Lower 16-bits of owner (or user) identifier (UID)</td></tr>
<tr><td>4</td><td>4</td><td></td><td>Lower 32-bits of data size</td></tr>
<tr><td colspan="4"> <em>If EXT4_EA_INODE_FL is not set</em></tr>
<tr><td>8</td><td>4</td><td></td><td>(last) access time, which contains the number of seconds since January 1, 1970 00:00:00 UTC (POSIX epoch)</td></tr>
<tr><td>12</td><td>4</td><td></td><td>(last) inode change time, which contains the number of seconds since January 1, 1970 00:00:00 UTC (POSIX epoch)</td></tr>
<tr><td>16</td><td>4</td><td></td><td>(last) modification time, which contains the number of seconds since January 1, 1970 00:00:00 UTC (POSIX epoch)</td></tr>
<tr><td colspan="4"> <em>If EXT4_EA_INODE_FL is set</em></tr>
<tr><td>8</td><td>4</td><td></td><td>Unknown (extended attribute value data checksum)</td></tr>
<tr><td>12</td><td>4</td><td></td><td>Unknown (lower 32-bits of extended attribute reference count)</td></tr>
<tr><td>16</td><td>4</td><td></td><td>Unknown (inode number that owns the extended attribute)</td></tr>
<tr><td colspan="4"> <em>Common</em></tr>
<tr><td>20</td><td>4</td><td></td><td>Deletion time, which contains the number of seconds since January 1, 1970 00:00:00 UTC (POSIX epoch)</td></tr>
<tr><td>24</td><td>2</td><td></td><td>Lower 16-bits of group identifier (GID)</td></tr>
<tr><td>26</td><td>2</td><td></td><td>Number of (hard) links</td></tr>
<tr><td>28</td><td>4</td><td></td><td>Lower 32-bits of number of blocks</td></tr>
<tr><td>32</td><td>4</td><td></td><td><a href="ext.html#inode_flags">Flags</a></td></tr>
<tr><td colspan="4"> <em>If EXT4_EA_INODE_FL is not set</em></tr>
<tr><td>36</td><td>4</td><td></td><td>Lower 32-bits of version</td></tr>
<tr><td colspan="4"> <em>If EXT4_EA_INODE_FL is set</em></tr>
<tr><td>36</td><td>4</td><td></td><td>Unknown (upper 32-bits of extended attribute reference count)</td></tr>
<tr><td colspan="4"> <em>If EXT4_EXTENTS_FL and EXT4_INLINE_DATA_FL are not set</em></tr>
<tr><td>40</td><td>12 x 4</td><td></td><td>Array of direct block numbers. A block number is relative from the start of the volume</td></tr>
<tr><td>88</td><td>4</td><td></td><td>Indirect block number. A block number is relative from the start of the volume</td></tr>
<tr><td>92</td><td>4</td><td></td><td>Double indirect block number. A block number is relative from the start of the volume</td></tr>
<tr><td>96</td><td>4</td><td></td><td>Triple indirect block number. A block number is relative from the start of the volume</td></tr>
<tr><td colspan="4"> <em>If EXT4_EXTENTS_FL is set</em></tr>
<tr><td>40</td><td>12</td><td></td><td><a href="ext.html#xt4_extents_header">Extents header</a></td></tr>
<tr><td>52</td><td>4 x 12</td><td></td><td><a href="ext.html#ext4_extent_descriptor">extent descriptors</a> or <a href="ext.html#ext4_extent_index">extents indexes</a></td></tr>
<tr><td colspan="4"> <em>If EXT4_INLINE_DATA_FL is set</em></tr>
<tr><td>40</td><td>60</td><td></td><td>File content data</td></tr>
<tr><td colspan="4"> <em>Common</em></tr>
<tr><td>100</td><td>4</td><td></td><td>NFS generation number</td></tr>
<tr><td>104</td><td>4</td><td></td><td>Lower 32-bits of file ACL (or extended attributes) block number</td></tr>
<tr><td>108</td><td>4</td><td></td><td>Upper 32-bits of data size</td></tr>
<tr><td>112</td><td>4</td><td></td><td>Fragment block address</td></tr>
<tr><td>116</td><td>2</td><td></td><td>Upper 16-bits of number of blocks</td></tr>
<tr><td>118</td><td>2</td><td></td><td>Upper 16-bits of file ACL (or extended attributes) block number</td></tr>
<tr><td>120</td><td>2</td><td></td><td>Upper 16-bits of owner (or user) identifier (UID)</td></tr>
<tr><td>122</td><td>2</td><td></td><td>Upper 16-bits of group identifier (GID)</td></tr>
<tr><td>124</td><td>2</td><td></td><td>Lower 16-bits of checksum</td></tr>
<tr><td>126</td><td>2</td><td></td><td>Unknown (reserved)</td></tr>
<tr><td colspan="4"> <em>Extension (if inode size &gt; 128)</em></tr>
<tr><td>128</td><td>2</td><td></td><td>Extended inode size</td></tr>
<tr><td>130</td><td>2</td><td></td><td>Upper 16-bits of checksum</td></tr>
<tr><td>132</td><td>4</td><td></td><td>(last) inode change time extra precision</td></tr>
<tr><td>136</td><td>4</td><td></td><td>(last) modification time extra precision</td></tr>
<tr><td>140</td><td>4</td><td></td><td>(last) access time extra precision</td></tr>
<tr><td>144</td><td>4</td><td></td><td>Creation time</td></tr>
<tr><td>148</td><td>4</td><td></td><td>Creation time extra precision</td></tr>
<tr><td>152</td><td>4</td><td></td><td>Upper 32-bits of version</td></tr>
<tr><td>156</td><td>4</td><td></td><td>Unknown (i_projid)</td></tr>
</table></div>
<p>If checksum type is CRC-32C, the checksum is stored as 0xffffffff - CRC-32C.</p>
<blockquote>
<p>Note that for a character and block device the first 2 bytes of the array of
direct block numbers contain the minor and major device number respectively.</p>
</blockquote>
<blockquote>
<p>Note that extended inode size can vary, seen 4, 28 and 32.</p>
</blockquote>
<h4 id="checksum-calculation-4"><a class="header" href="#checksum-calculation-4">Checksum calculation</a></h4>
<p>If checksum type is CRC-32C, the CRC32-C algorithm with the Castagnoli
polynomial (0x1edc6f41) and initial value of 0 is used to calculate the
checksum.</p>
<p>The checksum is calculated from:</p>
<ul>
<li>the 16 byte file system identifier in the superblock</li>
<li>the inode number as a 32-bit little-endian integer</li>
<li>the NFS generation number in the inode as a 32-bit little-endian integer</li>
<li>the data of the inode with the lower and upper part of the checksum set to 0-byte values.</li>
</ul>
<h4 id="extra-precision"><a class="header" href="#extra-precision">Extra precision</a></h4>
<p>The ext4 extra precision is 4 bytes in size and consists of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0.0</td><td>2 bits</td><td></td><td>Extra epoch value</td></tr>
<tr><td>0.2</td><td>30 bits</td><td></td><td>Fraction of second in nanoseconds</td></tr>
</table></div>
<p>The 34 bits extra precision timestamp (in number of seconds) can be calculated as
following:</p>
<pre><code>extra_precision_timestamp = ( extra_epoch_value x 0x100000000 ) + timestamp
</code></pre>
<h4 id="notes-4"><a class="header" href="#notes-4">Notes</a></h4>
<p>It has been observed that when EXT4_EA_INODE_FL is set the (last) modification
time can contain a valid timestamp.</p>
<p>According to <a href="https://docs.kernel.org/filesystems/ext4/overview.html#large-extended-attribute-values">The Linux Kernel documentation</a></p>
<blockquote>
<p>For backward compatibility with older versions of this feature, the
i_mtime/i_generation may store a back-reference to the inode number and
i_generation of the one owning inode (in cases where the EA inode is not
referenced by multiple inodes) to verify that the EA inode is the correct
one being accessed.</p>
</blockquote>
<h3 id="file-mode"><a class="header" href="#file-mode"><a name="file_mode"></a>File mode</a></h3>
<div class="table-wrapper"><table><thead><th>Value</th><th>Identifier</th><th>Description</th></thead><tr><td colspan="3"> <em>Access other, Bitmask: 0x0007 (S_IRWXO)</em></tr>
<tr><td>0x0001</td><td>S_IXOTH</td><td>X-access for other</td></tr>
<tr><td>0x0002</td><td>S_IWOTH</td><td>W-access for other</td></tr>
<tr><td>0x0004</td><td>S_IROTH</td><td>R-access for other</td></tr>
<tr><td colspan="3"> <em>Access group, Bitmask: 0x0038 (S_IRWXG)</em></tr>
<tr><td>0x0008</td><td>S_IXGRP</td><td>X-access for group</td></tr>
<tr><td>0x0010</td><td>S_IWGRP</td><td>W-access for group</td></tr>
<tr><td>0x0020</td><td>S_IRGRP</td><td>R-access for group</td></tr>
<tr><td colspan="3"> <em>Access owner (or user), Bitmask: 0x01c0 (S_IRWXU)</em></tr>
<tr><td>0x0040</td><td>S_IXUSR</td><td>X-access for owner (or user)</td></tr>
<tr><td>0x0080</td><td>S_IWUSR</td><td>W-access for owner (or user)</td></tr>
<tr><td>0x0100</td><td>S_IRUSR</td><td>R-access for owner (or user)</td></tr>
<tr><td colspan="3"> <em>Other</em></tr>
<tr><td>0x0200</td><td>S_ISTXT</td><td>Sticky bit</td></tr>
<tr><td>0x0400</td><td>S_ISGID</td><td>Set group identifer (GID) on execution</td></tr>
<tr><td>0x0800</td><td>S_ISUID</td><td>Set owner (or user) identifer (UID) on execution</td></tr>
<tr><td colspan="3"> <em>Type of file, Bitmask: 0xf000 (S_IFMT)</em></tr>
<tr><td>0x1000</td><td>S_IFIFO</td><td>Named pipe (FIFO)</td></tr>
<tr><td>0x2000</td><td>S_IFCHR</td><td>Character device</td></tr>
<tr><td>0x4000</td><td>S_IFDIR</td><td>Directory</td></tr>
<tr><td>0x6000</td><td>S_IFBLK</td><td>Block device</td></tr>
<tr><td>0x8000</td><td>S_IFREG</td><td>Regular file</td></tr>
<tr><td>0xa000</td><td>S_IFLNK</td><td>Symbolic link</td></tr>
<tr><td>0xc000</td><td>S_IFSOCK</td><td>Socket</td></tr>
</table></div>
<h3 id="inode-flags"><a class="header" href="#inode-flags"><a name="inode_flags"></a>Inode flags</a></h3>
<div class="table-wrapper"><table><thead><th>Value</th><th>Identifier</th><th>Description</th></thead><tr><td>0x00000001</td><td>EXT2_SECRM_FL, EXT3_SECRM_FL, EXT4_SECRM_FL, EXT4_INODE_SECRM</td><td>Secure deletion</td></tr>
<tr><td>0x00000002</td><td>EXT2_UNRM_FL, EXT3_UNRM_FL, EXT4_UNRM_FL, EXT4_INODE_UNRM</td><td>Undelete</td></tr>
<tr><td>0x00000004</td><td>EXT2_COMPR_FL, EXT3_COMPR_FL, EXT4_COMPR_FL, EXT4_INODE_COMPR</td><td>Compressed file, which is not yet implemented</td></tr>
<tr><td>0x00000008</td><td>EXT2_SYNC_FL, EXT3_SYNC_FL, EXT4_SYNC_FL, EXT4_INODE_SYNC</td><td>Synchronous updates</td></tr>
<tr><td>0x00000010</td><td>EXT2_IMMUTABLE_FL, EXT3_IMMUTABLE_FL, EXT4_IMMUTABLE_FL, EXT4_INODE_IMMUTABLE</td><td>Immutable file</td></tr>
<tr><td>0x00000020</td><td>EXT2_APPEND_FL, EXT3_APPEND_FL, EXT4_APPEND_FL, EXT4_INODE_APPEND</td><td>Writes to file may only append</td></tr>
<tr><td>0x00000040</td><td>EXT2_NODUMP_FL, EXT3_NODUMP_FL, EXT4_NODUMP_FL, EXT4_INODE_NODUMP</td><td>Do not remove (or dump) file</td></tr>
<tr><td>0x00000080</td><td>EXT2_NOATIME_FL, EXT3_NOATIME_FL, EXT4_NOATIME_FL, EXT4_INODE_NOATIME</td><td>Do not update access time (atime)</td></tr>
<tr><td>0x00000100</td><td>EXT2_DIRTY_FL, EXT3_DIRTY_FL, EXT4_DIRTY_FL, EXT4_INODE_DIRTY</td><td>Dirty compressed file, which is not yet implemented</td></tr>
<tr><td>0x00000200</td><td>EXT2_COMPRBLK_FL, EXT3_COMPRBLK_FL, EXT4_COMPRBLK_FL, EXT4_INODE_COMPRBLK</td><td>One or more compressed clusters, which is not yet implemented</td></tr>
<tr><td>0x00000400</td><td>EXT2_NOCOMP_FL, EXT3_NOCOMP_FL, EXT4_NOCOMPR_FL, EXT4_INODE_NOCOMPR</td><td>Do not compress, which is not yet implemented</td></tr>
<tr><td colspan="3"> <em>ext2 and ext3</em></tr>
<tr><td>0x00000800</td><td>EXT2_ECOMPR_FL, EXT3_ECOMPR_FL</td><td>Encrypted Compression error</td></tr>
<tr><td colspan="3"> <em>ext4</em></tr>
<tr><td>0x00000800</td><td>EXT4_ENCRYPT_FL, EXT4_INODE_ENCRYPT</td><td>Encrypted file</td></tr>
<tr><td colspan="3"> <em>Common</em></tr>
<tr><td>0x00001000</td><td>EXT2_BTREE_FL, EXT2_INDEX_FL, EXT3_INDEX_FL, EXT4_INDEX_FL, EXT4_INODE_INDEX</td><td>Hash-indexed directory (previously referred to as B-tree format).</td></tr>
<tr><td>0x00002000</td><td>EXT2_IMAGIC_FL, EXT3_IMAGIC_FL, EXT4_IMAGIC_FL, EXT4_INODE_IMAGIC</td><td>AFS directory</td></tr>
<tr><td>0x00004000</td><td>EXT2_JOURNAL_DATA_FL, EXT3_JOURNAL_DATA_FL, EXT4_JOURNAL_DATA_FL, EXT4_INODE_JOURNAL_DATA</td><td>File data must be written using the journal.</td></tr>
<tr><td>0x00008000</td><td>EXT2_NOTAIL_FL, EXT3_NOTAIL_FL, EXT4_NOTAIL_FL, EXT4_INODE_NOTAIL</td><td>File tail should not be merged, which is not used by ext4</td></tr>
<tr><td>0x00010000</td><td>EXT2_DIRSYNC_FL, EXT3_DIRSYNC_FL, EXT4_DIRSYNC_FL, EXT4_INODE_DIRSYNC</td><td>Directory entries should be written synchronously (dirsync)</td></tr>
<tr><td>0x00020000</td><td>EXT2_TOPDIR_FL, EXT3_TOPDIR_FL, EXT4_TOPDIR_FL, EXT4_INODE_TOPDIR</td><td>Top of directory hierarchy</td></tr>
<tr><td colspan="3"> <em>ext4</em></tr>
<tr><td>0x00040000</td><td>EXT4_HUGE_FILE_FL, EXT4_INODE_HUGE_FILE</td><td>Is a <a href="ext.html#huge_files">huge file</a></td></tr>
<tr><td>0x00080000</td><td>EXT4_EXTENTS_FL, EXT4_INODE_EXTENTS</td><td>Inode uses extents</td></tr>
<tr><td>0x00100000</td><td>EXT4_INODE_VERITY</td><td>Verity protected inode</td></tr>
<tr><td>0x00200000</td><td>EXT4_EA_INODE_FL, EXT4_INODE_EA_INODE</td><td>Inode used for large extended attribute</td></tr>
<tr><td>0x00400000</td><td>EXT4_EOFBLOCKS_FL, EXT4_INODE_EOFBLOCKS</td><td>Blocks allocated beyond EOF</td></tr>
<tr><td></td><td></td><td></td></tr>
<tr><td>0x01000000</td><td>EXT4_SNAPFILE_FL</td><td>Inode is a snapshot</td></tr>
<tr><td>0x02000000</td><td>EXT4_INODE_DAX</td><td>Inode is direct-access (DAX)</td></tr>
<tr><td>0x04000000</td><td>EXT4_SNAPFILE_DELETED_FL</td><td>Snapshot is being deleted</td></tr>
<tr><td>0x08000000</td><td>EXT4_SNAPFILE_SHRUNK_FL</td><td>Snapshot shrink has completed</td></tr>
<tr><td>0x10000000</td><td>EXT4_INLINE_DATA_FL, EXT4_INODE_INLINE_DATA</td><td>Inode has inline data</td></tr>
<tr><td>0x20000000</td><td>EXT4_PROJINHERIT_FL, EXT4_INODE_PROJINHERIT</td><td>Create sub file entries with the same project identifier</td></tr>
<tr><td>0x40000000</td><td>EXT4_INODE_CASEFOLD</td><td>Casefolded directory</td></tr>
<tr><td>0x80000000</td><td>EXT4_INODE_RESERVED</td><td>Unknown (reserved)</td></tr>
</table></div>
<h3 id="reserved-inode-numbers"><a class="header" href="#reserved-inode-numbers">Reserved inode numbers</a></h3>
<div class="table-wrapper"><table><thead><th>Value</th><th>Identifier</th><th>Description</th></thead><tr><td>1</td><td>EXT2_BAD_INO, EXT3_BAD_INO, EXT4_BAD_INO</td><td>Bad blocks inode</td></tr>
<tr><td>2</td><td>EXT2_ROOT_INO, EXT3_ROOT_INO, EXT4_ROOT_INO</td><td>Root inode</td></tr>
<tr><td>3</td><td>EXT4_USR_QUOTA_INO</td><td>Owner (or user) quota inode</td></tr>
<tr><td>4</td><td>EXT4_GRP_QUOTA_INO</td><td>Group quota inode</td></tr>
<tr><td>5</td><td>EXT2_BOOT_LOADER_INO, EXT3_BOOT_LOADER_INO, EXT4_BOOT_LOADER_INO</td><td>Boot loader inode</td></tr>
<tr><td>6</td><td>EXT2_UNDEL_DIR_INO, EXT3_UNDEL_DIR_INO, EXT4_UNDEL_DIR_INO</td><td>Undelete directory inode</td></tr>
<tr><td>7</td><td>EXT3_RESIZE_INO, EXT4_RESIZE_INO</td><td>Reserved group descriptors inode</td></tr>
<tr><td>8</td><td>EXT3_JOURNAL_INO, EXT4_JOURNAL_INO</td><td>Journal inode</td></tr>
</table></div>
<h2 id="inline-data"><a class="header" href="#inline-data">Inline data</a></h2>
<p>ext4 supports storing file entry data inline when the inode flag
EXT4_INLINE_DATA_FL is set.</p>
<blockquote>
<p>Note that inodes can have an implicit last sparse extent if the the inode
data size is greater than 60 bytes.</p>
</blockquote>
<h2 id="huge-files"><a class="header" href="#huge-files"><a name="huge_files"></a>Huge files</a></h2>
<p>TODO: complete section</p>
<h2 id="directory-entries"><a class="header" href="#directory-entries">Directory entries</a></h2>
<p>Directories entries are stored in the data blocks of a directory inode. The
directory entries can be stored in multiple ways:</p>
<ul>
<li>as linear directory entries</li>
<li>as inline data directory entries</li>
<li>as hash-tree directory entries</li>
</ul>
<h3 id="linear-directory-entries"><a class="header" href="#linear-directory-entries">Linear directory entries</a></h3>
<p>Linear directories entries are stored in a series of allocation blocks.</p>
<p>Linear directory entries contain:</p>
<ul>
<li>directory entry for "." (self)</li>
<li>directory entry for ".." (parent)</li>
<li>directory entry for other file system entries</li>
</ul>
<h4 id="the-directory-entry"><a class="header" href="#the-directory-entry"><a name="directory_entry"></a>The directory entry</a></h4>
<p>The directory entry is of variable size, at most 263 bytes, and consists of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>4</td><td></td><td>Inode number</td></tr>
<tr><td>4</td><td>2</td><td></td><td>Directory entry size, which must be a multitude of 4.</td></tr>
<tr><td>6</td><td>1</td><td></td><td>Name size, which contains the size of the name without the end-of-string character and has a maximum of 255</td></tr>
<tr><td>7</td><td>1</td><td></td><td><a href="ext.html#file_types">File type</a></td></tr>
<tr><td>8</td><td>...</td><td></td><td>Name, which contains a narrow character string without end-of-string character</td></tr>
</table></div>
<p>Older directory entry structures considered the name size a 16-bit value, but
the upper byte was never used.</p>
<p>The name can contain any character value except the path segment separator ('/')
and the NUL-character ('\0').</p>
<h4 id="file-types"><a class="header" href="#file-types"><a name="file_types"></a>File types</a></h4>
<div class="table-wrapper"><table><thead><th>Value</th><th>Identifier</th><th>Description</th></thead><tr><td>0</td><td>EXT2_FT_UNKNOWN</td><td>Unknown</td></tr>
<tr><td>1</td><td>EXT2_FT_REG_FILE</td><td>Regular file</td></tr>
<tr><td>2</td><td>EXT2_FT_DIR</td><td>Directory</td></tr>
<tr><td>3</td><td>EXT2_FT_CHRDEV</td><td>Character device</td></tr>
<tr><td>4</td><td>EXT2_FT_BLKDEV</td><td>Block device</td></tr>
<tr><td>5</td><td>EXT2_FT_FIFO</td><td>FIFO queue</td></tr>
<tr><td>6</td><td>EXT2_FT_SOCK</td><td>Socket</td></tr>
<tr><td>7</td><td>EXT2_FT_SYMLINK</td><td>Symbolic link</td></tr>
</table></div>
<h3 id="inline-data-directory-entries"><a class="header" href="#inline-data-directory-entries">Inline data directory entries</a></h3>
<p>ext4 supports storing the directory entries as inline data when the inode flag
EXT4_INLINE_DATA_FL is set.</p>
<p>The inline data directory entries is of variable size, at most 60 bytes, and
consists of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>4</td><td></td><td>Parent inode number</td></tr>
<tr><td>4</td><td>...</td><td></td><td>Array of <a href="ext.html#directory_entry">directory entries</a></td></tr>
</table></div>
<h3 id="hash-tree-directory-entries"><a class="header" href="#hash-tree-directory-entries">Hash tree directory entries</a></h3>
<p>The data of the hash tree (HTree) is stored in the data blocs or extent defined
by the directory inode. The hash-indexed directory entries are read-compatible
with the <a href="ext.html#directory_entry">linear directory entry</a>.</p>
<h4 id="hash-tree-root"><a class="header" href="#hash-tree-root">Hash tree root</a></h4>
<p>The hash tree root consists of:</p>
<ul>
<li>dx_root
<ul>
<li>directory entry for "." (self)</li>
<li>directory entry for ".." (parent)</li>
<li>dx_root_info</li>
<li>Array of dx_entry</li>
</ul>
</li>
<li>directory entry for other file system entries</li>
</ul>
<h4 id="dx_root_info"><a class="header" href="#dx_root_info">dx_root_info</a></h4>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>4</td><td>0</td><td>Unknown (reserved)</td></tr>
<tr><td>4</td><td>1</td><td></td><td>Hash method (or version)</td></tr>
<tr><td>5</td><td>1</td><td>8</td><td>Root information size</td></tr>
<tr><td>6</td><td>1</td><td></td><td>Number of indirect levels in the hash tree</td></tr>
<tr><td>7</td><td>1</td><td></td><td>Unknown (unused flags)</td></tr>
</table></div>
<h4 id="dx_entry"><a class="header" href="#dx_entry">dx_entry</a></h4>
<p>TODO: complete section</p>
<pre><code>struct dx_entry
{
        __le32 hash;
        __le32 block;
};
</code></pre>
<h2 id="symbolic-links"><a class="header" href="#symbolic-links">Symbolic links</a></h2>
<p>If the target path of a symbolic link is less than 60 characters long, it is
stored in the 60 bytes in the inode that are normally used for the 12 direct
and 3 indirect block numbers. If the target path is longer than 60 characters,
a block is allocated, and the block contains the target path. The inode data
size contains the length of the target path.</p>
<h2 id="extended-attributes"><a class="header" href="#extended-attributes"><a name="extended_attributes"></a>Extended attributes</a></h2>
<p>Extended attributes can be stored:</p>
<ul>
<li>in the inode block after the inode data</li>
<li>in the block referenced by the file ACL (or extended attributes) block number, if not 0</li>
</ul>
<blockquote>
<p>Note that both should be read to get the all the extended attributes.</p>
</blockquote>
<p>Extended attributes consists of:</p>
<ul>
<li>An extended attributes header</li>
<li>Extended attributes entries with a terminator</li>
</ul>
<h3 id="the-extended-attributes-inode-header"><a class="header" href="#the-extended-attributes-inode-header">The extended attributes inode header</a></h3>
<p>The extended attributes inode header (ext2_xattr_ibody_header,
ext3_xattr_ibody_header, ext4_xattr_ibody_header) is 4 bytes in size and
consists of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>4</td><td>"\x00\x00\x02\xea"</td><td>Signature</td></tr>
</table></div>
<h3 id="the-extended-attributes-block-header"><a class="header" href="#the-extended-attributes-block-header">The extended attributes block header</a></h3>
<h4 id="the-ext2-and-ext3-extended-attributes-block-header"><a class="header" href="#the-ext2-and-ext3-extended-attributes-block-header">The ext2 and ext3 extended attributes block header</a></h4>
<p>The ext2 and ext3 extended attributes block header (ext2_xattr_header,
ext3_xattr_header) is 32 bytes in size and consists of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>4</td><td>"\x00\x00\x02\xea"</td><td>Signature</td></tr>
<tr><td>4</td><td>4</td><td></td><td>Unknown (reference count)</td></tr>
<tr><td>8</td><td>4</td><td></td><td>Number of blocks</td></tr>
<tr><td>12</td><td>4</td><td></td><td>Attributes hash</td></tr>
<tr><td>16</td><td>4 x 4</td><td></td><td>Unknown (reserved)</td></tr>
</table></div>
<h4 id="the-ext4-extended-attributes-block-header"><a class="header" href="#the-ext4-extended-attributes-block-header">The ext4 extended attributes block header</a></h4>
<p>The ext4 extended attributes block header (ext4_xattr_header) is 32 bytes of
size and consists of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>4</td><td>"\x00\x00\x02\xea"</td><td>Signature</td></tr>
<tr><td>4</td><td>4</td><td></td><td>Unknown (Reference count)</td></tr>
<tr><td>8</td><td>4</td><td></td><td>Number of blocks</td></tr>
<tr><td>12</td><td>4</td><td></td><td>Attributes hash</td></tr>
<tr><td>16</td><td>4</td><td></td><td>Checksum</td></tr>
<tr><td>20</td><td>3 x 4</td><td></td><td>Unknown (reserved)</td></tr>
</table></div>
<h3 id="the-extended-attributes-entry"><a class="header" href="#the-extended-attributes-entry">The extended attributes entry</a></h3>
<p>The extended attributes entry (ext2_xattr_entry, ext3_xattr_entry,
ext4_xattr_entry) is of variable size and consists of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>1</td><td></td><td>Name size, which contains the size of the name without the end-of-string character</td></tr>
<tr><td>1</td><td>1</td><td></td><td>Name index</td></tr>
<tr><td>2</td><td>2</td><td></td><td>Value data offset, which contains the offset of the value data relative from the start of the extended attributes block or after the extended attributes signature in the inode block data</td></tr>
<tr><td>4</td><td>4</td><td></td><td>Value data inode number, which contains the inode number that contains the value data or 0 to indicate the current block</td></tr>
<tr><td>8</td><td>4</td><td></td><td>Value data size</td></tr>
<tr><td>12</td><td>4</td><td></td><td>Unknown (Attribute hash)</td></tr>
<tr><td>16</td><td>...</td><td></td><td>Name string, which contains an ASCII string without end-of-string character</td></tr>
<tr><td>...</td><td>...</td><td></td><td>32-bit alignment padding</td></tr>
</table></div>
<p>The last extended attributes entry has the first 4 values set to 0 (8 bytes)
and is used as a terminator.</p>
<blockquote>
<p>Note that some implementations of older Android versions of ext appear to
only set the first 4 bytess to 0.</p>
</blockquote>
<blockquote>
<p>Note that the name can be empty, for example in combination with a prefix or
with an encrypted file.</p>
</blockquote>
<h3 id="the-extended-attribute-name-index"><a class="header" href="#the-extended-attribute-name-index">The extended attribute name index</a></h3>
<p>The name index indicates the prefix of the extended attribute name.</p>
<div class="table-wrapper"><table><thead><th>Name index</th><th>Name prefix</th><th>Description</th></thead><tr><td>0</td><td>""</td><td>No prefix</td></tr>
<tr><td>1</td><td>"user."</td><td></td></tr>
<tr><td>2</td><td>"system.posix_acl_access"</td><td></td></tr>
<tr><td>3</td><td>"system.posix_acl_default"</td><td></td></tr>
<tr><td>4</td><td>"trusted."</td><td></td></tr>
<tr><td></td><td></td><td></td></tr>
<tr><td>6</td><td>"security."</td><td></td></tr>
<tr><td>7</td><td>"system."</td><td></td></tr>
<tr><td>8</td><td>"system.richacl"</td><td></td></tr>
</table></div>
<h2 id="journal"><a class="header" href="#journal">Journal</a></h2>
<p>The journal was introduced in ext3.</p>
<p>TODO: complete section</p>
<h2 id="exclude-bitmap"><a class="header" href="#exclude-bitmap">Exclude bitmap</a></h2>
<p>TODO: complete section</p>
<blockquote>
<p>Note that the excluded bitmap is used for snapshots.</p>
</blockquote>
<h2 id="references-4"><a class="header" href="#references-4">References</a></h2>
<ul>
<li><a href="https://docs.kernel.org/filesystems/ext4">ext4 Data Structures and Algorithms</a>, by the Linux kernel documentation</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="extensible-file-allocation-table-exfat-file-system-format"><a class="header" href="#extensible-file-allocation-table-exfat-file-system-format">Extensible File Allocation Table (exFAT) file system format</a></h1>
<p>The Extensible File Allocation Table (exFAT) file system format is a successor
of the <a href="fat.html">File Allocation Table (FAT)</a> file system format.</p>
<h2 id="overview-11"><a class="header" href="#overview-11">Overview</a></h2>
<p>An exFAT file system consists of:</p>
<ul>
<li>One or more reserved sectors
<ul>
<li>a boot record (or boot sector)</li>
</ul>
</li>
<li>One or more cluster block allocation tables</li>
<li>File and directory data</li>
</ul>
<h3 id="characteristics-10"><a class="header" href="#characteristics-10">Characteristics</a></h3>
<div class="table-wrapper"><table><thead><th>Characteristics</th><th>Description</th></thead><tr><td>Byte order</td><td>little-endian</td></tr>
<tr><td>Date and time values</td><td>FAT date and time</td></tr>
<tr><td>Character strings</td><td>UCS-2 little-endian, which allows for unpaired Unicode surrogates such as "U+d800" and "U+dc00"</td></tr>
</table></div>
<h3 id="boot-record"><a class="header" href="#boot-record">Boot record</a></h3>
<p>The boot record is stored in the first sector of the volume.</p>
<p>The boot record is at least 512 bytes in size and consists of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>3</td><td>"\xeb\x76\x90"</td><td>Boot entry point (JMP +120, NOP)</td></tr>
<tr><td>3</td><td>8</td><td>"EXFAT\x20\x20\x20"</td><td>File system signature (or OEM name)</td></tr>
<tr><td>11</td><td>53</td><td>0</td><td>Unknown (reserved), which must be 0.</td></tr>
<tr><td>64</td><td>8</td><td></td><td>Partition offset</td></tr>
<tr><td>72</td><td>8</td><td></td><td>Total number of sectors</td></tr>
<tr><td>80</td><td>4</td><td></td><td>Cluster block allocation table start sector</td></tr>
<tr><td>84</td><td>4</td><td></td><td>Cluster block allocation table size in number of sectors, which must be non 0</td></tr>
<tr><td>88</td><td>4</td><td></td><td>Data cluster start sector</td></tr>
<tr><td>92</td><td>4</td><td></td><td>Total number of data clusters</td></tr>
<tr><td>96</td><td>4</td><td></td><td>Root directory start cluster</td></tr>
<tr><td>100</td><td>4</td><td></td><td>Volume serial number</td></tr>
<tr><td>104</td><td>1</td><td></td><td>Format revision minor number</td></tr>
<tr><td>105</td><td>1</td><td>1</td><td>Format revision major number</td></tr>
<tr><td>106</td><td>2</td><td></td><td>Volume flags</td></tr>
<tr><td>108</td><td>1</td><td></td><td>Bytes per sector, which is stored as <code>2^n</code>, for example 9 is <code>2^9 = 512</code>. The bytes per sector value must be 512, 1024, 2048 or 4096.</td></tr>
<tr><td>109</td><td>1</td><td></td><td>Sectors per cluster block, which is stored as <code>2^n</code>, for example 3 is <code>2^3 = 8</code>. The sectors per cluster block must be 1 upto 32M (<code>2^25</code>).</td></tr>
<tr><td>110</td><td>1</td><td></td><td>Number of cluster block allocation tables</td></tr>
<tr><td>111</td><td>1</td><td></td><td>Drive number</td></tr>
<tr><td>112</td><td>1</td><td></td><td>Unknown (percent in use), which contains the percentage of allocated cluster blocks in the cluster heap of 0xff if not available</td></tr>
<tr><td>113</td><td>7</td><td></td><td>Unknown (reserved)</td></tr>
<tr><td>120</td><td>390</td><td></td><td>Used for boot code</td></tr>
<tr><td>510</td><td>2</td><td>"\x55\xaa"</td><td>Sector signature</td></tr>
</table></div>
<h3 id="volume-flags"><a class="header" href="#volume-flags">Volume flags</a></h3>
<div class="table-wrapper"><table><thead><th>Value</th><th>Identifier</th><th>Description</th></thead><tr><td>0x0001</td><td>ActiveFat</td><td>Active FAT, 0 for the first FAT, 1 for the second FAT</td></tr>
<tr><td>0x0002</td><td>VolumeDirty</td><td>Is dirty</td></tr>
<tr><td>0x0004</td><td>MediaFailure</td><td>Has media failures</td></tr>
<tr><td>0x0008</td><td>ClearToZero</td><td>Must be cleared</td></tr>
<tr><td>0xfff0</td><td></td><td>Unknown (reserved)</td></tr>
</table></div>
<h2 id="cluster-block-allocation-table"><a class="header" href="#cluster-block-allocation-table">Cluster block allocation table</a></h2>
<p>A cluster block allocation table consists of:</p>
<ul>
<li>One ore more cluster block allocation table entries</li>
</ul>
<h3 id="cluster-block-allocation-table-entry"><a class="header" href="#cluster-block-allocation-table-entry">Cluster block allocation table entry</a></h3>
<p>A cluster block allocation table entry is 32 bits in size and consists of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>32 bits</td><td></td><td>Data cluster number</td></tr>
</table></div>
<p>Where the data cluster number has the following meanings:</p>
<div class="table-wrapper"><table><thead><th>Value(s)</th><th>Description</th></thead><tr><td>0x00000000</td><td>Unused (free) cluster</td></tr>
<tr><td>0x00000001</td><td>Unknown (invalid)</td></tr>
<tr><td>0x00000002 - 0xffffffef</td><td>Used cluster</td></tr>
<tr><td>0xfffffff0 - 0xfffffff6</td><td>Reserved</td></tr>
<tr><td>0xfffffff7</td><td>Bad cluster</td></tr>
<tr><td>0xfffffff8 - 0xffffffff</td><td>End of cluster chain</td></tr>
</table></div>
<h2 id="directory"><a class="header" href="#directory">Directory</a></h2>
<p>A directory consists of:</p>
<ul>
<li>Zero or more directory entries</li>
<li>Terminator directory entry</li>
</ul>
<h3 id="directory-entry"><a class="header" href="#directory-entry">Directory entry</a></h3>
<p>A directory entry is 32 bytes in size and consists of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>1</td><td></td><td>Entry type</td></tr>
<tr><td>1</td><td>19</td><td></td><td>Entry data</td></tr>
<tr><td>20</td><td>4</td><td></td><td>Data stream start cluster</td></tr>
<tr><td>24</td><td>8</td><td></td><td>Data stream size</td></tr>
</table></div>
<h4 id="directory-entry-type"><a class="header" href="#directory-entry-type">Directory entry type</a></h4>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>5 bits</td><td></td><td>Type type code</td></tr>
<tr><td>0.5</td><td>1 bit</td><td></td><td>Is non-critical (also referred to as type importance)</td></tr>
<tr><td>0.6</td><td>1 bit</td><td></td><td>Is secondary entry (also referred to as type category)</td></tr>
<tr><td>0.7</td><td>1 bit</td><td></td><td>In use</td></tr>
</table></div>  
<div class="table-wrapper"><table><thead><th>Value</th><th>Description</th></thead><tr><td>0x00</td><td>Terminator directory entry</td></tr>
<tr><td>0x01 - 0x7f</td><td>Unused</td></tr>
<tr><td>0x80</td><td>Invalid</td></tr>
<tr><td>0x81 - 0xff</td><td>Used</td></tr>
</table></div>
<h5 id="directory-entry-type-codes"><a class="header" href="#directory-entry-type-codes">Directory entry type codes</a></h5>
<div class="table-wrapper"><table><thead><th>Value</th><th>Description</th></thead><tr><td colspan="4"> <em>Critical and primary</em></tr>
<tr><td>0x81</td><td>Allocation bitmap</td></tr>
<tr><td>0x82</td><td>Case folding mappings</td></tr>
<tr><td>0x83</td><td>Volume label</td></tr>
<tr><td></td><td></td></tr>
<tr><td>0x85</td><td>File entry</td></tr>
<tr><td></td><td></td></tr>
<tr><td colspan="4"> <em>Non-critical and primary</em></tr>
<tr><td>0xa0</td><td>Volume identifier</td></tr>
<tr><td>0xa1</td><td>TexFAT padding</td></tr>
<tr><td></td><td></td></tr>
<tr><td colspan="4"> <em>Critical and secondary</em></tr>
<tr><td>0xc0</td><td>Data stream</td></tr>
<tr><td>0xc1</td><td>File entry name</td></tr>
<tr><td></td><td></td></tr>
<tr><td colspan="4"> <em>Non-critical and secondary</em></tr>
<tr><td>0xe0</td><td>Vendor extension</td></tr>
<tr><td>0xe1</td><td>Vendor allocation</td></tr>
</table></div>
<h5 id="allocation-bitmap-directory-entry"><a class="header" href="#allocation-bitmap-directory-entry">Allocation bitmap directory entry</a></h5>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>1</td><td>0x81</td><td>Entry type</td></tr>
<tr><td>1</td><td>1</td><td></td><td>Bitmap flags</td></tr>
<tr><td>2</td><td>18</td><td>0</td><td>Unknown (Reserved)</td></tr>
<tr><td>20</td><td>4</td><td></td><td>Data stream start cluster</td></tr>
<tr><td>24</td><td>8</td><td></td><td>Data stream size</td></tr>
</table></div>
<h5 id="case-folding-mappings-directory-entry"><a class="header" href="#case-folding-mappings-directory-entry">Case folding mappings directory entry</a></h5>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>1</td><td>0x82</td><td>Entry type</td></tr>
<tr><td>1</td><td>3</td><td>0</td><td>Unknown (Reserved)</td></tr>
<tr><td>4</td><td>4</td><td></td><td>Checksum</td></tr>
<tr><td>8</td><td>12</td><td>0</td><td>Unknown (Reserved)</td></tr>
<tr><td>20</td><td>4</td><td></td><td>Data stream start cluster</td></tr>
<tr><td>24</td><td>8</td><td></td><td>Data stream size</td></tr>
</table></div>
<h5 id="volume-label-directory-entry"><a class="header" href="#volume-label-directory-entry">Volume label directory entry</a></h5>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>1</td><td>0x83</td><td>Entry type</td></tr>
<tr><td>1</td><td>1</td><td></td><td>Name number of characters</td></tr>
<tr><td>2</td><td>22</td><td></td><td>Name string, which contains an UCS-2 little-endian string without an end-of-string character</td></tr>
<tr><td>24</td><td>8</td><td>0</td><td>Unknown (Reserved)</td></tr>
</table></div>
<blockquote>
<p>Note that the volume label directory entry should only be stored in the first
and/or second directory entry of the root directory.</p>
</blockquote>
<h5 id="file-entry-directory-entry"><a class="header" href="#file-entry-directory-entry">File entry directory entry</a></h5>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>1</td><td>0x85</td><td>Entry type</td></tr>
<tr><td>1</td><td>1</td><td></td><td>Unknown (Secondary count)</td></tr>
<tr><td>2</td><td>2</td><td></td><td>Unknown (Set checksum)</td></tr>
<tr><td>4</td><td>2</td><td></td><td><a href="exfat.html#file_attribute_flags">File attribute flags</a></td></tr>
<tr><td>6</td><td>2</td><td>0</td><td>Unknown (Reserved)</td></tr>
<tr><td>8</td><td>2</td><td></td><td>Creation time</td></tr>
<tr><td>10</td><td>2</td><td></td><td>Creation date</td></tr>
<tr><td>12</td><td>2</td><td></td><td>Last modification time</td></tr>
<tr><td>14</td><td>2</td><td></td><td>Last modification date</td></tr>
<tr><td>16</td><td>2</td><td></td><td>Last access time</td></tr>
<tr><td>18</td><td>2</td><td></td><td>Last access date</td></tr>
<tr><td>20</td><td>1</td><td></td><td>Creation time fraction of seconds, which contains fraction of 2-seconds in 10 ms intervals</td></tr>
<tr><td>21</td><td>1</td><td></td><td>Last modification time fraction of seconds, which contains fraction of 2-seconds in 10 ms intervals</td></tr>
<tr><td>22</td><td>1</td><td></td><td>Creation time UTC offset, which contains number of 15 minute intervals of the time relative to UTC, where the MSB indicates the offset is valid</td></tr>
<tr><td>23</td><td>1</td><td></td><td>Last modification time UTC offset, which contains number of 15 minute intervals of the time relative to UTC, where the MSB indicates the offset is valid</td></tr>
<tr><td>24</td><td>1</td><td></td><td>Last access time UTC offset, which contains number of 15 minute intervals of the time relative to UTC, where the MSB indicates the offset is valid</td></tr>
<tr><td>25</td><td>7</td><td>0</td><td>Unknown (Reserved)</td></tr>
</table></div>
<h5 id="volume-identifier-directory-entry"><a class="header" href="#volume-identifier-directory-entry">Volume identifier directory entry</a></h5>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>1</td><td>0xa0</td><td>Entry type</td></tr>
<tr><td>1</td><td>1</td><td></td><td>Unknown (Secondary count)</td></tr>
<tr><td>2</td><td>2</td><td></td><td>Unknown (Set checksum)</td></tr>
<tr><td>4</td><td>2</td><td></td><td>Unknown (Flags)</td></tr>
<tr><td>6</td><td>16</td><td></td><td>Volume identifier, which contains a GUID</td></tr>
<tr><td>22</td><td>10</td><td>0</td><td>Unknown (Reserved)</td></tr>
</table></div>
<h5 id="data-stream-directory-entry"><a class="header" href="#data-stream-directory-entry">Data stream directory entry</a></h5>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>1</td><td>0xc0</td><td>Entry type</td></tr>
<tr><td>1</td><td>1</td><td></td><td>Unknown (Flags)</td></tr>
<tr><td>2</td><td>1</td><td>0</td><td>Unknown (Reserved)</td></tr>
<tr><td>3</td><td>1</td><td></td><td>Name number of characters</td></tr>
<tr><td>4</td><td>2</td><td></td><td>Name hash</td></tr>
<tr><td>6</td><td>2</td><td>0</td><td>Unknown (Reserved)</td></tr>
<tr><td>8</td><td>8</td><td></td><td>Data stream valid data size</td></tr>
<tr><td>16</td><td>4</td><td>0</td><td>Unknown (Reserved)</td></tr>
<tr><td>20</td><td>4</td><td></td><td>Data stream start cluster</td></tr>
<tr><td>24</td><td>8</td><td></td><td>Data stream size</td></tr>
</table></div>
<h5 id="file-entry-name-directory-entry"><a class="header" href="#file-entry-name-directory-entry">File entry name directory entry</a></h5>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>1</td><td>0xc1</td><td>Entry type</td></tr>
<tr><td>1</td><td>1</td><td></td><td>Unknown (Flags)</td></tr>
<tr><td>2</td><td>30</td><td></td><td>Name string, which contains an UCS-2 little-endian string without an end-of-string character</td></tr>
</table></div>
<h3 id="file-attribute-flags"><a class="header" href="#file-attribute-flags"><a name="file_attribute_flags"></a>File attribute flags</a></h3>
<div class="table-wrapper"><table><thead><th>Value</th><th>Description</th></thead><tr><td>0x0001</td><td>Read-only</td></tr>
<tr><td>0x0002</td><td>Hidden</td></tr>
<tr><td>0x0004</td><td>System</td></tr>
<tr><td>0x0008</td><td>Is volume label</td></tr>
<tr><td>0x0010</td><td>Is directory</td></tr>
<tr><td>0x0020</td><td>Archive</td></tr>
<tr><td>0x0040</td><td>Is device</td></tr>
<tr><td>0x0080</td><td>Unused (reserved)</td></tr>
</table></div>
<h2 id="references-5"><a class="header" href="#references-5">References</a></h2>
<ul>
<li><a href="https://learn.microsoft.com/en-gb/windows/win32/fileio/exfat-specification">exFAT file system specification</a>, by Microsoft</li>
<li><a href="https://en.wikipedia.org/wiki/ExFAT">exFAT</a>, by Wikipedia</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="file-allocation-table-fat-file-system-format"><a class="header" href="#file-allocation-table-fat-file-system-format">File Allocation Table (FAT) file system format</a></h1>
<p>The File Allocation Table (FAT) is widely used a file sytem.</p>
<h2 id="overview-12"><a class="header" href="#overview-12">Overview</a></h2>
<p>The File Allocation Table (FAT) is widely used a file sytem. There are multiple
known variants or derivatives of FAT, such as:</p>
<ul>
<li>(original) 8-bit FAT</li>
<li>FAT-12</li>
<li>FAT-16</li>
<li>FAT-32</li>
<li><a href="exfat.html">exFAT</a></li>
</ul>
<p>A FAT file system consists of:</p>
<ul>
<li>One or more reserved sectors
<ul>
<li>a boot record (or boot sector)</li>
<li>file system informartion for FAT-32</li>
</ul>
</li>
<li>One or more cluster block allocation tables</li>
<li>Root directory data for FAT-12 and FAT-16</li>
<li>File and directory data</li>
</ul>
<blockquote>
<p>Note that FAT-32 stores the root directory as part of the file and directory
data.</p>
</blockquote>
<h3 id="characteristics-11"><a class="header" href="#characteristics-11">Characteristics</a></h3>
<div class="table-wrapper"><table><thead><th>Characteristics</th><th>Description</th></thead><tr><td>Byte order</td><td>little-endian</td></tr>
<tr><td>Date and time values</td><td>FAT date and time</td></tr>
<tr><td>Character strings</td><td>A narrow character Single Byte Character (SBC) ASCII string.</td></tr>
</table></div>
<h3 id="terminology-4"><a class="header" href="#terminology-4">Terminology</a></h3>
<div class="table-wrapper"><table><thead><th>Term</th><th>Description</th></thead><tr><td>Hidden sectors</td><td>The sectors stored before the FAT volume, such as those used to store a parition table.</td></tr>
</table></div>
<h3 id="determing-the-fat-format-version"><a class="header" href="#determing-the-fat-format-version">Determing the FAT format version</a></h3>
<p>To distinguish between FAT-12, FAT-16 and FAT-32, compute the number of clusters
in the data area:</p>
<pre><code>data area size = total number of sectors - ( number of reserved sectors s tables + size of root directory )
</code></pre>
<pre><code>number of clusters = round down ( data area size / sectors per cluster )
</code></pre>
<ul>
<li>FAT-12 is used if the number of clusters is less than 4085</li>
<li>FAT-16 is used if the number of clusters is less than 65525</li>
<li>FAT-32 is used otherwise</li>
</ul>
<h2 id="boot-record-1"><a class="header" href="#boot-record-1">Boot record</a></h2>
<p>The boot record is stored in the first sector of the volume.</p>
<h3 id="fat-12-and-fat-16-boot-record"><a class="header" href="#fat-12-and-fat-16-boot-record">FAT-12 and FAT-16 boot record</a></h3>
<p>The FAT-12 and FAT-16 boot record is at least 512 bytes in size and consists of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>3</td><td>"\xeb\x3c\x90"</td><td>Boot entry point (JMP +62, NOP)</td></tr>
<tr><td>3</td><td>8</td><td></td><td>File system signature (or OEM name)</td></tr>
<tr><td>11</td><td>2</td><td></td><td>Bytes per sector, which must be 512, 1024, 2048 or 4096</td></tr>
<tr><td>13</td><td>1</td><td></td><td>Sectors per cluster block, which must be 1, 2, 4, 8, 16, 32, 64 or 128</td></tr>
<tr><td>14</td><td>2</td><td></td><td>Number of reserved sectors (reserved region), which starts at the first sector of the volume (sector 0) and must be 1 or more (typically 1 or 32).</td></tr>
<tr><td>16</td><td>1</td><td></td><td>Number of cluster block allocation tables, which must be 1 or more (typically 2).</td></tr>
<tr><td>17</td><td>2</td><td></td><td>Number of root directory entries</td></tr>
<tr><td>19</td><td>2</td><td></td><td>Total number of sectors (16-bit)</td></tr>
<tr><td>21</td><td>1</td><td></td><td><a href="fat.html#media_descriptors">Media descriptor</a></td></tr>
<tr><td>22</td><td>2</td><td></td><td>Cluster block allocation table size (16-bit) in number of sectors</td></tr>
<tr><td>24</td><td>2</td><td></td><td>Number of sectors per track</td></tr>
<tr><td>26</td><td>2</td><td></td><td>Number of heads</td></tr>
<tr><td>28</td><td>4</td><td></td><td>Number of hidden sectors</td></tr>
<tr><td>32</td><td>4</td><td></td><td>Total number of sectors (32-bit)</td></tr>
<tr><td>36</td><td>1</td><td></td><td>Drive number</td></tr>
<tr><td>37</td><td>1</td><td>0</td><td>Unknown (reserved for Windows NT)</td></tr>
<tr><td>38</td><td>1</td><td></td><td>Extended boot signature</td></tr>
<tr><td colspan="4"> <em>If extended boot signature == 0x29</em></tr>
<tr><td>39</td><td>4</td><td></td><td>Volume serial number</td></tr>
<tr><td>43</td><td>11</td><td></td><td>Volume label, which contains a narrow character string or "NO\x20NAME\x20\x20\x20\x20" if not set</td></tr>
<tr><td>54</td><td>8</td><td>"FAT12\x20\x20\x20" or "FAT16\x20\x20\x20"</td><td>File system hint</td></tr>
<tr><td colspan="4"> <em>If extended boot signature != 0x29</em></tr>
<tr><td>39</td><td>23</td><td></td><td>Unknown</td></tr>
<tr><td colspan="4"> <em>Common</em></tr>
<tr><td>62</td><td>448</td><td></td><td>Used for boot code</td></tr>
<tr><td>510</td><td>2</td><td>"\x55\xaa"</td><td>Sector signature</td></tr>
</table></div>
<blockquote>
<p>Note that the sector signature must be set at offset 512 but can, in
addition, it can be set in the last 2 bytes of the sector.</p>
</blockquote>
<blockquote>
<p>Note that the volume serial number can be derived from the system current
date and time.</p>
</blockquote>
<blockquote>
<p>Note that the file system hint value is purely informational and not enforced
by the format.</p>
</blockquote>
<h3 id="fat-32-boot-record"><a class="header" href="#fat-32-boot-record">FAT-32 boot record</a></h3>
<p>The FAT-32 boot record is at least 512 bytes in size and consists of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>3</td><td>"\xeb\x58\x90"</td><td>Boot entry point (JMP +90, NOP)</td></tr>
<tr><td>3</td><td>8</td><td></td><td>File system signature (or OEM name)</td></tr>
<tr><td>11</td><td>2</td><td></td><td>Bytes per sector, which must be 512, 1024, 2048 or 4096</td></tr>
<tr><td>13</td><td>1</td><td></td><td>Sectors per cluster block, which must be 1, 2, 4, 8, 16, 32, 64 or 128</td></tr>
<tr><td>14</td><td>2</td><td></td><td>Number of reserved sectors (reserved region), which starts at the first sector of the volume (sector 0) and must be 1 or more (typically 1 or 32).</td></tr>
<tr><td>16</td><td>1</td><td></td><td>Number of cluster block allocation tables, which must be 1 or more (typically 2).</td></tr>
<tr><td>17</td><td>2</td><td>0</td><td>Number of root directory entries, which must be 0 for FAT-32</td></tr>
<tr><td>19</td><td>2</td><td>0</td><td>Total number of sectors (16-bit), which must be 0 for FAT-32</td></tr>
<tr><td>21</td><td>1</td><td></td><td><a href="fat.html#media_descriptors">Media descriptor</a></td></tr>
<tr><td>22</td><td>2</td><td>0</td><td>Cluster block allocation table size (16-bit) in number of sectors, which must be 0 for FAT-32</td></tr>
<tr><td>24</td><td>2</td><td></td><td>Number of sectors per track</td></tr>
<tr><td>26</td><td>2</td><td></td><td>Number of heads</td></tr>
<tr><td>28</td><td>4</td><td></td><td>Number of hidden sectors</td></tr>
<tr><td>32</td><td>4</td><td></td><td>Total number of sectors (32-bit)</td></tr>
<tr><td>36</td><td>4</td><td></td><td>Cluster block allocation table size (32-bit) in number of sectors, which must be non 0 for FAT-32</td></tr>
<tr><td>40</td><td>2</td><td></td><td>Extended flags</td></tr>
<tr><td>42</td><td>1</td><td>0</td><td>Format revision minor number</td></tr>
<tr><td>43</td><td>1</td><td>0</td><td>Format revision major number</td></tr>
<tr><td>44</td><td>4</td><td></td><td>Root directory start cluster</td></tr>
<tr><td>48</td><td>2</td><td></td><td>File system information (FSINFO) sector number</td></tr>
<tr><td>50</td><td>2</td><td></td><td>Boot record sector number</td></tr>
<tr><td>52</td><td>12</td><td>0</td><td>Unknown (reserved)</td></tr>
<tr><td>64</td><td>1</td><td></td><td>Drive number</td></tr>
<tr><td>65</td><td>1</td><td>0</td><td>Unknown (reserved for Windows NT)</td></tr>
<tr><td>66</td><td>1</td><td></td><td>Extended boot signature</td></tr>
<tr><td colspan="4"> <em>If extended boot signature == 0x29</em></tr>
<tr><td>67</td><td>4</td><td></td><td>Volume serial number</td></tr>
<tr><td>71</td><td>11</td><td></td><td>Volume label, which contains a narrow character string or "NO\x20NAME\x20\x20\x20\x20" if not set</td></tr>
<tr><td>82</td><td>8</td><td>"FAT32\x20\x20\x20"</td><td>File system hint</td></tr>
<tr><td colspan="4"> <em>If extended boot signature != 0x29</em></tr>
<tr><td>67</td><td>23</td><td></td><td>Unknown</td></tr>
<tr><td colspan="4"> <em>Common</em></tr>
<tr><td>90</td><td>420</td><td></td><td>Used for boot code</td></tr>
<tr><td>510</td><td>2</td><td>"\x55\xaa"</td><td>Sector signature</td></tr>
</table></div>
<blockquote>
<p>Note that the sector signature must be set at offset 512 but can, in
addition, it can be set in the last 2 bytes of the sector.</p>
</blockquote>
<blockquote>
<p>Note that the volume serial number can be derived from the system current
date and time.</p>
</blockquote>
<blockquote>
<p>Note that the file system hint value is purely informational and not enforced
by the format.</p>
</blockquote>
<h3 id="oem-names"><a class="header" href="#oem-names">OEM names</a></h3>
<div class="table-wrapper"><table><thead><th>Value</th><th>Description</th></thead><tr><td>"MSWIN4.1"</td><td></td></tr>
<tr><td>"MSDOS 5.0"</td><td></td></tr>
</table></div>
<h3 id="media-descriptors"><a class="header" href="#media-descriptors"><a name="media_descriptors"></a>Media descriptors</a></h3>
<div class="table-wrapper"><table><thead><th>Value</th><th>Identifier</th><th>Description</th></thead><tr><td>0xf0</td><td></td><td>removable media</td></tr>
<tr><td>0xf8</td><td></td><td>fixed (non-removable) media</td></tr>
<tr><td>0xf9</td><td></td><td></td></tr>
<tr><td>0xfa</td><td></td><td></td></tr>
<tr><td>0xfb</td><td></td><td></td></tr>
<tr><td>0xfc</td><td></td><td></td></tr>
<tr><td>0xfd</td><td></td><td></td></tr>
<tr><td>0xfe</td><td></td><td></td></tr>
<tr><td>0xff</td><td></td><td></td></tr>
</table></div>
<h2 id="cluster-block-allocation-table-1"><a class="header" href="#cluster-block-allocation-table-1">Cluster block allocation table</a></h2>
<p>A cluster block allocation table consists of:</p>
<ul>
<li>One ore more cluster block allocation table entries</li>
</ul>
<h3 id="fat-12-cluster-block-allocation-table-entry"><a class="header" href="#fat-12-cluster-block-allocation-table-entry">FAT 12 cluster block allocation table entry</a></h3>
<p>A FAT 12 cluster block allocation table entry is 12 bits in size and consists
of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>12 bits</td><td></td><td>Data cluster number</td></tr>
</table></div>
<p>Where the data cluster number has the following meanings:</p>
<div class="table-wrapper"><table><thead><th>Value(s)</th><th>Description</th></thead><tr><td>0x000</td><td>Unused (free) cluster</td></tr>
<tr><td>0x001</td><td>Unknown (invalid)</td></tr>
<tr><td>0x002 - 0xfef</td><td>Used cluster</td></tr>
<tr><td>0xff0 - 0xff6</td><td>Reserved</td></tr>
<tr><td>0xff7</td><td>Bad cluster</td></tr>
<tr><td>0xff8 - 0xfff</td><td>End of cluster chain</td></tr>
</table></div>
<h3 id="fat-16-cluster-block-allocation-table-entry"><a class="header" href="#fat-16-cluster-block-allocation-table-entry">FAT 16 cluster block allocation table entry</a></h3>
<p>A FAT 16 cluster block allocation table entry is 16 bits in size and consists
of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>16 bits</td><td></td><td>Data cluster number</td></tr>
</table></div>
<p>Where the data cluster number has the following meanings:</p>
<div class="table-wrapper"><table><thead><th>Value(s)</th><th>Description</th></thead><tr><td>0x0000</td><td>Unused (free) cluster</td></tr>
<tr><td>0x0001</td><td>Unknown (invalid)</td></tr>
<tr><td>0x0002 - 0xffef</td><td>Used cluster</td></tr>
<tr><td>0xfff0 - 0xfff6</td><td>Reserved</td></tr>
<tr><td>0xfff7</td><td>Bad cluster</td></tr>
<tr><td>0xfff8 - 0xffff</td><td>End of cluster chain</td></tr>
</table></div>
<h3 id="fat-32-cluster-block-allocation-table-entry"><a class="header" href="#fat-32-cluster-block-allocation-table-entry">FAT 32 cluster block allocation table entry</a></h3>
<p>A FAT 32 cluster block allocation table entry is 32 bits in size and consists
of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>32 bits</td><td></td><td>Data cluster number</td></tr>
</table></div>
<blockquote>
<p>Note that only the lower 28-bits are used</p>
</blockquote>
<p>Where the data cluster number has the following meanings:</p>
<div class="table-wrapper"><table><thead><th>Value(s)</th><th>Description</th></thead><tr><td>0x00000000</td><td>Unused (free) cluster</td></tr>
<tr><td>0x00000001</td><td>Unknown (invalid)</td></tr>
<tr><td>0x00000002 - 0x0fffffef</td><td>Used cluster</td></tr>
<tr><td>0x0ffffff0 - 0x0ffffff6</td><td>Reserved</td></tr>
<tr><td>0x0ffffff7</td><td>Bad cluster</td></tr>
<tr><td>0x0ffffff8 - 0x0fffffff</td><td>End of cluster chain</td></tr>
<tr><td>0x10000000 - 0xffffffff</td><td>Unknown</td></tr>
</table></div>
<h2 id="directory-1"><a class="header" href="#directory-1">Directory</a></h2>
<p>A directory consists of:</p>
<ul>
<li>self (".") directory entry (not used in root directory)</li>
<li>parent ("..") directory entry (not used in root directory)</li>
<li>Zero or more directory entries</li>
<li>Terminator directory entry</li>
</ul>
<h3 id="directory-entry-1"><a class="header" href="#directory-entry-1">Directory entry</a></h3>
<h3 id="determining-the-root-directory-location"><a class="header" href="#determining-the-root-directory-location">Determining the root directory location</a></h3>
<pre><code>first allocation table offset = number of reserved sectors * bytes per sector
</code></pre>
<h4 id="fat-12-and-fat-16-root-directory"><a class="header" href="#fat-12-and-fat-16-root-directory">FAT-12 and FAT-16 root directory</a></h4>
<pre><code>root directory start offset = first allocation table offset + ( number of allocation tables * allocation table size * bytes per sector )
</code></pre>
<pre><code>first cluster offset = directory start sector + ( number of root directory entries * 32 )
</code></pre>
<h4 id="fat-32-root-directory"><a class="header" href="#fat-32-root-directory">FAT-32 root directory</a></h4>
<pre><code>first cluster offset = first allocation table sector + ( number of allocation tables * allocation table size * bytes per sector )
</code></pre>
<pre><code>root directory start offset = first cluster sector + ( ( root directory cluster - 2 ) * number of sectors per cluster )
</code></pre>
<h4 id="fat-12-fat-16-and-fat-32-directory-entry"><a class="header" href="#fat-12-fat-16-and-fat-32-directory-entry">FAT-12, FAT-16 and FAT-32 directory entry</a></h4>
<p>A FAT-12, FAT-16 and FAT-32 directory entry is 32 bytes in size and consists of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>8</td><td></td><td>Name, which is padded with spaces and the first character can have a special meaning</td></tr>
<tr><td>8</td><td>3</td><td></td><td>Extension, which is padded with spaces</td></tr>
<tr><td>11</td><td>1</td><td></td><td><a href="fat.html#file_attribute_flags">File attribute flags</a></td></tr>
<tr><td>12</td><td>1</td><td></td><td><a href="fat.html#short_file_name_flags">Flags</a></td></tr>
<tr><td>13</td><td>1</td><td></td><td>Creation time fraction of seconds, which contains fraction of 2-seconds in 10 ms intervals</td></tr>
<tr><td>14</td><td>2</td><td></td><td>Creation time</td></tr>
<tr><td>16</td><td>2</td><td></td><td>Creation date</td></tr>
<tr><td>18</td><td>2</td><td></td><td>Last access date</td></tr>
<tr><td>20</td><td>2</td><td></td><td>Unknown (OS/2 extended attribute), which is not used by FAT-12</td></tr>
<tr><td>22</td><td>2</td><td></td><td>Last modification time</td></tr>
<tr><td>24</td><td>2</td><td></td><td>Last modification date</td></tr>
<tr><td>26</td><td>2</td><td></td><td>Data stream start cluster</td></tr>
<tr><td>28</td><td>4</td><td></td><td>Data stream data size</td></tr>
</table></div>
<h3 id="short-or-83-file-name"><a class="header" href="#short-or-83-file-name">Short (or 8.3) file name</a></h3>
<p>A FAT short (or 8.3) file name is stored in an OEM character set (codepage). The
<a href="fat.html#short_name_first_character">first character</a> can have a special meaning.</p>
<p>Valid FAT short file name characters are:</p>
<div class="table-wrapper"><table><thead><th>Value</th><th>Description</th></thead><tr><td>'A-Z'</td><td>Upper case character</td></tr>
<tr><td>'0-9'</td><td>Numeric character</td></tr>
<tr><td>' '</td><td>Space, where trailing spaces are considered padding and therefore ignored.</td></tr>
<tr><td>'.'</td><td>Dot, with the exception of "." and  "..". Trailing dot characters are ignored.</td></tr>
<tr><td>'!'</td><td></td></tr>
<tr><td>'#'</td><td></td></tr>
<tr><td>'$'</td><td></td></tr>
<tr><td>'%'</td><td></td></tr>
<tr><td>'&amp;'</td><td></td></tr>
<tr><td>'''</td><td></td></tr>
<tr><td>'('</td><td></td></tr>
<tr><td>')'</td><td></td></tr>
<tr><td>'-'</td><td></td></tr>
<tr><td>'@'</td><td></td></tr>
<tr><td>'^'</td><td></td></tr>
<tr><td>'_'</td><td></td></tr>
<tr><td>'`'</td><td></td></tr>
<tr><td>'{'</td><td></td></tr>
<tr><td>'}'</td><td></td></tr>
<tr><td>'~'</td><td></td></tr>
<tr><td>0x80 - 0xff</td><td>Extended ASCII character, which are codepage dependent.</td></tr>
</table></div>
<h4 id="first-character"><a class="header" href="#first-character"><a name="short_name_first_character"></a>First character</a></h4>
<div class="table-wrapper"><table><thead><th>Value</th><th>Description</th></thead><tr><td>0x00</td><td>Last (or terminator) directory entry</td></tr>
<tr><td>0x01 - 0x13</td><td>VFAT long file name directory entry</td></tr>
<tr><td>0x05</td><td>Directory entry pending deallocation (deprecated since DOS 3.0) or substitution of a 0xe5 extended ASCII character value</td></tr>
<tr><td>0x41 - 0x54</td><td>Last VFAT long file name directory entry</td></tr>
<tr><td>0xe5</td><td>Unallocated directory entry</td></tr>
</table></div>
<h3 id="file-attribute-flags-1"><a class="header" href="#file-attribute-flags-1"><a name="file_attribute_flags"></a>File attribute flags</a></h3>
<div class="table-wrapper"><table><thead><th>Value</th><th>Description</th></thead><tr><td>0x01</td><td>Read-only</td></tr>
<tr><td>0x02</td><td>Hidden</td></tr>
<tr><td>0x04</td><td>System</td></tr>
<tr><td>0x08</td><td>Is volume label</td></tr>
<tr><td>0x10</td><td>Is directory</td></tr>
<tr><td>0x20</td><td>Archive</td></tr>
<tr><td>0x40</td><td>Is device</td></tr>
<tr><td>0x80</td><td>Unused (reserved)</td></tr>
</table></div>
<h3 id="flags"><a class="header" href="#flags"><a name="short_file_name_flags"></a>Flags</a></h3>
<div class="table-wrapper"><table><thead><th>Value</th><th>Description</th></thead><tr><td>0x01</td><td>Data is EFS encrypted</td></tr>
<tr><td>0x02</td><td>Data contains large EFS header</td></tr>
<tr><td colspan="3">  </tr>
<tr><td>0x08</td><td>Name should be represented in lower case</td></tr>
<tr><td>0x10</td><td>Extension should be represented in lower case</td></tr>
</table></div>
<h3 id="vfat-long-file-name-entry"><a class="header" href="#vfat-long-file-name-entry">VFAT long file name entry</a></h3>
<p>VFAT long file names entries are stored in directory entries. Multiple VFAT
long file name entries can be used to store a single long file name, where
the highest (last) sequence number is stored first. A maximum of 20 VFAT long
file name entries can be used to store a long file name of 255 UCS-2 characters.</p>
<p>VFAT long file names are stored using UCS-2 little-endian, which allows for
unpaired Unicode surrogates such as "U+d800" and "U+dc00"</p>
<p>VFAT long file name entries are stored before the directory entry containing
the short file name and additional file entry information.</p>
<p>A VFAT long file name entry is 32 bytes in size and consists of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>1</td><td></td><td>Sequence number</td></tr>
<tr><td>1</td><td>10</td><td></td><td>First name segment string, which contains 5 UCS-2 string characters</td></tr>
<tr><td>11</td><td>1</td><td>0x0f</td><td>Unknown (attributes)</td></tr>
<tr><td>12</td><td>1</td><td>0x00</td><td>Unknown (type)</td></tr>
<tr><td>13</td><td>1</td><td></td><td>Checksum of the short (8.3) file name</td></tr>
<tr><td>14</td><td>12</td><td></td><td>Second name segment string, which contains 6 UCS-2 string characters</td></tr>
<tr><td>26</td><td>2</td><td>0</td><td>Unknown (first cluster)</td></tr>
<tr><td>28</td><td>4</td><td></td><td>Third name segment string, which contains 2 UCS-2 string characters</td></tr>
</table></div>
<blockquote>
<p>Note that unused characters in the VFAT long file segment strings after the
end-of-string character (0x0000) are padded with 0xffff.</p>
</blockquote>
<h4 id="vfat-long-file-name-sequence-number"><a class="header" href="#vfat-long-file-name-sequence-number">VFAT long file name sequence number</a></h4>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>5 bits</td><td></td><td>Number</td></tr>
<tr><td>0.5</td><td>1 bit</td><td>0</td><td>Unknown (reserved)</td></tr>
<tr><td>0.6</td><td>1 bit</td><td>0</td><td>Unknown (last logical, first physical LFN entry)</td></tr>
<tr><td>0.7</td><td>1 bit</td><td>0</td><td>Unknown</td></tr>
</table></div>
<h2 id="references-6"><a class="header" href="#references-6">References</a></h2>
<ul>
<li><a href="http://download.microsoft.com/download/1/6/1/161ba512-40e2-4cc9-843a-923143f3456c/fatgen103.doc">Microsoft Extensible Firmware Initiative FAT32 File System Specification</a>, by Microsoft</li>
<li><a href="https://en.wikipedia.org/wiki/Design_of_the_FAT_file_system">Design of the FAT file system</a>, by Wikipedia</li>
<li><a href="https://en.wikipedia.org/wiki/File_Allocation_Table">File Allocation Table</a>, by Wikipedia</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="new-technologies-file-system-ntfs-format"><a class="header" href="#new-technologies-file-system-ntfs-format">New Technologies File System (NTFS) format</a></h1>
<p>The New Technologies File System (NTFS) format is the primary file system for
Microsoft Windows versions that are based on Windows NT.</p>
<h2 id="overview-13"><a class="header" href="#overview-13">Overview</a></h2>
<p>An New Technologies File System (NTFS) consists of:</p>
<ul>
<li>boot record</li>
<li>boot loader</li>
<li>Master File Table (MFT)</li>
<li>Mirror Master File Table (MFT)</li>
</ul>
<h3 id="characteristics-12"><a class="header" href="#characteristics-12">Characteristics</a></h3>
<div class="table-wrapper"><table><thead><th>Characteristics</th><th>Description</th></thead><tr><td>Byte order</td><td>little-endian</td></tr>
<tr><td>Date and time values</td><td>FILETIME in UTC</td></tr>
<tr><td>Character strings</td><td>UCS-2 little-endian, which allows for unpaired Unicode surrogates such as "U+d800" and "U+dc00"</td></tr>
</table></div>
<h3 id="versions"><a class="header" href="#versions">Versions</a></h3>
<div class="table-wrapper"><table><thead><th>Format version</th><th>Remarks</th></thead><tr><td>1.0</td><td>Introduced in Windows NT 3.1</td></tr>
<tr><td>1.1</td><td>Introduced in Windows NT 3.5, also seen to be used by Windows NT 3.1</td></tr>
<tr><td>1.2</td><td>Introduced in Windows NT 3.51</td></tr>
<tr><td>3.0</td><td>Introduced in Windows 2000</td></tr>
<tr><td>3.1</td><td>Introduced in Windows XP</td></tr>
</table></div>
<blockquote>
<p>Note that the format versions mentioned above are the version as used by NTFS.
Another common versioning schema uses the Windows version, e.g. NTFS 5.0 is the
version of NTFS used on Windows XP which is version 3.1 in schema mentioned
above.</p>
</blockquote>
<blockquote>
<p>Note Windows does not necessarily uses the latest version, e.g. Windows 10
(1809) has been observed to use NTFS version 1.2 for 64k cluster block size.</p>
</blockquote>
<h3 id="terminology-5"><a class="header" href="#terminology-5">Terminology</a></h3>
<h4 id="cluster"><a class="header" href="#cluster">Cluster</a></h4>
<p>NTFS refers to it file system blocks as clusters. Note that these are not the
same as the physical clusters of a harddisk. For clarity this document will
refer to these as cluster blocks. In other sources they are also referred to as
logical clusters.</p>
<p>Typically a cluster block is 8 sectors (or 8 x 512 = 4096 bytes) in size. A
cluster block number is relative to the start of the boot record.</p>
<h4 id="virtual-cluster"><a class="header" href="#virtual-cluster">Virtual cluster</a></h4>
<p>The term virtual cluster refers to cluster blocks which are relative to the
start of a data stream.</p>
<h4 id="long-and-short-file-name"><a class="header" href="#long-and-short-file-name">Long and short (file) name</a></h4>
<p>In Windows terminology the name of a file (or directory) can either be short or
long. The short name is an equivalent of the filename in the (DOS) 8.3 format.
The long name is actual the (full) name of the file. The term long refers to
the aspect that the name is longer than the short variant. Because most
documentation refer to the (full) name as the long name, for clarity sake so
will this document.</p>
<h4 id="metadata-files"><a class="header" href="#metadata-files">Metadata files</a></h4>
<p>NTFS uses the Master File Table (MFT) to store information about files and
directories. The MFT entries reference the different volume and file system
metadata. There are several predefined metadata files.</p>
<p>The following metadata files are predefined and use a fixed MFT entry number.</p>
<div class="table-wrapper"><table><thead><th>MFT entry number</th><th>Filename</th><th>Description</th></thead><tr><td>0</td><td>"$MFT"</td><td>Master File Table</td></tr>
<tr><td>1</td><td>"$MFTMirr"</td><td>Back up of the first 4 entries of the Master File Table</td></tr>
<tr><td>2</td><td>"$LogFile"</td><td>Metadata transaction journal</td></tr>
<tr><td>3</td><td>"$Volume"</td><td>Volume information</td></tr>
<tr><td>4</td><td>"$AttrDef"</td><td>MFT entry attribute definitions</td></tr>
<tr><td>5</td><td>"."</td><td>Root directory</td></tr>
<tr><td>6</td><td>"$Bitmap"</td><td>Cluster block allocation bitmap</td></tr>
<tr><td>7</td><td>"$Boot"</td><td>Boot record (or boot code)</td></tr>
<tr><td>8</td><td>"$BadClus"</td><td>Bad clusters</td></tr>
<tr><td colspan="3"> <em>Used in NTFS version 1.2 and earlier</em></tr>
<tr><td>9</td><td>"$Quota"</td><td>Quota information</td></tr>
<tr><td colspan="3"> <em>Used in NTFS version 3.0 and later</em></tr>
<tr><td>9</td><td>"$Secure"</td><td>Security and access control information</td></tr>
<tr><td colspan="3"> <em>Common</em></tr>
<tr><td>10</td><td>"$UpCase"</td><td>Case folding mappings</td></tr>
<tr><td>11</td><td>"$Extend"</td><td>A directory containing extended metadata files</td></tr>
<tr><td>12-15</td><td></td><td>Unknown (Reserved), which are marked as in-use but are empty</td></tr>
<tr><td>16-23</td><td></td><td>Unused, which are marked as unused</td></tr>
<tr><td colspan="3"> <em>Used in NTFS version 3.0 and later</em></tr>
<tr><td>24</td><td>"$Extend$Quota"</td><td>Quota information</td></tr>
<tr><td>25</td><td>"$Extend$ObjId"</td><td>Unique file identifiers for distributed link tracking</td></tr>
<tr><td>26</td><td>"$Extend$Reparse"</td><td>Backreferences to reparse points</td></tr>
<tr><td colspan="3"> <em><a href="ntfs.html#transactional_ntfs">Transactional NTFS metadata files</a>, which have been observed in Windows Vista and later</em></tr>
<tr><td>27</td><td>"$Extend$RmMetadata"</td><td>Resource manager metadata directory</td></tr>
<tr><td>28</td><td>"$Extend$RmMetadata$Repair"</td><td>Repair information</td></tr>
<tr><td>29 or 30</td><td>"$Extend$RmMetadata$TxfLog"</td><td>Transactional NTFS (TxF) log metadata directory</td></tr>
<tr><td>30 or 31</td><td>"$Extend$RmMetadata$Txf"</td><td>Transactional NTFS (TxF) metadata directory</td></tr>
<tr><td>31 or 32</td><td>"$Extend$RmMetadata$TxfLog$Tops"</td><td>TxF Old Page Stream (TOPS) file, which is used to store data that has been overwritten inside a currently active transaction</td></tr>
<tr><td>32 or 33</td><td>"$Extend$RmMetadata$TxfLog$TxfLog.blf"</td><td>Transactional NTFS (TxF) base log metadata file</td></tr>
<tr><td colspan="3"> <em>Observed in Windows 10 and later</em></tr>
<tr><td>29</td><td>"$Extend$Deleted"</td><td>Temporary location for files that have an open handle but a request has been made to delete them</td></tr>
<tr><td colspan="3"> <em>Common</em></tr>
<tr><td></td><td>...</td><td>A file or directory</td></tr>
</table></div>
<p>The following metadata files are predefined, however the MFT entry number is
commonly used but not fixed.</p>
<div class="table-wrapper"><table><thead><th>MFT entry number</th><th>Filename</th><th>Description</th></thead><tr><td></td><td>"$Extend$UsnJrnl"</td><td><a href="ntfs.html#usn_change_journal">USN change journal</a></td></tr>
</table></div>
<h2 id="the-boot-record"><a class="header" href="#the-boot-record">The boot record</a></h2>
<p>The boot record is stored at the start of the volume (in the $Boot metadata
file) and contains:</p>
<ul>
<li>the file system signature</li>
<li>the BIOS parameter block</li>
<li>the boot loader</li>
</ul>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>3</td><td></td><td>Boot entry point</td></tr>
<tr><td>3</td><td>8</td><td>"NTFS\x20\x20\x20\x20"</td><td>File system signature (Also known as OEM identifier or dummy identifier)</td></tr>
<tr><td colspan="4"> <em>DOS version 2.0 BIOS parameter block (BPB)</em></tr>
<tr><td>11</td><td>2</td><td></td><td>Bytes per sector. Note that the following values are supported by mkntfs: 256, 512, 1024, 2048 and 4096</td></tr>
<tr><td>13</td><td>1</td><td></td><td>Number of sectors per cluster block</td></tr>
<tr><td>14</td><td>2</td><td>0</td><td>Unknown (Reserved Sectors), which is not used by NTFS and must be 0</td></tr>
<tr><td>16</td><td>1</td><td>0</td><td>Number of cluster block allocation tables, which is not used by NTFS and must be 0</td></tr>
<tr><td>17</td><td>2</td><td>0</td><td>Number of root directory entries, which is not not used by NTFS and must be 0</td></tr>
<tr><td>19</td><td>2</td><td>0</td><td>Number of sectors (16-bit), which is not used by NTFS must be 0</td></tr>
<tr><td>21</td><td>1</td><td></td><td><a href="ntfs.html#media_descriptor">Media descriptor</a></td></tr>
<tr><td>22</td><td>2</td><td>0</td><td>Cluster block allocation table size (16-bit) in number of sectors, which is not used by NTFS and must be 0</td></tr>
<tr><td colspan="4"> <em>DOS version 3.4 BIOS parameter block (BPB)</em></tr>
<tr><td>24</td><td>2</td><td>0x3f</td><td>Sectors per track, which is not used by NTFS</td></tr>
<tr><td>26</td><td>2</td><td>0xff</td><td>Number of heads, which is not used by NTFS</td></tr>
<tr><td>28</td><td>4</td><td>0x3f</td><td>Number of hidden sectors, which is not used by NTFS</td></tr>
<tr><td>32</td><td>4</td><td>0x00</td><td>Number of sectors (32-bit), which is not used by NTFS must be 0</td></tr>
<tr><td colspan="4"> <em>NTFS version 8.0 BIOS parameter block (BPB) or extended BPB, which was introduced in Windows NT 3.1</em></tr>
<tr><td>36</td><td>1</td><td>0x80</td><td>Unknown (Disc unit number), which is not used by NTFS</td></tr>
<tr><td>37</td><td>1</td><td>0x00</td><td>Unknown (Flags), which is not used by NTFS</td></tr>
<tr><td>38</td><td>1</td><td>0x80</td><td>Unknown (BPB version signature byte), which is not used by NTFS</td></tr>
<tr><td>39</td><td>1</td><td>0x00</td><td>Unknown (Reserved), which is not used by NTFS</td></tr>
<tr><td>40</td><td>8</td><td></td><td>Number of sectors (64-bit)</td></tr>
<tr><td>48</td><td>8</td><td></td><td>Master File Table (MFT) cluster block number</td></tr>
<tr><td>56</td><td>8</td><td></td><td>Mirror MFT cluster block number</td></tr>
<tr><td>64</td><td>4</td><td></td><td>MFT entry size</td></tr>
<tr><td>68</td><td>4</td><td></td><td>Index entry size</td></tr>
<tr><td>72</td><td>8</td><td></td><td>Volume serial number</td></tr>
<tr><td>80</td><td>4</td><td>0</td><td>Checksum, which is not used by NTFS</td></tr>
<tr><td colspan="4">  </tr>
<tr><td>84</td><td>426</td><td></td><td>Boot code</td></tr>
<tr><td>510</td><td>2</td><td>"\x55\xaa"</td><td>The (boot) signature</td></tr>
</table></div>
<h3 id="boot-entry-point"><a class="header" href="#boot-entry-point">Boot entry point</a></h3>
<p>The boot entry point often contains a jump instruction to the boot code at
offset 84 followed by a no-operation, e.g.</p>
<pre><code>eb52   jmp 0x52
90     nop
</code></pre>
<h3 id="number-of-sectors-per-cluster-block"><a class="header" href="#number-of-sectors-per-cluster-block">Number of sectors per cluster block</a></h3>
<p>The number of sectors per cluster block value as used by mkntfs is defined as
following:</p>
<ul>
<li>Values 0 to 128 represent sizes of 0 to 128 sectors.</li>
<li>Values 244 to 255 represent sizes of <code>2^(256-n)</code> sectors.</li>
<li>Other values are unknown.</li>
</ul>
<h3 id="cluster-block-size"><a class="header" href="#cluster-block-size">Cluster block size</a></h3>
<p>The cluster block size can be determined as following:</p>
<pre><code>cluster block size = bytes per sector x sectors per cluster block
</code></pre>
<p>Different NTFS implementations support different cluster block sizes. Known
supported cluster block size:</p>
<div class="table-wrapper"><table><thead><th>Cluster block size</th><th>Bytes per sector</th><th>Supported by</th></thead><tr><td>256</td><td>256</td><td>mkntfs</td></tr>
<tr><td>512</td><td>256 - 512</td><td>mkntfs, ntfs3g, Windows</td></tr>
<tr><td>1024</td><td>256 - 1024</td><td>mkntfs, ntfs3g, Windows</td></tr>
<tr><td>2048</td><td>256 - 2048</td><td>mkntfs, ntfs3g, Windows</td></tr>
<tr><td>4096</td><td>256 - 4096</td><td>mkntfs, ntfs3g, Windows</td></tr>
<tr><td>8192</td><td>256 - 4096</td><td>mkntfs, ntfs3g, Windows</td></tr>
<tr><td>16K (16384)</td><td>256 - 4096</td><td>mkntfs, ntfs3g, Windows</td></tr>
<tr><td>32K (32768)</td><td>256 - 4096</td><td>mkntfs, ntfs3g, Windows</td></tr>
<tr><td>64K (65536)</td><td>256 - 4096</td><td>mkntfs, ntfs3g, Windows</td></tr>
<tr><td>128K (131072)</td><td>256 - 4096</td><td>mkntfs, ntfs3g, Windows 10 (1903)</td></tr>
<tr><td>256K (262144)</td><td>256 - 4096</td><td>mkntfs, ntfs3g, Windows 10 (1903)</td></tr>
<tr><td>512K (524288)</td><td>256 - 4096</td><td>mkntfs, ntfs3g, Windows 10 (1903)</td></tr>
<tr><td>1M (1048576)</td><td>256 - 4096</td><td>mkntfs, ntfs3g, Windows 10 (1903)</td></tr>
<tr><td>2M (2097152)</td><td>512 - 4096</td><td>mkntfs, ntfs3g, Windows 10 (1903)</td></tr>
</table></div>
<blockquote>
<p>Note that Windows 10 (1903) requires the partition containing the NTFS file
system to be aligned with the cluster block size. For example for a cluster
block size of 128k the partition must 128 KiB aligned. The default partition
partition alignment appears to be 64 KiB.</p>
</blockquote>
<p>mkntfs restricts the cluster size to:</p>
<pre><code>bytes per sector &gt;= cluster size &gt; 4096 x bytes per sector
</code></pre>
<h3 id="master-file-table-mft-offset"><a class="header" href="#master-file-table-mft-offset">Master File Table (MFT) offset</a></h3>
<p>The Master File Table (MFT) offset can be determined as following:</p>
<pre><code>MFT offset = boot record offset + ( MFT cluster block number x Cluster block size )
</code></pre>
<p>The lower 32-bit part of the NTFS volume serial number is the Windows API
(WINAPI) volume serial number. This can be determined by comparing the output
of:</p>
<pre><code>fsutil fsinfo volumeinfo C:
fsutil fsinfo ntfsinfo C:
</code></pre>
<p>Often the total number of sectors in the boot record will be smaller than the
underlying partition. A (nearly identical) backup of the boot record is stored
in last sector of cluster block, that follows the last cluster block of the
volume. Often this is the 512 bytes after the last sector of the volume, but
not necessarily. The backup boot record is not included in the total number of
sectors.</p>
<h3 id="master-file-table-mft-and-index-entry-size"><a class="header" href="#master-file-table-mft-and-index-entry-size">Master File Table (MFT) and index entry size</a></h3>
<p>The Master File Table (MFT) entry size and index entry size are defined as
following:</p>
<ul>
<li>Values 0 to 127 represent sizes of 0 to 127 cluster blocks.</li>
<li>Values 128 to 255 represent sizes of <code>2^(256-n)</code> bytes; or <code>2^(-n)</code> if considered as a signed byte.</li>
<li>Other values are not considered valid.</li>
</ul>
<h3 id="bitlocker-drive-encryption-bde"><a class="header" href="#bitlocker-drive-encryption-bde">BitLocker Drive Encryption (BDE)</a></h3>
<p>BitLocker Drive Encryption (BDE) uses the file system signature: "-FVE-FS-".
Where FVE is an abbreviation of Full Volume Encryption.</p>
<p>The data structures of BDE on Windows Vista and 7 differ.</p>
<p>A Windows Vista BDE volume starts with:</p>
<pre><code>eb 52 90 2d 46 56 45 26 46 53 2d
</code></pre>
<p>A Windows 7 BDE volume starts with:</p>
<pre><code>eb 58 90 2d 46 56 45 26 46 53 2d
</code></pre>
<p>BDE is largely a stand-alone but has some integration with NTFS.</p>
<p>TODO: link to BDE format documentation</p>
<h3 id="volume-shadow-snapshots-vss"><a class="header" href="#volume-shadow-snapshots-vss">Volume Shadow Snapshots (VSS)</a></h3>
<p>Volume Shadow Snapshots (VSS) uses the GUID
3808876b-c176-4e48-b7ae-04046e6cc752 (stored in little-endian) to identify its
data.</p>
<p>VSS is largely a stand-alone but has some integration with NTFS.</p>
<p>TODO: link to VSS format documentation</p>
<h3 id="media-descriptor"><a class="header" href="#media-descriptor"><a name="media_descriptor"></a>Media descriptor</a></h3>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0.0</td><td>1 bit</td><td></td><td>Sides, where single-sided (0) and double-sided (1)</td></tr>
<tr><td>0.1</td><td>1 bit</td><td></td><td>Track size, where 9 sectors per track (0) and 8 sectors per track (1)</td></tr>
<tr><td>0.2</td><td>1 bit</td><td></td><td>Density, where 80 tracks (0) and 40 tracks (1)</td></tr>
<tr><td>0.3</td><td>1 bit</td><td></td><td>Type, where Fixed disc (0) and Removable disc (1)</td></tr>
<tr><td>0.4</td><td>4 bits</td><td></td><td>Always set to 1</td></tr>
</table></div>
<h2 id="the-boot-loader"><a class="header" href="#the-boot-loader">The boot loader</a></h2>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>512</td><td></td><td></td><td>Windows NT (boot) loader (NTLDR/BOOTMGR)</td></tr>
</table></div>
<h2 id="the-master-file-table-mft"><a class="header" href="#the-master-file-table-mft">The Master File Table (MFT)</a></h2>
<p>The MFT consist of an array of MFT entries. The offset of the MFT table can be
found in the volume header and the size of the MFT is defined by the MFT entry
of the $MFT metadata file.</p>
<blockquote>
<p>Note that the MFT can consists of multiple data ranges, defined by the data
runs in the $MFT metadata file.</p>
</blockquote>
<h3 id="mft-entry"><a class="header" href="#mft-entry">MFT entry</a></h3>
<p>Although the size of a MFT entry is defined in the volume header is commonly
1024 bytes in size and consists of:</p>
<ul>
<li>The MFT entry header</li>
<li><a href="ntfs.html#fix_up_values">The fix-up values</a></li>
<li>An array of MFT attribute values</li>
<li>Padding, which should contain 0-byte values</li>
</ul>
<blockquote>
<p>Note that the MFT entry can be filled entirely with 0-byte values. Seen in
Windows XP for MFT entry numbers 16 - 23.</p>
</blockquote>
<h4 id="mft-entry-header"><a class="header" href="#mft-entry-header">MFT entry header</a></h4>
<p>The MFT entry header (FILE_RECORD_SEGMENT_HEADER) is 42 or 48 bytes in size
and consists of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td colspan="4"> <em>MULTI_SECTOR_HEADER</em></tr>
<tr><td>0</td><td>4</td><td>"BAAD", "FILE"</td><td>Signature</td></tr>
<tr><td>4</td><td>2</td><td></td><td>The fix-up values (or update sequence array) offset, which contain an offset relative from the start of the MFT entry.</td></tr>
<tr><td>6</td><td>2</td><td></td><td>The number of fix-up values (or update sequence array size)</td></tr>
<tr><td colspan="4">  </tr>
<tr><td>8</td><td>8</td><td></td><td>Metadata transaction journal sequence number, which contains a $LogFile Sequence Number (LSN)</td></tr>
<tr><td>16</td><td>2</td><td></td><td>Sequence (number)</td></tr>
<tr><td>18</td><td>2</td><td></td><td>Reference (link) count</td></tr>
<tr><td>20</td><td>2</td><td></td><td>Attributes offset (or first attribute offset), which contains an offset relative from the start of the MFT entry</td></tr>
<tr><td>22</td><td>2</td><td></td><td><a href="ntfs.html#mft_entry_flags">MFT entry flags</a></td></tr>
<tr><td>24</td><td>4</td><td></td><td>Used size in bytes</td></tr>
<tr><td>28</td><td>4</td><td></td><td>MFT entry size in bytes</td></tr>
<tr><td>32</td><td>8</td><td></td><td><a href="ntfs.html#file_reference">Base record file reference</a></td></tr>
<tr><td>40</td><td>2</td><td></td><td>First available attribute identifier</td></tr>
<tr><td colspan="4"> <em>If NTFS version is 3.0</em></tr>
<tr><td>42</td><td>2</td><td></td><td>Unknown (wfixupPattern)</td></tr>
<tr><td>44</td><td>4</td><td></td><td>Unknown</td></tr>
<tr><td colspan="4"> <em>If NTFS version is 3.1</em></tr>
<tr><td>42</td><td>2</td><td></td><td>Unknown (wfixupPattern)</td></tr>
<tr><td>44</td><td>4</td><td></td><td>MFT entry number</td></tr>
</table></div>
<h5 id="baad-signature"><a class="header" href="#baad-signature">"BAAD" signature</a></h5>
<p>According to <a href="https://flatcap.github.io/linux-ntfs/ntfs/">NTFS documentation</a> if
during chkdsk, when a multi-sector item is found where the multi-sector header
does not match the values at the end of the sector, it marks the item as "BAAD"
and fill it with 0-byte values except for a fix-up value at the end of the first
sector of the item. The "BAAD" signature has been seen to be used on Windows NT4
and XP.</p>
<h5 id="sequence-number"><a class="header" href="#sequence-number">Sequence number</a></h5>
<p>According to <a href="https://learn.microsoft.com/en-us/windows/win32/devnotes/file-record-segment-header">FILE_RECORD_SEGMENT_HEADER structure</a>
the sequence number is incremented each time that a file record segment is
freed; it is 0 if the segment is not used.</p>
<h5 id="base-record-file-reference"><a class="header" href="#base-record-file-reference">Base record file reference</a></h5>
<p>The base record file reference is used to store additional attributes for
another MFT entry, e.g. for attribute lists.</p>
<h4 id="mft-entry-flags"><a class="header" href="#mft-entry-flags"><a name="mft_entry_flags"></a>MFT entry flags</a></h4>
<div class="table-wrapper"><table><thead><th>Value</th><th>Identifier</th><th>Description</th></thead><tr><td>0x0001</td><td>FILE_RECORD_SEGMENT_IN_USE, MFT_RECORD_IN_USE</td><td>In use</td></tr>
<tr><td>0x0002</td><td>FILE_FILE_NAME_INDEX_PRESENT, FILE_NAME_INDEX_PRESENT, MFT_RECORD_IS_DIRECTORY</td><td>Has file name (or $I30) index. When this flag is set the file entry represents a directory</td></tr>
<tr><td>0x0004</td><td>MFT_RECORD_IN_EXTEND</td><td>Unknown. According to <a href="https://ultradefrag.net/doc/man/ntfs/ntfs_layout.h.html">ntfs_layout.h</a> this is set for all system files present in the $Extend directory</td></tr>
<tr><td>0x0008</td><td>MFT_RECORD_IS_VIEW_INDEX</td><td>Is index. When this flag is set the file entry represents an index. According to <a href="https://ultradefrag.net/doc/man/ntfs/ntfs_layout.h.html">ntfs_layout.h</a> this is set for all indices other than $I30</td></tr>
</table></div>
<h4 id="the-fix-up-values"><a class="header" href="#the-fix-up-values"><a name="fix_up_values"></a>The fix-up values</a></h4>
<p>The fix-up values are of variable size and consists of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>2</td><td></td><td>Fix-up placeholder value</td></tr>
<tr><td>2</td><td>2 x number of fix-up values</td><td></td><td>Fix-up (original) value array</td></tr>
</table></div>
<p>On disk the last 2 bytes for each 512 byte block is replaced by the fix-up
placeholder value. The original value is stored in the corresponding fix-up
(original) value array entry.</p>
<blockquote>
<p>Note that there can be more fix-up values than the number of 512 byte blocks
in the data.</p>
</blockquote>
<p>According to <a href="https://learn.microsoft.com/en-us/windows/win32/devnotes/multi-sector-header">MULTI_SECTOR_HEADER structure</a>
the update sequence array must end before the last USHORT value in the first
sector. It also states that the update sequence array size value contains the
number of bytes, but based on analysis of data samples it seems to be more
likely to the number of words.</p>
<p>In NT4 (version 1.2) the MFT entry is 42 bytes in size and the fix-up values
are stored at offset 42. This is likely where the name wfixupPattern originates
from.</p>
<p>TODO: provide examples on applying the fix-up values.</p>
<h3 id="the-file-reference"><a class="header" href="#the-file-reference"><a name="file_reference"></a>The file reference</a></h3>
<p>The file reference (FILE_REFERENCE or MFT_SEGMENT_REFERENCE) is 8 bytes in size
and consists of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>6</td><td></td><td>MFT entry number</td></tr>
<tr><td>6</td><td>2</td><td></td><td>Sequence number</td></tr>
</table></div>
<blockquote>
<p>Note that the index value in the MFT entry is 32-bit in size.</p>
</blockquote>
<h3 id="mft-attribute"><a class="header" href="#mft-attribute">MFT attribute</a></h3>
<p>The MFT attribute consist of:</p>
<ul>
<li>the attribute header</li>
<li>the attribute resident or non-resident data</li>
<li>the <a href="ntfs.html#attribute_name">attribute name</a></li>
<li>Unknown data, likely alignment padding (4-byte alignment)</li>
<li>resident attribute data or non-resident attribute data runs</li>
<li>alignment padding (8-byte alignment), can contain remnant data</li>
</ul>
<h4 id="mft-attribute-header"><a class="header" href="#mft-attribute-header">MFT attribute header</a></h4>
<p>The MFT attribute header (ATTRIBUTE_RECORD_HEADER) is 16 bytes in size and
consists of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>4</td><td></td><td><a href="ntfs.html#attribute_types">Attribute type</a> (or type code)</td></tr>
<tr><td>4</td><td>4</td><td></td><td>Attribute size (or record length), which includes the 8 bytes of the attribute type and size</td></tr>
<tr><td>8</td><td>1</td><td></td><td>Non-resident flag (or form code), where RESIDENT_FORM (0) and NONRESIDENT_FORM (1)</td></tr>
<tr><td>9</td><td>1</td><td></td><td>Name size (or name length), which contains the number of characters without the end-of-string character</td></tr>
<tr><td>10</td><td>2</td><td></td><td>Name offset, which contains an offset relative from the start of the MFT attribute</td></tr>
<tr><td>12</td><td>2</td><td></td><td><a href="ntfs.html#mft_attribute_data_flags">Attribute data flags</a></td></tr>
<tr><td>14</td><td>2</td><td></td><td>Attribute identifier (or instance), which contains an unique identifier to distinguish between attributes that contain segmented data.</td></tr>
</table></div>
<h4 id="mft-attribute-data-flags"><a class="header" href="#mft-attribute-data-flags"><a name="mft_attribute_data_flags"></a>MFT attribute data flags</a></h4>
<div class="table-wrapper"><table><thead><th>Value</th><th>Identifier</th><th>Description</th></thead><tr><td>0x0001</td><td></td><td>Is LZNT1 compressed</td></tr>
<tr><td></td><td></td><td></td></tr>
<tr><td>0x00ff</td><td>ATTRIBUTE_FLAG_COMPRESSION_MASK</td><td></td></tr>
<tr><td></td><td></td><td></td></tr>
<tr><td>0x4000</td><td>ATTRIBUTE_FLAG_ENCRYPTED</td><td>Is encrypted</td></tr>
<tr><td>0x8000</td><td>ATTRIBUTE_FLAG_SPARSE</td><td>Is sparse</td></tr>
</table></div>
<p>TODO: determine the meaning of compression flag in the context of resident
$INDEX_ROOT. Do the data flags have a different meaning for different
attributes?</p>
<h4 id="resident-mft-attribute"><a class="header" href="#resident-mft-attribute">Resident MFT attribute</a></h4>
<p>The resident MFT attribute data is present when the non-resident flag is not
set (0). The resident data is 8 bytes in size and consists of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>4</td><td></td><td>Data size (or value length)</td></tr>
<tr><td>4</td><td>2</td><td></td><td>Data offset (or value size), which contains an offset relative from the start of the MFT attribute</td></tr>
<tr><td>6</td><td>1</td><td></td><td>Indexed flag</td></tr>
<tr><td>7</td><td>1</td><td>0x00</td><td>Unknown (Padding)</td></tr>
</table></div>
<p>TODO: determine the meaning of indexed flag bits, other than the LSB</p>
<h4 id="non-resident-mft-attribute"><a class="header" href="#non-resident-mft-attribute">Non-resident MFT attribute</a></h4>
<p>The non-resident MFT attribute data is present when the non-resident flag is
set (1). The non-resident data is 48 or 56 bytes in size and consists of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>8</td><td></td><td>First (or lowest) Virtual Cluster Number (VCN) of the data</td></tr>
<tr><td>8</td><td>8</td><td></td><td>Last (or highest) Virtual Cluster Number (VCN) of the data</td></tr>
<tr><td>16</td><td>2</td><td></td><td>Data runs offset (or mappings pairs offset), which contains an offset relative from the start of the MFT attribute</td></tr>
<tr><td>18</td><td>2</td><td></td><td>Compression unit size, which contains the compression unit size as <code>2^(n)</code> number of cluster blocks.</td></tr>
<tr><td>20</td><td>4</td><td></td><td>Unknown (Padding)</td></tr>
<tr><td>24</td><td>8</td><td></td><td>Allocated data size (or allocated length), which contains the allocated data size in number of bytes. This value is not valid if the first VCN is nonzero.</td></tr>
<tr><td>32</td><td>8</td><td></td><td>Data size (or file size), which contains the data size in number of bytes. This value is not valid if the first VCN is nonzero.</td></tr>
<tr><td>40</td><td>8</td><td></td><td>Valid data size (or valid data length), which contains the valid data size in number of bytes. This value is not valid if the first VCN is nonzero.</td></tr>
<tr><td colspan="4"> <em>If compression unit size &gt; 0</em></tr>
<tr><td>48</td><td>8</td><td></td><td>Compressed data size.</td></tr>
</table></div>
<blockquote>
<p>Note that the total size of the data runs should be larger or equal to the
data size.</p>
</blockquote>
<blockquote>
<p>Note that Windows will fill data ranges beyond the valid data size with 0-byte
values. The data size remains unchanged. This applies to compressed and
uncompressed data. If the first VCN is zero a valid data size of 0 represents
a file entirely filled with 0-byte values.</p>
</blockquote>
<p>TODO: determine the meaning of a VCN of -1</p>
<p>For more information about compressed MFT attributes see <a href="ntfs.html#compression">compression</a>.</p>
<h4 id="attribute-name"><a class="header" href="#attribute-name"><a name="attribute_name"></a>Attribute name</a></h4>
<p>The attribute name is of variable size and consists of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>...</td><td></td><td>Name, which contains an UCS-2 little-endian string without end-of-string character</td></tr>
</table></div>
<h4 id="data-runs"><a class="header" href="#data-runs">Data runs</a></h4>
<p>The data runs are stored in a variable size (data) runlist. This runlist
consists of runlist elements.</p>
<p>A runlist element is of variable size and consists of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0.0 </td><td>4 bits</td><td></td><td>Number of cluster blocks value size, which contains the number of bytes used to store the data run size</td></tr>
<tr><td>0.4</td><td>4 bits</td><td></td><td>Cluster block number value size, which contains the number of bytes used to store the data run size</td></tr>
<tr><td>1</td><td>Size value size</td><td></td><td>Data run number of cluster blocks, which contains the number of cluster blocks</td></tr>
<tr><td>...</td><td>Cluster block number value size</td><td></td><td>Data run cluster block number</td></tr>
</table></div>
<p>The data run cluster block number is a singed value, where the MSB is the
singed bit, e.g. if the data run cluster block contains "dbc8" it corresponds
to the 64-bit value 0xffffffffffffdbc8.</p>
<p>The first data run offset contains the absolute cluster block number where
successive data run offsets are relative to the last data run offset.</p>
<blockquote>
<p>Note that the cluster block number byte size is the first nibble when reading
the byte stream, but here it is represented as the upper nibble of the first
byte.</p>
</blockquote>
<p>The last runlist element is (0, 0), which is stored as a 0-byte value.</p>
<p>According to <a href="https://flatcap.github.io/linux-ntfs/ntfs/">NTFS documentation</a>
the size of the runlist is rounded up to the next multitude of 4 bytes, but
based on analysis of data samples it seems that the size of the trailing data
can be even larger than 3 and are not always 0-byte values.</p>
<p>TODO: provide examples of data runs</p>
<h5 id="sparse-data-runs"><a class="header" href="#sparse-data-runs">Sparse data runs</a></h5>
<p>The MFT attribute data flag (ATTRIBUTE_FLAG_SPARSE) indicates if the data
stream is sparse or not, where the runlist can contain both sparse and
non-sparse data runs.</p>
<p>A sparse data run has a cluster block number value size of 0, representing
there is no offset (cluster block number). A sparse data run is filled with
0-byte values.</p>
<p>Compressed data streams also define sparse data runs without setting the
ATTRIBUTE_FLAG_SPARSE flag.</p>
<blockquote>
<p>Note that $BadClus:$Bad also defines a data run with a cluster block number
value size of 0, without setting the ATTRIBUTE_FLAG_SPARSE flag.</p>
</blockquote>
<h5 id="compresssed-data-runs"><a class="header" href="#compresssed-data-runs">Compresssed data runs</a></h5>
<p>The MFT attribute data flags (0x00ff) indicate if the data stream is compressed
or not.</p>
<blockquote>
<p>Note that Windows supports compressed data runs for NTFS file systems with a
cluster block size of 4096 bytes or less.</p>
</blockquote>
<blockquote>
<p>Note that Windows 10 supports Windows Overlay Filter (WOF) compressed data,
which stores the LZXPRESS Huffman or LZX compressed data in alternate data
stream named WofCompressedData and links it to the default data stream using
a reparse point.</p>
</blockquote>
<p>The data is stored in compression unit blocks. A compression unit typically
consists of 16 cluster blocks. However the actual value is stored in the
non-resident MFT attribute.</p>
<p>Also see <a href="ntfs.html#compression">compression</a>.</p>
<h2 id="the-attributes"><a class="header" href="#the-attributes">The attributes</a></h2>
<h3 id="known-attribute-types"><a class="header" href="#known-attribute-types"><a name="attribute_types"></a>Known attribute types</a></h3>
<p>The attribute types are stored in the <a href="ntfs.html#attribute_definitions">$AttrDef metadata file</a>.</p>
<div class="table-wrapper"><table><thead><th>Value</th><th>Identifier</th><th>Description</th></thead><tr><td>0x00000000</td><td></td><td>Unused</td></tr>
<tr><td>0x00000010</td><td>$STANDARD_INFORMATION</td><td>Standard information</td></tr>
<tr><td>0x00000020</td><td>$ATTRIBUTE_LIST</td><td>Attributes list</td></tr>
<tr><td>0x00000030</td><td>$FILE_NAME</td><td>The file or directory name</td></tr>
<tr><td colspan="3"> <em>Used in NTFS version 1.2 and earlier</em></tr>
<tr><td>0x00000040</td><td>$VOLUME_VERSION</td><td>Volume version</td></tr>
<tr><td colspan="3"> <em>Used in NTFS version 3.0 and later</em></tr>
<tr><td>0x00000040</td><td>$OBJECT_ID</td><td>Object identifier</td></tr>
<tr><td colspan="3"> <em>Common</em></tr>
<tr><td>0x00000050</td><td>$SECURITY_DESCRIPTOR</td><td>Security descriptor</td></tr>
<tr><td>0x00000060</td><td>$VOLUME_NAME</td><td>Volume label</td></tr>
<tr><td>0x00000070</td><td>$VOLUME_INFORMATION</td><td>Volume information</td></tr>
<tr><td>0x00000080</td><td>$DATA</td><td>Data stream</td></tr>
<tr><td>0x00000090</td><td>$INDEX_ROOT</td><td>Index root</td></tr>
<tr><td>0x000000a0</td><td>$INDEX_ALLOCATION</td><td>Index allocation</td></tr>
<tr><td>0x000000b0</td><td>$BITMAP</td><td>Bitmap</td></tr>
<tr><td colspan="3"> <em>Used in NTFS version 1.2 and earlier</em></tr>
<tr><td>0x000000c0</td><td>$SYMBOLIC_LINK</td><td>Symbolic link</td></tr>
<tr><td colspan="3"> <em>Used in NTFS version 3.0 and later</em></tr>
<tr><td>0x000000c0</td><td>$REPARSE_POINT</td><td>Reparse point</td></tr>
<tr><td colspan="3"> <em>Common</em></tr>
<tr><td>0x000000d0</td><td>$EA_INFORMATION</td><td>(HPFS) extended attribute information</td></tr>
<tr><td>0x000000e0</td><td>$EA</td><td>(HPFS) extended attribute</td></tr>
<tr><td colspan="3"> <em>Used in NTFS version 1.2 and earlier</em></tr>
<tr><td>0x000000f0</td><td>$PROPERTY_SET</td><td>Property set</td></tr>
<tr><td colspan="3"> <em>Used in NTFS version 3.0 and later</em></tr>
<tr><td>0x00000100</td><td>$LOGGED_UTILITY_STREAM</td><td>Logged utility stream</td></tr>
<tr><td colspan="3"> <em>Common</em></tr>
<tr><td></td><td></td><td></td></tr>
<tr><td>0x00001000</td><td></td><td>First user defined attribute</td></tr>
<tr><td></td><td></td><td></td></tr>
<tr><td>0xffffffff</td><td></td><td>End of attributes marker</td></tr>
</table></div>
<h3 id="attribute-chains"><a class="header" href="#attribute-chains"><a name="attribute_chains"></a>Attribute chains</a></h3>
<p>Multiple attributes can be chained to make up a single attribute data stream,
e.g. the attributes:</p>
<ol>
<li>$INDEX_ALLOCATION ($I30) VCN: 0</li>
<li>$INDEX_ALLOCATION ($I30) VCN: 596</li>
</ol>
<p>The first attribute will contain the size of the data defined by all the
attributes and successive attributes should have a size of 0.</p>
<p>It is assumed that the attributes in a chain must be continuous and defined
in-order.</p>
<h3 id="the-standard-information-attribute"><a class="header" href="#the-standard-information-attribute">The standard information attribute</a></h3>
<p>The standard information attribute ($STANDARD_INFORMATION) contains the basic
file entry metadata. It is stored as a resident MFT attribute.</p>
<p>The standard information data (STANDARD_INFORMATION) is either 48 or 72 bytes
in size and consists of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>8</td><td></td><td>Creation date and time, which contains a FILETIME</td></tr>
<tr><td>8</td><td>8</td><td></td><td>Last modification (or last written) dat and time, which contains a FILETIME</td></tr>
<tr><td>16</td><td>8</td><td></td><td>MFT entry last modification date and time, which contains a FILETIME</td></tr>
<tr><td>24</td><td>8</td><td></td><td>Last access date and time, which contains a FILETIME</td></tr>
<tr><td>32</td><td>4</td><td></td><td><a href="ntfs.html#file_attribute_flags">File attribute flags</a></td></tr>
<tr><td>36</td><td>4</td><td></td><td>Unknown (Maximum number of versions)</td></tr>
<tr><td>40</td><td>4</td><td></td><td>Unknown (Version number)</td></tr>
<tr><td>44</td><td>4</td><td></td><td>Unknown (Class identifier)</td></tr>
<tr><td colspan="4"> <em>If NTFS version 3.0 or later</em></tr>
<tr><td>48</td><td>4</td><td></td><td>Owner identifier</td></tr>
<tr><td>52</td><td>4</td><td></td><td>Security descriptor identifier, which contains the entry number in the security ID index ($Secure:$SII). Also see <a href="ntfs.html#access_control">Access Control</a></td></tr>
<tr><td>56</td><td>8</td><td></td><td>Quota charged</td></tr>
<tr><td>64</td><td>8</td><td></td><td>Update Sequence Number (USN)</td></tr>
</table></div>
<blockquote>
<p>Note that MFT entries have been observed without a $STANDARD_INFORMATION
attribute, but with other attributes such as $FILE_NAME and an $I30 index.</p>
</blockquote>
<h3 id="the-attribute-list-attribute"><a class="header" href="#the-attribute-list-attribute">The attribute list attribute</a></h3>
<p>The attribute list attribute ($ATTRIBUTE_LIST) is used to store MFT attributes
outside the MFT entry, e.g. when the MFT entry is too small to store all the
attributes.</p>
<p>The entries in the list reference the location of MFT attributes. The attribute
list attribute can be stored as either a resident (for a small amount of data)
or non-resident MFT attribute.</p>
<blockquote>
<p>Note that MFT entry 0 also can contain an attribute list and allows to store
listed attributes beyond the first data run.</p>
</blockquote>
<h4 id="the-attribute-list"><a class="header" href="#the-attribute-list">The attribute list</a></h4>
<p>An attribute list consists of:</p>
<ul>
<li>one or more attribute list entries</li>
</ul>
<h4 id="the-attribute-list-entry"><a class="header" href="#the-attribute-list-entry">The attribute list entry</a></h4>
<p>An attribute list entry (ATTRIBUTE_LIST_ENTRY) is of variable size and
consists of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>4</td><td></td><td><a href="ntfs.html#attribute_types">Attribute type</a> (or type code)</td></tr>
<tr><td>4</td><td>2</td><td></td><td>Size (or record length), which includes the 6 bytes of the attribute type and size</td></tr>
<tr><td>6</td><td>1</td><td></td><td>Name size (or name length), which contains the number of characters without the end-of-string character</td></tr>
<tr><td>7</td><td>1</td><td></td><td>Name offset, which contains an offset relative from the start of the attribute list entry</td></tr>
<tr><td>8</td><td>8</td><td></td><td>Data first (or lowest) VCN</td></tr>
<tr><td>16</td><td>8</td><td></td><td><a href="ntfs.html#file_reference">File reference</a> (or segment reference), which contains a reference to the MFT entry that contains (part of) the attribute data</td></tr>
<tr><td>24</td><td>2</td><td></td><td>Attribute identifier (or instance), which contains an unique identifier to distinguish between attributes that contain segmented data.</td></tr>
<tr><td>26</td><td>...</td><td></td><td>Name, which contains an UCS-2 little-endian string without end-of-string character</td></tr>
<tr><td>...</td><td>...</td><td></td><td>alignment padding (8-byte alignment), can contain remnant data</td></tr>
</table></div>
<h3 id="the-file-name-attribute"><a class="header" href="#the-file-name-attribute"><a name="file_name_attribute"></a>The file name attribute</a></h3>
<p>The file name attribute ($FILE_NAME) contains the basic file system information,
like the parent file entry, various date and time values and name. It is stored
as a resident MFT attribute.</p>
<p>The file name data (FILE_NAME) is of variable size and consists of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>8</td><td></td><td><a href="ntfs.html#file_reference">Parent file reference</a></td></tr>
<tr><td>8</td><td>8</td><td></td><td>Creation date and time, which contains a FILETIME</td></tr>
<tr><td>16</td><td>8</td><td></td><td>Last modification (or last written) date and time, which contains a FILETIME</td></tr>
<tr><td>24</td><td>8</td><td></td><td>MFT entry last modification date and time, which contains a FILETIME</td></tr>
<tr><td>32</td><td>8</td><td></td><td>Last access date and time, which contains a FILETIME</td></tr>
<tr><td>40</td><td>8</td><td></td><td>Allocated (or reserved) file size</td></tr>
<tr><td>48</td><td>8</td><td></td><td>Data size</td></tr>
<tr><td>56</td><td>4</td><td></td><td><a href="ntfs.html#file_attribute_flags">File attribute flags</a></td></tr>
<tr><td colspan="4"> <em>If FILE_ATTRIBUTE_REPARSE_POINT is set</em></tr>
<tr><td>60</td><td>4</td><td></td><td><a href="ntfs.html#reparse_point_tag">Reparse point tag</a></td></tr>
<tr><td colspan="4"> <em>If FILE_ATTRIBUTE_REPARSE_POINT is not set</em></tr>
<tr><td>60</td><td>4</td><td></td><td>Unknown (extended attribute data size)</td></tr>
<tr><td colspan="4"> <em>Common</em></tr>
<tr><td>64</td><td>1</td><td></td><td>Name string size, which contains the number of characters without the end-of-string character</td></tr>
<tr><td>65</td><td>1</td><td></td><td>Namespace of the name string</td></tr>
<tr><td>66</td><td>...</td><td></td><td>Name, which contains an UCS-2 little-endian string without end-of-string character</td></tr>
</table></div>
<p>TODO: determine if the allocated file size and file size values contain accurate values when the file name data is stored in a MFT attribute.</p>
<p>An MFT attribute can contain multiple file name attributes, e.g. for a separate
(long) name and short name.</p>
<p>In several cases on a Vista NTFS volume the MFT entry contained both a DOS &amp;
Windows and POSIX name space $FILE_NAME attribute. However the directory entry
index ($I30) of the parent directory only contained the DOS &amp; Windows name.</p>
<p>In case of a hard link the MFT entry will contain additional file name
attributes with the parent file reference of each hard link.</p>
<h4 id="namespace"><a class="header" href="#namespace">Namespace</a></h4>
<div class="table-wrapper"><table><thead><th>Value</th><th>Identifier</th><th>Description</th></thead><tr><td>0</td><td>POSIX</td><td>Case sensitive character set that consists of all Unicode characters except for: "\0" (zero character), "/" (forward slash). The ":" (colon) is valid for NTFS but not for Windows.</td></tr>
<tr><td>1</td><td>FILE_NAME_NTFS, WINDOWS</td><td>Case insensitive sub set of the POSIX character set that consists of all Unicode characters except for: <code>" * / : &lt; &gt; ? \ | +</code>. Note that names cannot end with a "." (dot) or " " (space).</td></tr>
<tr><td>2</td><td>FILE_NAME_DOS, DOS</td><td>Case insensitive sub set of the WINDOWS character set that consists of all upper case ASCII characters except for: <code>" * + , / : ; &lt; = &gt; ? \</code>. Note that the name must follow the 8.3 format.</td></tr>
<tr><td>3</td><td>DOS_WINDOWS</td><td>Both the DOS and WINDOWS names are identical, which is the same as the DOS character set, with the exception that lower case is used as well.</td></tr>
</table></div>
<blockquote>
<p>Note that the Windows API function CreateFile allows to create case sensitive
file names when the flag FILE_FLAG_POSIX_SEMANTICS is set.</p>
</blockquote>
<h4 id="long-to-short-name-conversion"><a class="header" href="#long-to-short-name-conversion">Long to short name conversion</a></h4>
<p>A short name can be determined from a long name with the following approach. In
the long name:</p>
<ul>
<li>ignore Unicode characters beyond the first 8-bit (extended ASCII)</li>
<li>ignore control characters and spaces (character &lt; 0x20)</li>
<li>ignore non-allowed characters <code>" * + , / : ; &lt; = &gt; ? \</code></li>
<li>ignore dots except the last one, which is used for the extension</li>
<li>make all letters upper case</li>
</ul>
<p>Additional observations:</p>
<ul>
<li><code>[</code> or <code>]</code> are replaced by an underscore (<code>_</code>)</li>
</ul>
<p>Make the name unique:</p>
<ol>
<li>use the characters 1 to 6 add ~1 and if the long name has an extension add the a dot and its first 3 letters, e.g. "Program Files" becomes "PROGRA~1" or " ~PLAYMOVIE.REG" becomes "~PLAYM~1.REG"</li>
<li>if the name already exists try ~2 up to ~9, e.g. "Program Data", in the same directory as "Program Files", becomes "PROGRA~2"</li>
<li>if the name already exists use a 16-bit hexadecimal value for characters 3 to 6 with ~1, e.g. "x86_microsoft-windows-r..ry-editor.resources_31bf3856ad364e35_6.0.6000.16386_en-us_f89a7b0005d42fd4" in a directory with a lot of filenames starting with "x86_microsoft", becomes "X8FCA6~1.163"</li>
</ol>
<p>TODO: determine if the behavior is dependent on a setting that can be changed with fsutil</p>
<h3 id="the-volume-version-attribute"><a class="header" href="#the-volume-version-attribute">The volume version attribute</a></h3>
<p>The volume version attribute ($VOLUME_VERSION) contains volume version.</p>
<p>TODO: complete section. Need a pre NTFS version 3.0 volume with this attribute.
$AttrDef indicates the attribute to be 8 bytes in size.</p>
<h3 id="the-object-identifier-attribute"><a class="header" href="#the-object-identifier-attribute">The object identifier attribute</a></h3>
<p>The object identifier attribute ($OBJECT_ID) contains distributed link tracker
properties. It is stored as a resident MFT attribute.</p>
<p>The object identifier attribute data is either 16 or 64 bytes in size and
consists of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>16</td><td></td><td>Droid file identifier, which contains a GUID</td></tr>
<tr><td>16</td><td>16</td><td></td><td>Birth droid volume identifier, which contains a GUID</td></tr>
<tr><td>32</td><td>16</td><td></td><td>Birth droid file identifier, which contains a GUID</td></tr>
<tr><td>48</td><td>16</td><td></td><td>Birth droid domain identifier, which contains a GUID</td></tr>
</table></div>
<p>Droid in this context refers to CDomainRelativeObjId.</p>
<h3 id="the-security-descriptor-attribute"><a class="header" href="#the-security-descriptor-attribute">The security descriptor attribute</a></h3>
<p>TODO: determine if this override any value in $Secure:$SDS?</p>
<p>The security descriptor attribute ($SECURITY_DESCRIPTOR) contains a Windows NT
security descriptor. It can be stored as either a resident (for a small amount
of data) and non-resident MFT attribute.</p>
<p>TODO: link to security descriptor format documentation</p>
<h3 id="the-volume-name-attribute"><a class="header" href="#the-volume-name-attribute">The volume name attribute</a></h3>
<p>The volume name attribute ($VOLUME_NAME) contains the volume label. It is
stored as a resident MFT attribute.</p>
<p>The volume name attribute data is of variable size and consists of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>...</td><td></td><td>Volume label, which contains an UCS-2 little-endian string without end-of-string character</td></tr>
</table></div>
<p>The volume name attribute is used in the $Volume metadata file MFT entry.</p>
<h3 id="the-volume-information-attribute"><a class="header" href="#the-volume-information-attribute">The volume information attribute</a></h3>
<p>The volume information attribute ($VOLUME_INFORMATION) contains information
about the volume. It is stored as a resident MFT attribute.</p>
<p>The volume information attribute data is 12 bytes in size and consists of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>8</td><td></td><td>Unknown</td></tr>
<tr><td>8</td><td>1</td><td></td><td>Major format version</td></tr>
<tr><td>9</td><td>1</td><td></td><td>Minor format version</td></tr>
<tr><td>10</td><td>2</td><td></td><td><a href="ntfs.html#volume_flags">Volume flags</a></td></tr>
</table></div>
<p>The volume information attribute is used in the $Volume metadata file MFT entry.</p>
<h4 id="volume-flags-1"><a class="header" href="#volume-flags-1"><a name="volume_flags"></a>Volume flags</a></h4>
<div class="table-wrapper"><table><thead><th>Value</th><th>Identifier</th><th>Description</th></thead><tr><td>0x0001</td><td>VOLUME_IS_DIRTY</td><td>Is dirty</td></tr>
<tr><td>0x0002</td><td>VOLUME_RESIZE_LOG_FILE</td><td>Re-size journal ($LogFile)</td></tr>
<tr><td>0x0004</td><td>VOLUME_UPGRADE_ON_MOUNT</td><td>Upgrade on next mount</td></tr>
<tr><td>0x0008</td><td>VOLUME_MOUNTED_ON_NT4</td><td>Mounted on Windows NT 4</td></tr>
<tr><td>0x0010</td><td>VOLUME_DELETE_USN_UNDERWAY</td><td>Delete USN in progress</td></tr>
<tr><td>0x0020</td><td>VOLUME_REPAIR_OBJECT_ID</td><td>Repair object identifiers</td></tr>
<tr><td></td><td></td><td></td></tr>
<tr><td>0x0080</td><td></td><td>Unknown</td></tr>
<tr><td></td><td></td><td></td></tr>
<tr><td>0x4000</td><td>VOLUME_CHKDSK_UNDERWAY</td><td>chkdsk in progress</td></tr>
<tr><td>0x8000</td><td>VOLUME_MODIFIED_BY_CHKDSK</td><td>Modified by chkdsk</td></tr>
</table></div>
<h3 id="the-data-stream-attribute"><a class="header" href="#the-data-stream-attribute">The data stream attribute</a></h3>
<p>The data stream attribute ($DATA) contains the file data. It can be stored as
either a resident (for a small amount of data) and non-resident MFT attribute.</p>
<p>Multiple data attributes for the same data stream can be used in the attribute
list to define different parts of the data stream data. The first data stream
attribute will contain the size of the entire data stream data. Other data
stream attributes should have a size of 0. Also see <a href="ntfs.html#attribute_chains">attribute chains</a>.</p>
<h3 id="the-index-root-attribute"><a class="header" href="#the-index-root-attribute">The index root attribute</a></h3>
<p>The index root attribute ($INDEX_ROOT) contains the root of the index tree. It
is stored as a resident MFT attribute.</p>
<p>Also see <a href="ntfs.html#index">the index</a> and <a href="ntfs.html#index_root">the index root</a>.</p>
<h3 id="the-index-allocation-attribute"><a class="header" href="#the-index-allocation-attribute">The index allocation attribute</a></h3>
<p>The index allocation attribute ($INDEX_ALLOCATION) contains an array of index
entries. It is stored as a non-resident MFT attribute.</p>
<p>The index allocation attribute itself does not define which attribute type it
contains in the index value data. For this information it needs the
corresponding index root attribute.</p>
<p>Multiple index allocation attributes for the same index can be used in the
attribute list to define different parts of the index allocation data. The
first index allocation attribute will contain the size of the entire index
allocation data. Other index allocation attributes should have a size of 0.
Also see <a href="ntfs.html#attribute_chains">attribute chains</a>.</p>
<p>Also see <a href="ntfs.html#index">the index</a>.</p>
<h3 id="the-bitmap-attribute"><a class="header" href="#the-bitmap-attribute">The bitmap attribute</a></h3>
<p>The bitmap attribute ($BITMAP) contains the allocation bitmap. It can be stored
as either a resident (for a small amount of data) and non-resident MFT
attribute.</p>
<p>It is used to maintain information about which entry is used and which is not.
Every bit in the bitmap represents an entry. The index is stored byte-wise with
the LSB of the byte corresponds to the first allocation element. The allocation
element can represent different things:</p>
<ul>
<li>an MFT entry in the MFT (nameless) bitmap;</li>
<li>an index entry in an index ($I30).</li>
</ul>
<p>The allocation element is allocated if the corresponding bit contains 1 or
unallocated if 0.</p>
<h3 id="the-symbolic-link-attribute"><a class="header" href="#the-symbolic-link-attribute">The symbolic link attribute</a></h3>
<p>The symbolic link attribute ($SYMBOLIC_LINK) contains a symbolic link.</p>
<p>TODO: complete section. Need a pre NTFS version 3.0 volume with this attribute.
$AttrDef indicates the attribute is of variable size.</p>
<h3 id="the-reparse-point-attribute"><a class="header" href="#the-reparse-point-attribute">The reparse point attribute</a></h3>
<p>The reparse point attribute ($REPARSE_POINT) contains information about a file
system-level link. It is stored as a resident MFT attribute.</p>
<p>Als see <a href="ntfs.html#reparse_point">the reparse point</a>.</p>
<h3 id="the-hpfs-extended-attribute-information"><a class="header" href="#the-hpfs-extended-attribute-information">The (HPFS) extended attribute information</a></h3>
<p>The (HPFS) extended attribute information ($EA_INFORMATION) contains
information about the extended attribute ($EA).</p>
<p>The extended attribute information data is 8 bytes in size and consists of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>2</td><td></td><td>Size of an extended attribute entry</td></tr>
<tr><td>2</td><td>2</td><td></td><td>Number of extended attributes which have the NEED_EA flag set</td></tr>
<tr><td>4</td><td>4</td><td></td><td>Size of the extended attribute ($EA) data</td></tr>
</table></div>
<h3 id="the-hpfs-extended-attribute"><a class="header" href="#the-hpfs-extended-attribute">The (HPFS) extended attribute</a></h3>
<p>The (HPFS) extended attribute ($EA) contains the extended attribute data.</p>
<p>The extended attribute data is of variable size and consists of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>4</td><td></td><td>Offset to next extended attribute entry, where the offset is relative from the start of the extended attribute data</td></tr>
<tr><td>4</td><td>1</td><td></td><td><a href="ntfs.html#extended_attribute_flags">Extended attribute flags</a></td></tr>
<tr><td>5</td><td>1</td><td></td><td>Number of characters of the extended attribute name</td></tr>
<tr><td>6</td><td>2</td><td></td><td>Value data size</td></tr>
<tr><td>8</td><td>...</td><td></td><td>The extended attribute name, which contains an ASCII string</td></tr>
<tr><td>...</td><td>...</td><td></td><td>Value data</td></tr>
<tr><td>...</td><td>...</td><td></td><td>Unknown</td></tr>
</table></div>
<p>TODO: determine if the name is 2-byte aligned</p>
<h4 id="extended-attribute-flags"><a class="header" href="#extended-attribute-flags"><a name="extended_attribute_flags"></a>Extended attribute flags</a></h4>
<div class="table-wrapper"><table><thead><th>Value</th><th>Identifier</th><th>Description</th></thead><tr><td>0x80</td><td>NEED_EA</td><td>Unknown (Need EA) flag</td></tr>
</table></div>
<p>TODO: determine what the NEED_EA flag is used for</p>
<h4 id="unitattr-extended-attribute-value-data"><a class="header" href="#unitattr-extended-attribute-value-data">UNITATTR extended attribute value data</a></h4>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>4</td><td></td><td>Unknown (equivalent of st_mode?)</td></tr>
</table></div>
<h3 id="the-property-set-attribute"><a class="header" href="#the-property-set-attribute">The property set attribute</a></h3>
<p>The property set attribute ($PROPERTY_SET) contains a property set.</p>
<p>TODO: complete section. Need a pre NTFS version 3.0 volume with this attribute.
$AttrDef does not seem to always define this attribute.</p>
<h3 id="the-logged-utility-stream-attribute"><a class="header" href="#the-logged-utility-stream-attribute">The logged utility stream attribute</a></h3>
<p>TODO: complete section</p>
<div class="table-wrapper"><table><thead><th>Value</th><th>Identifier</th><th>Description</th></thead><tr><td>$EFS</td><td></td><td>Encrypted NTFS (EFS)</td></tr>
<tr><td>$TXF_DATA</td><td></td><td>Transactional NTFS (TxF)</td></tr>
</table></div>
<h2 id="the-attribute-types"><a class="header" href="#the-attribute-types"><a name="attribute_types"></a>The attribute types</a></h2>
<p>The attribute types are stored in the <code>$AttrDef</code> metadata file.</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>128</td><td></td><td>Attribute which contains an UCS-2 little-endian string with end-of-string character. Unused bytes are filled with 0-byte values.</td></tr>
<tr><td>128</td><td>4</td><td></td><td><a href="ntfs.html#attribute_types">Attribute type</a> (or type code)</td></tr>
<tr><td>132</td><td>8</td><td></td><td>Unknown</td></tr>
<tr><td>140</td><td>4</td><td></td><td>Unknown (flags?)</td></tr>
<tr><td>144</td><td>8</td><td></td><td>Unknown (minimum attribute size?)</td></tr>
<tr><td>152</td><td>8</td><td></td><td>Unknown (maximum attribute size?)</td></tr>
</table></div>
<h2 id="the-index"><a class="header" href="#the-index"><a name="index"></a>The index</a></h2>
<p>The index structures are used for various purposes one of which are the
directory entries.</p>
<p>The root of the index is stored in index root. The index root attribute defines
which type of attribute is stored in the index and the root index node.</p>
<p>If the index is too large part of the index is stored in an index allocation
attribute with the same attribute name. The index allocation attribute defines
a data stream which contains index entries. Each index entry contains an index
node.</p>
<p>An index consists of a tree, where both the branch and index leaf nodes contain
the actual data. E.g. in case of a directory entries index, any node that
contains index value data make up for the directory entries.</p>
<p>The index value data in a branch node signifies the upper bound of the values
in the that specific branch. E.g. if directory entries index branch node
contains the name "textfile.txt" all names in that index branch are smaller
than "textfile.txt".</p>
<blockquote>
<p>Note the actual sorting order is dependent on the collation type defined in
the index root attribute.</p>
</blockquote>
<p>The index allocation attribute is accompanied by a bitmap attribute with the
corresponding attribute name. The bitmap attribute defines the allocation of
virtual cluster blocks within the index allocation attribute data stream.</p>
<blockquote>
<p>Note that the index allocation attribute can be present even though it is not
used.</p>
</blockquote>
<h3 id="common-used-indexes"><a class="header" href="#common-used-indexes">Common used indexes</a></h3>
<p>Indexes commonly used by NTFS are:</p>
<div class="table-wrapper"><table><thead><th>Value</th><th>Identifier</th><th>Description</th></thead><tr><td>$I30</td><td></td><td>Directory entries (used by directories)</td></tr>
<tr><td>$SDH</td><td></td><td>Security descriptor hashes (used by $Secure)</td></tr>
<tr><td>$SII</td><td></td><td>Security descriptor identifiers (used by $Secure)</td></tr>
<tr><td>$O</td><td></td><td>Object identifiers (used by $ObjId)</td></tr>
<tr><td>$O</td><td></td><td>Owner identifiers (used by $Quota)</td></tr>
<tr><td>$Q</td><td></td><td>Quotas (used by $Quota)</td></tr>
<tr><td>$R</td><td></td><td>Reparse points (used by $Reparse)</td></tr>
</table></div>
<h3 id="the-index-root"><a class="header" href="#the-index-root"><a name="index_root"></a>The index root</a></h3>
<p>The index root consists of:</p>
<ul>
<li>index root header</li>
<li>index node header</li>
<li>an array of index values</li>
</ul>
<h4 id="the-index-root-header"><a class="header" href="#the-index-root-header">The index root header</a></h4>
<p>The index root header is 16 bytes in size and consists of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>4</td><td></td><td>Attribute type, which contains the type of the indexed attribute or 0 if none</td></tr>
<tr><td>4</td><td>4</td><td></td><td><a href="ntfs.html#collation_type">Collation type</a>, which contains a value to indicate the ordering of the index entries</td></tr>
<tr><td>8</td><td>4</td><td></td><td>Index entry size</td></tr>
<tr><td>12</td><td>4</td><td></td><td>Number of cluster blocks per index entry</td></tr>
</table></div>
<blockquote>
<p>Note that for NTFS version 1.2 the index entry size does not have to match
the index entry size in the volume header. The correct size seems to be the
value in the index root header.</p>
</blockquote>
<h4 id="collation-type"><a class="header" href="#collation-type"><a name="collation_type"></a>Collation type</a></h4>
<div class="table-wrapper"><table><thead><th>Value</th><th>Identifier</th><th>Description</th></thead><tr><td>0x00000000</td><td>COLLATION_BINARY</td><td>Binary, where the first byte is most significant</td></tr>
<tr><td>0x00000001</td><td>COLLATION_FILENAME</td><td>UCS-2 strings case-insensitive, where the case folding is stored in $UpCase</td></tr>
<tr><td>0x00000002</td><td>COLLATION_UNICODE_STRING</td><td>UCS-2 strings case-sensitive, where upper case letters should come first</td></tr>
<tr><td></td><td></td><td></td></tr>
<tr><td>0x00000010</td><td>COLLATION_NTOFS_ULONG</td><td>Unsigned 32-bit little-endian integer</td></tr>
<tr><td>0x00000011</td><td>COLLATION_NTOFS_SID</td><td>NT security identifier (SID)</td></tr>
<tr><td>0x00000012</td><td>COLLATION_NTOFS_SECURITY_HASH</td><td>Security hash first, then NT security identifier</td></tr>
<tr><td>0x00000013</td><td>COLLATION_NTOFS_ULONGS</td><td>An array of unsigned 32-bit little-endian integer values</td></tr>
</table></div>
<h3 id="the-index-entry"><a class="header" href="#the-index-entry">The index entry</a></h3>
<p>The index entry consists of:</p>
<ul>
<li>the index entry header</li>
<li>the index node header</li>
<li><a href="ntfs.html#fix_up_values">The fix-up values</a></li>
<li>alignment padding (8-byte alignment), contains zero-bytes</li>
<li>an array of index values</li>
</ul>
<h4 id="the-index-entry-header"><a class="header" href="#the-index-entry-header">The index entry header</a></h4>
<p>The index entry header is 24 bytes in size and consists of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>4</td><td>"INDX"</td><td>Signature</td></tr>
<tr><td>4</td><td>2</td><td></td><td>The fix-up values offset, which contains an offset relative from the start of the index entry header.</td></tr>
<tr><td>6</td><td>2</td><td></td><td>The number of fix-up values</td></tr>
<tr><td>8</td><td>8</td><td></td><td>Metadata transaction journal sequence number, which contains a $LogFile Sequence Number (LSN)</td></tr>
<tr><td>16</td><td>8</td><td></td><td>Virtual Cluster Number (VCN) of the index entry</td></tr>
</table></div>
<blockquote>
<p>Note that there can be more fix-up value than supported by the index entry
data size.</p>
</blockquote>
<h3 id="the-index-node-header"><a class="header" href="#the-index-node-header">The index node header</a></h3>
<p>The index node header is 16 bytes in size and consists of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>4</td><td></td><td>Index values offset, where the offset is relative from the start of the index node header</td></tr>
<tr><td>4</td><td>4</td><td></td><td>Index node size, where the value includes the size of the index node header</td></tr>
<tr><td>8</td><td>4</td><td></td><td>Allocated index node size, where the value includes the size of the index node header</td></tr>
<tr><td>12</td><td>4</td><td></td><td><a href="ntfs.html#index_node_flags">Index node flags</a></td></tr>
</table></div>
<p>In an index entry (index allocation attribute) the index node size includes the
size of the fix-up values and the alignment padding following it.</p>
<p>The remainder of the index node contains remnant data and/or zero-byte values.</p>
<h4 id="the-index-node-flags"><a class="header" href="#the-index-node-flags"><a name="index_node_flags"></a>The index node flags</a></h4>
<div class="table-wrapper"><table><thead><th>Value</th><th>Identifier</th><th>Description</th></thead><tr><td>0x00000001</td><td></td><td>Is branch node, which is used to indicate if the node is a branch node that has sub nodes</td></tr>
</table></div>
<h3 id="the-index-value"><a class="header" href="#the-index-value">The index value</a></h3>
<p>The index value is of variable size and consists of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>8</td><td></td><td><a href="ntfs.html#file_reference">File reference</a></td></tr>
<tr><td>8</td><td>2</td><td></td><td>Size, which includes the 10 bytes of the file reference and size</td></tr>
<tr><td>10</td><td>2</td><td></td><td>Key data size</td></tr>
<tr><td>12</td><td>4</td><td></td><td>Index value flags</td></tr>
<tr><td colspan="4"> <em>If index key data size &gt; 0</em></tr>
<tr><td>16</td><td>...</td><td></td><td>Key data</td></tr>
<tr><td>...</td><td>...</td><td></td><td>Data</td></tr>
<tr><td colspan="4"> <em>If index value flag 0x00000001 (is branch node) is set</em></tr>
<tr><td>...</td><td>8</td><td></td><td>Sub node Virtual Cluster Number (VCN)</td></tr>
</table></div>
<p>The index values are stored 8 byte aligned.</p>
<blockquote>
<p>Note that some other sources define the index value flags as a 16-bit value
followed by 2 bytes of padding.</p>
</blockquote>
<h4 id="the-index-value-flags"><a class="header" href="#the-index-value-flags">The index value flags</a></h4>
<div class="table-wrapper"><table><thead><th>Value</th><th>Identifier</th><th>Description</th></thead><tr><td>0x00000001</td><td></td><td>Has sub node, when set the index value contains a sub node Virtual Cluster Number (VCN)</td></tr>
<tr><td>0x00000002</td><td></td><td>Is last, when set the index value is the last in the index values array</td></tr>
</table></div>
<h3 id="index-key-and-value-data"><a class="header" href="#index-key-and-value-data">Index key and value data</a></h3>
<h4 id="directory-entry-index-value"><a class="header" href="#directory-entry-index-value">Directory entry index value</a></h4>
<p>The MFT attribute name of the directory entry index is: $I30.</p>
<p>The directory entry index value contains a <a href="ntfs.html#file_name_attribute">file name attribute</a>
in the index key data.</p>
<blockquote>
<p>Note that the index value data can contain remnant data.</p>
</blockquote>
<p>The short and long names of the same file have a separate index values. The
short name uses the DOS name space and the long name the WINDOWS name space.
Index values with a single name use either the POSIX or DOS_WINDOWS name space.</p>
<p>A hard link to a file in the same directory has separate index values.</p>
<h4 id="security-descriptor-hash-index-value"><a class="header" href="#security-descriptor-hash-index-value">Security descriptor hash index value</a></h4>
<p>The MFT attribute name of the security descriptor hash index is: $SDH.
It appears to only to be used by the $Secure metadata file.</p>
<p>Also see <a href="ntfs.html#security_descriptor_hash_index_value">the security descriptor hash index value</a>.</p>
<h4 id="security-descriptor-identifier-index-value"><a class="header" href="#security-descriptor-identifier-index-value">Security descriptor identifier index value</a></h4>
<p>The MFT attribute name of the security descriptor identifier index is: $SII.
It appears to only to be used by the $Secure metadata file.</p>
<p>Also see <a href="ntfs.html#security_descriptor_identifier_index_value">the security descriptor identifier index value</a>.</p>
<h2 id="compression"><a class="header" href="#compression"><a name="compression"></a>Compression</a></h2>
<h3 id="compressed-data-runs"><a class="header" href="#compressed-data-runs">Compressed data-runs</a></h3>
<p>NTFS compression groups 16 cluster blocks together. This group of 16 cluster
blocks also named a compression unit, which is either "compressed" or
uncompressed.</p>
<p>The term compressed is quoted here because the group of cluster blocks can also
contain uncompressed data. A group of cluster blocks is "compressed" when it is
compressed size is smaller than its uncompressed data size. Within a group of
cluster blocks each of the 16 blocks is "compressed" individually.</p>
<p>The compression unit size is stored in the non-resident MFT attribute. The
maximum uncompressed data size is always the cluster size (in most case
4096).</p>
<blockquote>
<p>Note that a resident $DATA attribute with the compression type in the
data flags is stored uncompressed.</p>
</blockquote>
<p>The data runs in the $DATA attribute define cluster block ranges, e.g.</p>
<pre><code>21 02 35 52
</code></pre>
<p>This data run defines 2 data blocks starting at block number 21045 followed by
14 sparse blocks. The total number of blocks in the compression unit is 16.
Compressed data is stored in the first 2 blocks and the 14 sparse blocks are
only there to make sure the data runs add up to the compression unit size. They
do not define actual sparse data.</p>
<p>Another example:</p>
<pre><code>21 40 37 52
</code></pre>
<p>This data run defines 64 data blocks starting at block number 21047. Since
this data run is larger than the compression unit size the data is stored
uncompressed.</p>
<p>If the data run was e.g. 60 data blocks followed by 4 sparse blocks the first 3
compression units (blocks 1 to 48) would be uncompressed and the last
compression unit (blocks 49 to 64) would be compressed.</p>
<p>Also "sparse data" and "sparse compression unit" data runs can be mixed. If in
the previous example the 60 data blocks would be followed by 20 sparse blocks
the last compression unit (blocks 65 to 80) would be sparse.</p>
<p>A compression unit can consists of multiple compressed data runs, e.g. 1 data
block followed by 4 data blocks followed by 11 sparse blocks. Data runs have
been observed where the last data run size does not align with the compression
unit size.</p>
<p>The sparse blocks data run can be stored in a subsequent attribute in an
attribute chain and can be stored in multiple data runs.</p>
<p>NTFS compression stores the "compressed" data in blocks. Each block has a 2
byte block header.</p>
<p>The block is of variable size and consists of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>2</td><td></td><td>Block size</td></tr>
<tr><td>2</td><td>compressed data size</td><td></td><td>Uncompressed or LZNT1 compressed data</td></tr>
</table></div>
<p>The upper 4 bits of the block size are used as flags:</p>
<div class="table-wrapper"><table><thead><th>Bit(s)</th><th>Description</th></thead><tr><td>0 - 11</td><td>Compressed data size</td></tr>
<tr><td>12 - 14</td><td>Unknown</td></tr>
<tr><td>15</td><td>Data is compressed</td></tr>
</table></div>
<p>TODO: link to LZNT1 documentation</p>
<h3 id="windows-overlay-filter-wof-compressed-data"><a class="header" href="#windows-overlay-filter-wof-compressed-data">Windows Overlay Filter (WOF) compressed data</a></h3>
<p>A MFT entry that contains Windows Overlay Filter (WOF) compressed data has the
following attributes:</p>
<ul>
<li>reparse point attribute with tag 0x80000017, which defines the compression method</li>
<li>a nameless data attribute that is sparse and contains the uncompressed data size</li>
<li>a data attribute named WofCompressedData that contains LZXPRESS Huffman or LZX compressed data</li>
</ul>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td colspan="4"> <em>Chunk offset table</em></tr>
<tr><td>0</td><td>...</td><td></td><td>Array of 32-bit of 64-bit compressed data chunk offsets, where the offset is relative from the start of the data chunks</td></tr>
<tr><td colspan="4"> <em>Data chunks</em></tr>
<tr><td>...</td><td>...</td><td></td><td>One or more compressed or uncompressed data chunks</td></tr>
</table></div>
<blockquote>
<p>Note that if the chunk size equals the size of the uncompressed data the chunk
is stored (as-is) uncompressed.</p>
</blockquote>
<p>The size of the chunk offset table is:</p>
<pre><code>number of chunk offsets = uncompressed size / compression unit size
</code></pre>
<p>The offset of the first compressed data chunk is at the end of the chunk offset
table and is not stored in the chunk offset table.</p>
<p>If the uncompressed size of a chunk is smaller than the compression unit size
the chunk is stored uncompressed.</p>
<p>Also see <a href="ntfs.html#wof_compression_method">Windows Overlay Filter (WOF) compression method</a>.</p>
<h2 id="the-reparse-point"><a class="header" href="#the-reparse-point"><a name="reparse_point"></a>The reparse point</a></h2>
<p>The reparse point is used to create file system-level links. Reparse data is
stored in the reparse point attribute. The reparse point data
(REPARSE_DATA_BUFFER) is of variable size and consists of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>4</td><td></td><td>Reparse point tag</td></tr>
<tr><td>4</td><td>2</td><td></td><td>Reparse data size</td></tr>
<tr><td>6</td><td>2</td><td>0</td><td>Unknown (Reserved)</td></tr>
<tr><td>8</td><td>...</td><td></td><td>Reparse data</td></tr>
</table></div>
<p>TODO: determine if non-native (Microsoft) reparse points are stored with their GUID</p>
<h3 id="the-reparse-point-tag"><a class="header" href="#the-reparse-point-tag"><a name="reparse_point_tag"></a>The reparse point tag</a></h3>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0.0 </td><td>16 bits</td><td></td><td>Type</td></tr>
<tr><td>2.0 </td><td>12 bits</td><td></td><td>Unknown (Reserved)</td></tr>
<tr><td>3.4</td><td>4 bits</td><td></td><td>Flags</td></tr>
</table></div>
<h4 id="reparse-point-tag-flags"><a class="header" href="#reparse-point-tag-flags">Reparse point tag flags</a></h4>
<div class="table-wrapper"><table><thead><th>Value</th><th>Identifier</th><th>Description</th></thead><tr><td>0x1</td><td></td><td>Unknown (Reserved)</td></tr>
<tr><td>0x2</td><td></td><td>Is alias (Name surrogate bit), when this bit is set, the file or directory represents another named entity in the system.</td></tr>
<tr><td>0x4</td><td></td><td>Is high-latency media (Reserved)</td></tr>
<tr><td>0x8</td><td></td><td>Is native (Microsoft-bit)</td></tr>
</table></div>
<h4 id="known-reparse-point-tags"><a class="header" href="#known-reparse-point-tags">Known reparse point tags</a></h4>
<div class="table-wrapper"><table><thead><th>Value</th><th>Identifier</th><th>Description</th></thead><tr><td>0x00000000</td><td>IO_REPARSE_TAG_RESERVED_ZERO</td><td>Unknown (Reserved)</td></tr>
<tr><td>0x00000001</td><td>IO_REPARSE_TAG_RESERVED_ONE</td><td>Unknown (Reserved)</td></tr>
<tr><td>0x00000002</td><td>IO_REPARSE_TAG_RESERVED_TWO</td><td>Unknown (Reserved)</td></tr>
<tr><td></td><td></td><td></td></tr>
<tr><td>0x80000005</td><td>IO_REPARSE_TAG_DRIVE_EXTENDER</td><td>Used by Home server drive extender</td></tr>
<tr><td>0x80000006</td><td>IO_REPARSE_TAG_HSM2</td><td>Used by Hierarchical Storage Manager Product</td></tr>
<tr><td>0x80000007</td><td>IO_REPARSE_TAG_SIS</td><td>Used by single-instance storage (SIS) filter driver</td></tr>
<tr><td>0x80000008</td><td>IO_REPARSE_TAG_WIM</td><td>Used by the WIM Mount filter</td></tr>
<tr><td>0x80000009</td><td>IO_REPARSE_TAG_CSV</td><td>Used by Clustered Shared Volumes (CSV) version 1</td></tr>
<tr><td>0x8000000a</td><td>IO_REPARSE_TAG_DFS</td><td>Used by the Distributed File System (DFS)</td></tr>
<tr><td>0x8000000b</td><td>IO_REPARSE_TAG_FILTER_MANAGER</td><td>Used by filter manager test harness</td></tr>
<tr><td></td><td></td><td></td></tr>
<tr><td>0x80000012</td><td>IO_REPARSE_TAG_DFSR</td><td>Used by the Distributed File System (DFS)</td></tr>
<tr><td>0x80000013</td><td>IO_REPARSE_TAG_DEDUP</td><td>Used by the Data Deduplication (Dedup)</td></tr>
<tr><td>0x80000014</td><td>IO_REPARSE_TAG_NFS</td><td>Used by the Network File System (NFS)</td></tr>
<tr><td>0x80000015</td><td>IO_REPARSE_TAG_FILE_PLACEHOLDER</td><td>Used by Windows Shell for placeholder files</td></tr>
<tr><td>0x80000016</td><td>IO_REPARSE_TAG_DFM</td><td>Used by Dynamic File filter</td></tr>
<tr><td>0x80000017</td><td>IO_REPARSE_TAG_WOF</td><td>Used by <a href="ntfs.html#wof_reparse_data">Windows Overlay Filter (WOF)</a>, for either WIMBoot or compression</td></tr>
<tr><td>0x80000018</td><td>IO_REPARSE_TAG_WCI</td><td>Used by <a href="ntfs.html#wci_reparse_data">Windows Container Isolation (WCI)</a></td></tr>
<tr><td></td><td></td><td></td></tr>
<tr><td>0x8000001b</td><td>IO_REPARSE_TAG_APPEXECLINK</td><td>Used by Universal Windows Platform (UWP) packages to encode information that allows the application to be launched by CreateProcess</td></tr>
<tr><td></td><td></td><td></td></tr>
<tr><td>0x8000001e</td><td>IO_REPARSE_TAG_STORAGE_SYNC</td><td>Used by the Azure File Sync (AFS) filter</td></tr>
<tr><td></td><td></td><td></td></tr>
<tr><td>0x80000020</td><td>IO_REPARSE_TAG_UNHANDLED</td><td>Used by Windows Container Isolation (WCI)</td></tr>
<tr><td>0x80000021</td><td>IO_REPARSE_TAG_ONEDRIVE</td><td>Unknown (Not used)</td></tr>
<tr><td></td><td></td><td></td></tr>
<tr><td>0x80000023</td><td>IO_REPARSE_TAG_AF_UNIX</td><td>Used by the Windows Subsystem for Linux (WSL) to represent a UNIX domain socket</td></tr>
<tr><td>0x80000024</td><td>IO_REPARSE_TAG_LX_FIFO</td><td>Used by the Windows Subsystem for Linux (WSL) to represent a UNIX FIFO (named pipe)</td></tr>
<tr><td>0x80000025</td><td>IO_REPARSE_TAG_LX_CHR</td><td>Used by the Windows Subsystem for Linux (WSL) to represent a UNIX character special file</td></tr>
<tr><td>0x80000036</td><td>IO_REPARSE_TAG_LX_BLK</td><td>Used by the Windows Subsystem for Linux (WSL) to represent a UNIX block special file</td></tr>
<tr><td></td><td></td><td></td></tr>
<tr><td>0x9000001c</td><td>IO_REPARSE_TAG_PROJFS</td><td>Used by the Windows Projected File System filter, for files managed by a user mode provider such as VFS for Git</td></tr>
<tr><td></td><td></td><td></td></tr>
<tr><td>0x90001018</td><td>IO_REPARSE_TAG_WCI_1</td><td>Used by Windows Container Isolation (WCI)</td></tr>
<tr><td></td><td></td><td></td></tr>
<tr><td>0x9000101a</td><td>IO_REPARSE_TAG_CLOUD_1</td><td>Used by the Cloud Files filter, for files managed by a sync engine such as OneDrive</td></tr>
<tr><td></td><td></td><td></td></tr>
<tr><td>0x9000201a</td><td>IO_REPARSE_TAG_CLOUD_2</td><td>Used by the Cloud Files filter, for files managed by a sync engine such as OneDrive</td></tr>
<tr><td></td><td></td><td></td></tr>
<tr><td>0x9000301a</td><td>IO_REPARSE_TAG_CLOUD_3</td><td>Used by the Cloud Files filter, for files managed by a sync engine such as OneDrive</td></tr>
<tr><td></td><td></td><td></td></tr>
<tr><td>0x9000401a</td><td>IO_REPARSE_TAG_CLOUD_4</td><td>Used by the Cloud Files filter, for files managed by a sync engine such as OneDrive</td></tr>
<tr><td></td><td></td><td></td></tr>
<tr><td>0x9000501a</td><td>IO_REPARSE_TAG_CLOUD_5</td><td>Used by the Cloud Files filter, for files managed by a sync engine such as OneDrive</td></tr>
<tr><td></td><td></td><td></td></tr>
<tr><td>0x9000601a</td><td>IO_REPARSE_TAG_CLOUD_6</td><td>Used by the Cloud Files filter, for files managed by a sync engine such as OneDrive</td></tr>
<tr><td></td><td></td><td></td></tr>
<tr><td>0x9000701a</td><td>IO_REPARSE_TAG_CLOUD_7</td><td>Used by the Cloud Files filter, for files managed by a sync engine such as OneDrive</td></tr>
<tr><td></td><td></td><td></td></tr>
<tr><td>0x9000801a</td><td>IO_REPARSE_TAG_CLOUD_8</td><td>Used by the Cloud Files filter, for files managed by a sync engine such as OneDrive</td></tr>
<tr><td></td><td></td><td></td></tr>
<tr><td>0x9000901a</td><td>IO_REPARSE_TAG_CLOUD_9</td><td>Used by the Cloud Files filter, for files managed by a sync engine such as OneDrive</td></tr>
<tr><td></td><td></td><td></td></tr>
<tr><td>0x9000a01a</td><td>IO_REPARSE_TAG_CLOUD_A</td><td>Used by the Cloud Files filter, for files managed by a sync engine such as OneDrive</td></tr>
<tr><td></td><td></td><td></td></tr>
<tr><td>0x9000b01a</td><td>IO_REPARSE_TAG_CLOUD_B</td><td>Used by the Cloud Files filter, for files managed by a sync engine such as OneDrive</td></tr>
<tr><td></td><td></td><td></td></tr>
<tr><td>0x9000c01a</td><td>IO_REPARSE_TAG_CLOUD_C</td><td>Used by the Cloud Files filter, for files managed by a sync engine such as OneDrive</td></tr>
<tr><td></td><td></td><td></td></tr>
<tr><td>0x9000d01a</td><td>IO_REPARSE_TAG_CLOUD_D</td><td>Used by the Cloud Files filter, for files managed by a sync engine such as OneDrive</td></tr>
<tr><td></td><td></td><td></td></tr>
<tr><td>0x9000e01a</td><td>IO_REPARSE_TAG_CLOUD_E</td><td>Used by the Cloud Files filter, for files managed by a sync engine such as OneDrive</td></tr>
<tr><td></td><td></td><td></td></tr>
<tr><td>0x9000f01a</td><td>IO_REPARSE_TAG_CLOUD_F</td><td>Used by the Cloud Files filter, for files managed by a sync engine such as OneDrive</td></tr>
<tr><td></td><td></td><td></td></tr>
<tr><td>0xa0000003</td><td>IO_REPARSE_TAG_MOUNT_POINT</td><td><a href="ntfs.html#junction_reparse_data">Junction</a> (or mount point)</td></tr>
<tr><td></td><td></td><td></td></tr>
<tr><td>0xa000000c</td><td>IO_REPARSE_TAG_SYMLINK</td><td><a href="ntfs.html#symbolic_link_reparse_data">Symbolic link</a></td></tr>
<tr><td></td><td></td><td></td></tr>
<tr><td>0xa0000010</td><td>IO_REPARSE_TAG_IIS_CACHE</td><td>Used by Microsoft Internet Information Services (IIS) caching</td></tr>
<tr><td></td><td></td><td></td></tr>
<tr><td>0xa0000019</td><td>IO_REPARSE_TAG_GLOBAL_REPARSE</td><td>Used by NPFS to indicate a named pipe symbolic link from a server silo into the host silo</td></tr>
<tr><td>0xa000001a</td><td>IO_REPARSE_TAG_CLOUD</td><td>Used by the Cloud Files filter, for files managed by a sync engine such as Microsoft OneDrive</td></tr>
<tr><td></td><td></td><td></td></tr>
<tr><td>0xa000001d</td><td>IO_REPARSE_TAG_LX_SYMLINK</td><td>Used by the Windows Subsystem for Linux (WSL) to represent a UNIX symbolic link</td></tr>
<tr><td></td><td></td><td></td></tr>
<tr><td>0xa000001f</td><td>IO_REPARSE_TAG_WCI_TOMBSTONE</td><td>Used by Windows Container Isolation (WCI)</td></tr>
<tr><td></td><td></td><td></td></tr>
<tr><td>0xa0000022</td><td>IO_REPARSE_TAG_PROJFS_TOMBSTONE</td><td>Used by the Windows Projected File System filter, for files managed by a user mode provider such as VFS for Git</td></tr>
<tr><td></td><td></td><td></td></tr>
<tr><td>0xa0000027</td><td>IO_REPARSE_TAG_WCI_LINK</td><td>Used by Windows Container Isolation (WCI)</td></tr>
<tr><td></td><td></td><td></td></tr>
<tr><td>0xa0001027</td><td>IO_REPARSE_TAG_WCI_LINK_1</td><td>Used by Windows Container Isolation (WCI)</td></tr>
<tr><td></td><td></td><td></td></tr>
<tr><td>0xc0000004</td><td>IO_REPARSE_TAG_HSM</td><td>Used by Hierarchical Storage Manager Product</td></tr>
<tr><td></td><td></td><td></td></tr>
<tr><td>0xc0000014</td><td>IO_REPARSE_TAG_APPXSTRM</td><td>Unknown (Not used)</td></tr>
</table></div>
<h3 id="junction-or-mount-point-reparse-data"><a class="header" href="#junction-or-mount-point-reparse-data"><a name="junction_reparse_data"></a>Junction or mount point reparse data</a></h3>
<p>A reparse point with tag IO_REPARSE_TAG_MOUNT_POINT (0xa0000003) contains
junction or mount point reparse data. The junction or mount point reparse data
is of variable size and consists of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>2</td><td></td><td>Substitute name offset, where the offset is relative from the start of the reparse name data</td></tr>
<tr><td>2</td><td>2</td><td></td><td>Substitute name size in bytes, where the size of the end-of-string character is not included</td></tr>
<tr><td>4</td><td>2</td><td></td><td>Display name offset, where the offset is relative from the start of the reparse name data</td></tr>
<tr><td>6</td><td>2</td><td></td><td>Display name size in bytes, where the size of the end-of-string character is not included</td></tr>
<tr><td colspan="4"> <em>Reparse name data</em></tr>
<tr><td>8</td><td>...</td><td></td><td>Substitute name, which contains an UCS-2 little-endian string without end-of-string character</td></tr>
<tr><td>...</td><td>...</td><td></td><td>Display name, which contains an UCS-2 little-endian string without end-of-string character</td></tr>
</table></div>
<blockquote>
<p>Note that it is currently unclear if the names contain an end-of-string
character or if they are followed by alignment padding.</p>
</blockquote>
<p>TODO: determine what character values like 0x0002 represent in the substitute name</p>
<pre><code>00000010: 5c 00 3f 00 3f 00 02 00  43 00 3a 00 5c 00 55 00   \.?.?... C.:.\.U.
00000020: 73 00 65 00 72 00 73 00  5c 00 74 00 65 00 73 00   s.e.r.s. \.t.e.s.
00000030: 74 00 5c 00 44 00 6f 00  63 00 75 00 6d 00 65 00   t.\.D.o. c.u.m.e.
00000040: 6e 00 74 00 73 00 00 00                            n.t.s...
</code></pre>
<h3 id="symbolic-link-reparse-data"><a class="header" href="#symbolic-link-reparse-data"><a name="symbolic_link_reparse_data"></a>Symbolic link reparse data</a></h3>
<p>A reparse point with tag IO_REPARSE_TAG_SYMLINK (0xa000000c) contains symbolic
link reparse data. The symbolic link reparse data is of variable size and
consists of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>2</td><td></td><td>Substitute name offset, where the offset is relative from the start of the reparse name data</td></tr>
<tr><td>2</td><td>2</td><td></td><td>Substitute name size in bytes</td></tr>
<tr><td>4</td><td>2</td><td></td><td>Display name offset, where the offset is relative from the start of the reparse name data</td></tr>
<tr><td>6</td><td>2</td><td></td><td>Display name size, in bytes</td></tr>
<tr><td>8</td><td>4</td><td></td><td>Symbolic link flags</td></tr>
<tr><td colspan="4"> <em>Reparse name data</em></tr>
<tr><td>12</td><td>...</td><td></td><td>Substitute name, which contains an UCS-2 little-endian string without end-of-string character</td></tr>
<tr><td>...</td><td>...</td><td></td><td>Display name, which contains an UCS-2 little-endian string without end-of-string character</td></tr>
</table></div>
<h4 id="symbolic-link-flags"><a class="header" href="#symbolic-link-flags">Symbolic link flags</a></h4>
<div class="table-wrapper"><table><thead><th>Value</th><th>Identifier</th><th>Description</th></thead><tr><td>0x00000001</td><td>SYMLINK_FLAG_RELATIVE</td><td>The substitute name is a path name relative to the directory containing the symbolic link.</td></tr>
</table></div>
<h3 id="windows-overlay-filter-wof-reparse-data"><a class="header" href="#windows-overlay-filter-wof-reparse-data"><a name="wof_reparse_data"></a>Windows Overlay Filter (WOF) reparse data</a></h3>
<p>A reparse point with tag IO_REPARSE_TAG_WOF (0x80000017) contains Windows
Overlay Filter (WOF) reparse data. The Windows Overlay Filter (WOF) reparse
data is 16 bytes in size and consists of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td colspan="4"> <em>External provider information</em></tr>
<tr><td>0</td><td>4</td><td>1</td><td>Unknown (WOF version)</td></tr>
<tr><td>4</td><td>4</td><td>2</td><td>Unknown (WOF provider)</td></tr>
<tr><td colspan="4"> <em>Internal provider information</em></tr>
<tr><td>8</td><td>4</td><td>1</td><td>Unknown (file information version)</td></tr>
<tr><td>12</td><td>4</td><td></td><td><a href="ntfs.html#wof_compression_method">Compression method</a></td></tr>
</table></div>
<h3 id="windows-overlay-filter-wof-compression-method"><a class="header" href="#windows-overlay-filter-wof-compression-method"><a name="wof_compression_method"></a>Windows Overlay Filter (WOF) compression method</a></h3>
<div class="table-wrapper"><table><thead><th>Value</th><th>Identifier</th><th>Description</th></thead><tr><td>0</td><td></td><td>LZXPRESS Huffman with 4k window (compression unit)</td></tr>
<tr><td>1</td><td></td><td>LZX with 32k window (compression unit)</td></tr>
<tr><td>2</td><td></td><td>LZXPRESS Huffman with 8k window (compression unit)</td></tr>
<tr><td>3</td><td></td><td>LZXPRESS Huffman with 16k window (compression unit)</td></tr>
</table></div>
<p>TODO: link to LZXPRESS Huffman and LZX documentation</p>
<h3 id="windows-container-isolation-wci-reparse-data"><a class="header" href="#windows-container-isolation-wci-reparse-data"><a name="wci_reparse_data">Windows Container Isolation (WCI) reparse data</a></h3>
<p>A reparse point with tag IO_REPARSE_TAG_WCI (0x80000018) contains Windows
Container Isolation (WCI) reparse data. The Windows Container Isolation (WCI)
reparse data is of variable size and consists of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>4</td><td>1</td><td>Version</td></tr>
<tr><td>4</td><td>4</td><td>0</td><td>Unknown (reserved)</td></tr>
<tr><td>8</td><td>16</td><td></td><td>Look-up identifier, which contains a GUID</td></tr>
<tr><td>24</td><td>2</td><td></td><td>Name size in bytes</td></tr>
<tr><td>26</td><td>...</td><td></td><td>Name, which contains an UCS-2 little-endian string without end-of-string character</td></tr>
</table></div>
<h2 id="the-allocation-bitmap"><a class="header" href="#the-allocation-bitmap">The allocation bitmap</a></h2>
<p>The metadata file $Bitmap contains the allocation bitmap.</p>
<p>Every bit in the allocation bitmap represents a block the size of the cluster
block, where the LSB is the first bit in a byte.</p>
<p>TODO: describe what the $SRAT data stream is used for.</p>
<h2 id="access-control"><a class="header" href="#access-control"><a name="access_control"></a>Access control</a></h2>
<p>The $Secure metadata file contains the security descriptors used for access control.</p>
<div class="table-wrapper"><table><thead><th>Type</th><th>Name</th><th>Description</th></thead><tr><td>Data</td><td>$SDS</td><td>Security descriptor data stream, which contains all the Security descriptors on the volume</td></tr>
<tr><td>Index</td><td>$SDH</td><td>Security descriptor hash index</td></tr>
<tr><td>Index</td><td>$SII</td><td>Security descriptor identifier index, which contains the mapping of the security descriptor identifier (in $STANDARD_INFORMATION) to the offset of the security descriptor data (in $Secure:$SDS)</td></tr>
</table></div>
<h3 id="security-descriptor-hash-sdh-index"><a class="header" href="#security-descriptor-hash-sdh-index">Security descriptor hash ($SDH) index</a></h3>
<h4 id="the-security-descriptor-hash-index-value"><a class="header" href="#the-security-descriptor-hash-index-value"><a name="security_descriptor_hash_index_value"></a>The security descriptor hash index value</a></h4>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td colspan="4"> <em>Key data</em></tr>
<tr><td>0</td><td>4</td><td></td><td>Security descriptor hash</td></tr>
<tr><td>4</td><td>4</td><td></td><td>Security descriptor identifier</td></tr>
<tr><td colspan="4"> <em>Value data</em></tr>
<tr><td>8</td><td>4</td><td></td><td>Security descriptor hash</td></tr>
<tr><td>12</td><td>4</td><td></td><td>Security descriptor identifier</td></tr>
<tr><td>16</td><td>8</td><td></td><td>Security descriptor data offset (in $SDS)</td></tr>
<tr><td>24</td><td>4</td><td></td><td>Security descriptor data size (in $SDS)</td></tr>
<tr><td>28</td><td>4</td><td></td><td>Unknown</td></tr>
</table></div>
<h3 id="security-descriptor-identifier-sii-index"><a class="header" href="#security-descriptor-identifier-sii-index">Security descriptor identifier ($SII) index</a></h3>
<h4 id="the-security-descriptor-identifier-index-value"><a class="header" href="#the-security-descriptor-identifier-index-value"><a name="security_descriptor_identifier_index_value"></a>The security descriptor identifier index value</a></h4>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td colspan="4"> <em>Key data</em></tr>
<tr><td>0</td><td>4</td><td></td><td>Security descriptor identifier</td></tr>
<tr><td colspan="4"> <em>Value data</em></tr>
<tr><td>4</td><td>4</td><td></td><td>Security descriptor hash</td></tr>
<tr><td>8</td><td>4</td><td></td><td>Security descriptor identifier</td></tr>
<tr><td>12</td><td>8</td><td></td><td>Security descriptor data offset (in $SDS)</td></tr>
<tr><td>20</td><td>4</td><td></td><td>Security descriptor data size (in $SDS)</td></tr>
</table></div>
<p>TODO: describe the hash algorithm</p>
<h3 id="security-descriptor-sds-data-stream"><a class="header" href="#security-descriptor-sds-data-stream">Security descriptor ($SDS) data stream</a></h3>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>4</td><td></td><td>Security descriptor hash</td></tr>
<tr><td>4</td><td>4</td><td></td><td>Security descriptor identifier</td></tr>
<tr><td>12</td><td>8</td><td></td><td>Security descriptor data offset (in $SDS)</td></tr>
<tr><td>20</td><td>4</td><td></td><td>Security descriptor data size (in $SDS)</td></tr>
<tr><td>24</td><td>...</td><td></td><td>Security descriptor data</td></tr>
<tr><td>...</td><td>...</td><td></td><td>Alignment padding (2-byte alignment)</td></tr>
</table></div>
<p>TODO: link to security descriptor format documentation</p>
<h2 id="the-object-identifiers"><a class="header" href="#the-object-identifiers">The object identifiers</a></h2>
<h3 id="objido"><a class="header" href="#objido">$ObjID:$O</a></h3>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td colspan="4"> <em>Key data</em></tr>
<tr><td>0</td><td>16</td><td></td><td>File (or object) identifier, which contains a GUID</td></tr>
<tr><td colspan="4"> <em>Value data</em></tr>
<tr><td>4</td><td>8</td><td></td><td><a href="ntfs.html#file_reference">File reference</a></td></tr>
<tr><td>12</td><td>16</td><td></td><td>Birth droid volume identifier, which contains a GUID</td></tr>
<tr><td>28</td><td>16</td><td></td><td>Birth droid file (or object) identifier, which contains a GUID</td></tr>
<tr><td>44</td><td>16</td><td></td><td>Birth droid domain identifier, which contains a GUID</td></tr>
</table></div>
<h2 id="metadata-transaction-journal-log-file"><a class="header" href="#metadata-transaction-journal-log-file"><a name="log_file"></a>Metadata transaction journal (log file)</a></h2>
<p>TODO: complete section</p>
<p>The metadata file $LogFile contains the metadata transaction journal and
consists of:</p>
<ul>
<li>Log File Service restart page header</li>
<li><a href="ntfs.html#fix_up_values">The fix-up values</a></li>
</ul>
<h3 id="log-file-service-restart-page-header"><a class="header" href="#log-file-service-restart-page-header">Log File service restart page header</a></h3>
<p>The Log File service restart page header (LFS_RESTART_PAGE_HEADER) is 30 bytes
in size and consists of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td colspan="4"> <em>MULTI_SECTOR_HEADER</em></tr>
<tr><td>0</td><td>4</td><td>"CHKD", "RCRD", "RSTR"</td><td>Signature</td></tr>
<tr><td>4</td><td>2</td><td></td><td>The fix-up values (or update sequence array) offset, which contain an offset relative from the start of the restart page header.</td></tr>
<tr><td>6</td><td>2</td><td></td><td>The number of fix-up values (or update sequence array size)</td></tr>
<tr><td colspan="4">  </tr>
<tr><td>8</td><td>8</td><td></td><td>Checkdisk last LSN</td></tr>
<tr><td>16</td><td>4</td><td></td><td>System page size</td></tr>
<tr><td>20</td><td>4</td><td></td><td>Log page size</td></tr>
<tr><td>24</td><td>2</td><td></td><td>Restart offset</td></tr>
<tr><td>26</td><td>2</td><td></td><td>Minor format version</td></tr>
<tr><td>28</td><td>2</td><td></td><td>Major format version</td></tr>
</table></div>
<h4 id="log-file-service-restart-page-versions"><a class="header" href="#log-file-service-restart-page-versions">Log File service restart page versions</a></h4>
<div class="table-wrapper"><table><thead><th>Major format version</th><th>Remarks</th></thead><tr><td>-1</td><td>Beta Version</td></tr>
<tr><td>0</td><td>Transition</td></tr>
<tr><td>1</td><td>Update sequence support</td></tr>
</table></div>
<h2 id="usn-change-journal"><a class="header" href="#usn-change-journal"><a name="usn_change_journal"></a>USN change journal</a></h2>
<p>The metadata file $Extend$UsnJrnl contains the USN change journal. It is a
sparse file in which NTFS stores records of changes to files and directories.
Applications make use of the journal to respond to file and directory changes
as they occur, like e.g. the Windows File Replication Service (FRS) and the
Windows (Desktop) Search service.</p>
<p>The USN change journal consists of:</p>
<ul>
<li>the $UsnJrnl:$Max data stream, containing metadata like the maximum size of the journal</li>
<li>the $UsnJrnl:$J data stream, containing the update (or change) entries. The $UsnJrnl:$J data stream is sparse.</li>
</ul>
<h3 id="usn-change-journal-metadata"><a class="header" href="#usn-change-journal-metadata">USN change journal metadata</a></h3>
<p>The USN change journal metadata is 32 bytes in size and consists of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>8</td><td></td><td>Maximum size in bytes</td></tr>
<tr><td>8</td><td>8</td><td></td><td>Allocation (size) delta in bytes</td></tr>
<tr><td>16</td><td>8</td><td></td><td>Update (USN) journal identifier, which contains a FILETIME</td></tr>
<tr><td>24</td><td>8</td><td></td><td>Unknown (empty)</td></tr>
</table></div>
<h2 id="usn-change-journal-entries"><a class="header" href="#usn-change-journal-entries">USN change journal entries</a></h2>
<p>The $UsnJrnl:$J data stream consists of an array of USN change journal entries.
The USN change journal entries are stored on a per block-basis and 8-byte
aligned. Therefore the remainder of the block can contain 0-byte values.</p>
<p>TODO: describe journal block size</p>
<p>Once the stream reaches maximum size the earliest USN change journal entries
are removed from the stream and replaced with a sparse data run.</p>
<h3 id="usn-change-journal-entry"><a class="header" href="#usn-change-journal-entry">USN change journal entry</a></h3>
<p>The USN change journal entry (USN_RECORD_V2) is of variable size and consists
of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>4</td><td></td><td>Entry (or record) size</td></tr>
<tr><td>4</td><td>2</td><td>2</td><td>Major format version</td></tr>
<tr><td>6</td><td>2</td><td>0</td><td>Minor format version</td></tr>
<tr><td>8</td><td>8</td><td></td><td>File reference</td></tr>
<tr><td>16</td><td>8</td><td></td><td>Parent file reference</td></tr>
<tr><td>24</td><td>8</td><td></td><td>Update sequence number (USN), which contains the file offset of the USN change journal entry which is used as a unique identifier</td></tr>
<tr><td>32</td><td>8</td><td></td><td>Update date and time, which contains a FILETIME</td></tr>
<tr><td>40</td><td>4</td><td></td><td><a href="ntfs.html#update_reason_flags">Update reason flags</a></td></tr>
<tr><td>44</td><td>4</td><td></td><td><a href="ntfs.html#update_source_flags">Update source flags</a></td></tr>
<tr><td>48</td><td>4</td><td></td><td>Security descriptor identifier, which contains the entry number in the security ID index ($Secure:$SII). Also see <a href="ntfs.html#access_control">Access Control</a></td></tr>
<tr><td>52</td><td>4</td><td></td><td><a href="ntfs.html#file_attribute_flags">File attribute flags</a></td></tr>
<tr><td>56</td><td>2</td><td></td><td>Name size in bytes</td></tr>
<tr><td>58</td><td>2</td><td></td><td>Name offset, which is relative from the start of the USN change journal entry</td></tr>
<tr><td>60</td><td>(name size)</td><td></td><td>Name, which contains an UCS-2 little-endian string without end-of-string character</td></tr>
<tr><td>...</td><td>...</td><td>0x00</td><td>Unknown (Padding)</td></tr>
</table></div>
<h4 id="update-reason-flags"><a class="header" href="#update-reason-flags"><a name="update_reason_flags"></a>Update reason flags</a></h4>
<div class="table-wrapper"><table><thead><th>Value</th><th>Identifier</th><th>Description</th></thead><tr><td>0x00000001</td><td>USN_REASON_DATA_OVERWRITE</td><td>The data in the file or directory is overwritten.</td></tr>
<tr><td>0x00000002</td><td>USN_REASON_DATA_EXTEND</td><td>The file or directory is extended.</td></tr>
<tr><td>0x00000004</td><td>USN_REASON_DATA_TRUNCATION</td><td>The file or directory is truncated.</td></tr>
<tr><td></td><td></td><td></td></tr>
<tr><td>0x00000010</td><td>USN_REASON_NAMED_DATA_OVERWRITE</td><td>One or more named data streams ($DATA attributes) of file were overwritten</td></tr>
<tr><td>0x00000020</td><td>USN_REASON_NAMED_DATA_EXTEND</td><td>One or more named data streams ($DATA attributes) of file were extended</td></tr>
<tr><td>0x00000040</td><td>USN_REASON_NAMED_DATA_TRUNCATION</td><td>One or more named data streams ($DATA attributes) of a file were truncated</td></tr>
<tr><td></td><td></td><td></td></tr>
<tr><td>0x00000100</td><td>USN_REASON_FILE_CREATE</td><td>The file or directory was created</td></tr>
<tr><td>0x00000200</td><td>USN_REASON_FILE_DELETE</td><td>The file or directory was deleted</td></tr>
<tr><td>0x00000400</td><td>USN_REASON_EA_CHANGE</td><td>The extended attributes of the file were changed</td></tr>
<tr><td>0x00000800</td><td>USN_REASON_SECURITY_CHANGE</td><td>The access rights (security descriptor) of a file or directory were changed</td></tr>
<tr><td>0x00001000</td><td>USN_REASON_RENAME_OLD_NAME</td><td>The name changed, where the USN change journal entry contains the old name</td></tr>
<tr><td>0x00002000</td><td>USN_REASON_RENAME_NEW_NAME</td><td>The name changed, where the USN change journal entry contains the new name</td></tr>
<tr><td>0x00004000</td><td>USN_REASON_INDEXABLE_CHANGE</td><td>Content indexed status changed. The file attribute FILE_ATTRIBUTE_NOT_CONTENT_INDEXED was changed</td></tr>
<tr><td>0x00008000</td><td>USN_REASON_BASIC_INFO_CHANGE</td><td>Basic file or directory attributes changed. One or more file or directory attributes were changed e.g. read-only, hidden, system, archive, or sparse attribute, or one or more time stamps.</td></tr>
<tr><td>0x00010000</td><td>USN_REASON_HARD_LINK_CHANGE</td><td>A hard link was created or deleted</td></tr>
<tr><td>0x00020000</td><td>USN_REASON_COMPRESSION_CHANGE</td><td>The file or directory was compressed or decompressed</td></tr>
<tr><td>0x00040000</td><td>USN_REASON_ENCRYPTION_CHANGE</td><td>The file or directory was encrypted or decrypted</td></tr>
<tr><td>0x00080000</td><td>USN_REASON_OBJECT_ID_CHANGE</td><td>The object identifier of a file or directory was changed</td></tr>
<tr><td>0x00100000</td><td>USN_REASON_REPARSE_POINT_CHANGE</td><td>The reparse point that in a file or directory was changed, or a reparse point was added to or deleted from a file or directory.</td></tr>
<tr><td>0x00200000</td><td>USN_REASON_STREAM_CHANGE</td><td>A named data stream ($DATA attribute) is added to or removed from a file, or a named stream is renamed</td></tr>
<tr><td>0x00400000</td><td>USN_REASON_TRANSACTED_CHANGE</td><td>Unknown</td></tr>
<tr><td></td><td></td><td></td></tr>
<tr><td>0x80000000</td><td>USN_REASON_CLOSE</td><td>The file or directory was closed</td></tr>
</table></div>
<h4 id="update-source-flags"><a class="header" href="#update-source-flags"><a name="update_source_flags"></a>Update source flags</a></h4>
<div class="table-wrapper"><table><thead><th>Value</th><th>Identifier</th><th>Description</th></thead><tr><td>0x00000001</td><td>USN_SOURCE_DATA_MANAGEMENT</td><td>The operation added a private data stream to a file or directory. The modifications did not change the application data.</td></tr>
<tr><td>0x00000002</td><td>USN_SOURCE_AUXILIARY_DATA</td><td>The operation was caused by the operating system. Although a write operation is performed on the item, the data was not changed.</td></tr>
<tr><td>0x00000004</td><td>USN_SOURCE_REPLICATION_MANAGEMENT</td><td>The operation was caused by file replication</td></tr>
</table></div>
<h2 id="alternate-data-streams-ads"><a class="header" href="#alternate-data-streams-ads">Alternate data streams (ADS)</a></h2>
<div class="table-wrapper"><table><thead><th>Data stream name</th><th>Description</th></thead><tr><td>"♣BnhqlkugBim0elg1M1pt2tjdZe", "♣SummaryInformation", "{4c8cc155-6c1e-11d1-8e41-00c04fb9386d}"</td><td>Used to store properties, where ♣ (black club) is Unicode character U+2663</td></tr>
<tr><td>"{59828bbb-3f72-4c1b-a420-b51ad66eb5d3}.XPRESS"</td><td>Used during remote differential compression</td></tr>
<tr><td>"AFP_AfpInfo", "AFP_Resource"</td><td>Used to store Macintosh operating system property lists</td></tr>
<tr><td>"encryptable"</td><td>Used to store attributes relating to thumbnails in the thumbnails database</td></tr>
<tr><td>"favicon"</td><td>Used to store favorite icons for web pages</td></tr>
<tr><td>"ms-properties"</td><td>Used to store properties</td></tr>
<tr><td>"OECustomProperty"</td><td>Used to store custom properties related to email files</td></tr>
<tr><td>"Zone.Identifier"</td><td>Used to store the Internet Explorere URL security zone of the origin</td></tr>
</table></div>
<h3 id="ms-properties"><a class="header" href="#ms-properties">ms-properties</a></h3>
<p>The ms-properties alternate data stream contains a Windows Serialized Property
Store (SPS).</p>
<p>TODO: link to Windows Serialized Property Store (SPS) format documentation</p>
<h3 id="zoneidentifier"><a class="header" href="#zoneidentifier">Zone.Identifier</a></h3>
<p>The Zone.Identifier alternate data stream contains ASCII text in the form:</p>
<pre><code>[ZoneTransfer]
ZoneId=3
</code></pre>
<p>Where ZoneId refers to the <a href="https://learn.microsoft.com/en-us/previous-versions/windows/internet-explorer/ie-developer/platform-apis/ms537183(v=vs.85)">Internet Explorer URL security zone</a>
of the origin.</p>
<h2 id="transactional-ntfs-txf"><a class="header" href="#transactional-ntfs-txf"><a name="transactional_ntfs"></a>Transactional NTFS (TxF)</a></h2>
<p>As of Vista Transactional NTFS (TxF) was added.</p>
<p>In TxF the resource manager (RM) keeps track of transactional metadata and log
files. The TxF related metadata files are stored in the metadata directory:</p>
<pre><code>$Extend\$RmMetadata
</code></pre>
<h3 id="resource-manager-repair-information"><a class="header" href="#resource-manager-repair-information">Resource manager repair information</a></h3>
<p>The resource manager repair information metadata file:
$Extend$RmMetadata$Repair consists of the following data streams:</p>
<ul>
<li>the default (unnamed) data stream</li>
<li>the $Config data stream, contains the resource manager repair configuration information</li>
</ul>
<p>TODO: determine the purpose of the default (unnamed) data stream</p>
<h4 id="resource-manager-repair-configuration-information"><a class="header" href="#resource-manager-repair-configuration-information">Resource manager repair configuration information</a></h4>
<p>TODO: complete section</p>
<p>The $Repair:$Config data streams contains:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>4</td><td></td><td>Unknown</td></tr>
<tr><td>4</td><td>4</td><td></td><td>Unknown</td></tr>
</table></div>
<h3 id="transactional-ntfs-txf-metadata-directory"><a class="header" href="#transactional-ntfs-txf-metadata-directory">Transactional NTFS (TxF) metadata directory</a></h3>
<p>TODO: complete section</p>
<p>The transactional NTFS (TxF) metadata directory: $Extend$RmMetadata$Txf is
used to isolate files for delete or overwrite operations.</p>
<h3 id="txf-old-page-stream-tops-file"><a class="header" href="#txf-old-page-stream-tops-file">TxF Old Page Stream (TOPS) file</a></h3>
<p>The TxF Old Page Stream (TOPS) file: $Extend$RmMetadata$TxfLog$Tops consists
of the following data streams:</p>
<ul>
<li>the default (unnamed) data stream, contains metadata about the resource manager, such as its GUID, its CLFS log policy, and the LSN at which recovery should start</li>
<li>the $T data stream, contains the file data that is partially overwritten by a transaction as opposed to a full overwrite, which would move the file into the Transactional NTFS (TxF) metadata directory</li>
</ul>
<h4 id="txf-old-page-stream-tops-metadata"><a class="header" href="#txf-old-page-stream-tops-metadata">TxF Old Page Stream (TOPS) metadata</a></h4>
<p>TODO: complete section</p>
<p>The $Tops default (unnamed) data streams contains:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>2</td><td></td><td>Unknown</td></tr>
<tr><td>2</td><td>2</td><td></td><td>Size of TOPS metadata</td></tr>
<tr><td>4</td><td>4</td><td></td><td>Unknown (Number of resource managers/streams?)</td></tr>
<tr><td>8</td><td>16</td><td></td><td>Resource Manager (RM) identifier, which contains a GUID</td></tr>
<tr><td>24</td><td>8</td><td></td><td>Unknown (empty)</td></tr>
<tr><td>32</td><td>8</td><td></td><td>Base (or log start) LSN of TxFLog stream</td></tr>
<tr><td>40</td><td>8</td><td></td><td>Unknown</td></tr>
<tr><td>48</td><td>8</td><td></td><td>Last flushed LSN of TxFLog stream</td></tr>
<tr><td>56</td><td>8</td><td></td><td>Unknown</td></tr>
<tr><td>64</td><td>8</td><td></td><td>Unknown (empty)</td></tr>
<tr><td>72</td><td>8</td><td></td><td>Unknown (Restart LSN?)</td></tr>
<tr><td>80</td><td>20</td><td></td><td>Unknown</td></tr>
</table></div>
<h4 id="txf-old-page-stream-tops-file-data"><a class="header" href="#txf-old-page-stream-tops-file-data">TxF Old Page Stream (TOPS) file data</a></h4>
<p>The $Tops:$T data streams contains the file data that is partially overwritten
by a transaction. It consists of multiple pending transaction XML-documents.</p>
<p>TODO: describe start of each sector containing 0x0001</p>
<p>A pending transaction XML-document starts with an UTF-8 byte-order-mark. Is
roughly contains the following data:</p>
<pre><code>&lt;?xml version='1.0' encoding='utf-8'?&gt;
&lt;PendingTransaction Version="2.0" Identifier="..."&gt;
   &lt;Transactions&gt;
      &lt;Transaction TransactionId="..."&gt;
      &lt;Install Application="..., Culture=..., Version=..., PublicKeyToken=...,
                           ProcessorArchitecture=..., versionScope=..."
               RefGuid="..."
               RefIdentifier="..."
               RefExtra="..."/&gt;
      ...
      &lt;/Transaction&gt;
   &lt;/Transactions&gt;
   &lt;ChangeList&gt;
      &lt;Change Family="..., Culture=..., PublicKeyToken=...,
                     ProcessorArchitecture=..., versionScope=..."
              New="..."/&gt;
      ...
   &lt;/ChangeList&gt;
   &lt;POQ&gt;
      &lt;BeginTransaction id="..."/&gt;

      &lt;CreateFile path="..."
                  fileAttribute="..."/&gt;
      &lt;DeleteFile path="..."/&gt;
      &lt;MoveFile source="..." destination="..."/&gt;
      &lt;HardlinkFile source="..." destination="..."/&gt;
      &lt;SetFileInformation path="..."
                          securityDescriptor="binary base64:..."
                          flags="..."/&gt;

       &lt;CreateKey path="..."/&gt;
       &lt;SetKeyValue path="..."
                    name="..."
                    type="..."
                    encoding="base64"
                    value="..."/&gt;
      &lt;DeleteKeyValue path="..."
                      name="..."/&gt;

      ...
   &lt;/POQ&gt;
   &lt;InstallerQueue Length="..."&gt;
      &lt;Action Installer="..."
              Mode="..."
              Phase="..."
              Family="..., Culture=..., PublicKeyToken=...,
                     ProcessorArchitecture=..., versionScope=..."
              Old="..."
              New="..."/&gt;

      ...
   &lt;/InstallerQueue &gt;
&lt;/PendingTransaction&gt;
</code></pre>
<h3 id="transactional-ntfs-txf-common-log-file-system-clfs-files"><a class="header" href="#transactional-ntfs-txf-common-log-file-system-clfs-files">Transactional NTFS (TxF) Common Log File System (CLFS) files</a></h3>
<p>TxF uses a Common Log File System (CLFS) log store and the logged utility
stream attribute named $TXF_DATA.</p>
<p>TODO: link to CLFS format documentation</p>
<p>The base log file (BLF) of the TxF log store is:</p>
<pre><code>$Extend\$RmMetadata\$TxfLog\TxfLog.blf
</code></pre>
<p>Commonly the corresponding container files are:</p>
<pre><code>$Extend\$RmMetadata\$TxfLog\TxfLogContainer00000000000000000001
$Extend\$RmMetadata\$TxfLog\TxfLogContainer00000000000000000002
</code></pre>
<p>TxF uses a multiplexed log store which contains the following streams:</p>
<ul>
<li>the KtmLog stream used for Kernel Transaction Manager (KTM) metadata records</li>
<li>TxfLog stream, which contains the TxF log records.</li>
</ul>
<h3 id="transactional-data-logged-utility-stream-attribute"><a class="header" href="#transactional-data-logged-utility-stream-attribute">Transactional data logged utility stream attribute</a></h3>
<p>The transactional data ($TXF_DATA) logged utility stream attribute is 56 bytes
in size and consist of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>6</td><td></td><td>Unknown (remnant data)</td></tr>
<tr><td>6</td><td>8</td><td></td><td>Resource manager root file reference, which contains an NTFS file reference that refers to the MFT</td></tr>
<tr><td>14</td><td>8</td><td></td><td>Unknown (USN index?)</td></tr>
<tr><td>22</td><td>8</td><td></td><td>File identifier (TxID), which contains a TxF file identifier</td></tr>
<tr><td>30</td><td>8</td><td></td><td>Data LSN, which contains a CLFS LSN of file data transaction records</td></tr>
<tr><td>38</td><td>8</td><td></td><td>Metadata LSN, which contains a CLFS LSN of file system metadata transaction records</td></tr>
<tr><td>46</td><td>8</td><td></td><td>Directory index LSN, which contains a CLFS LSN of directory index transaction records</td></tr>
<tr><td>54</td><td>2</td><td></td><td>Unknown (Flags?)</td></tr>
</table></div>
<blockquote>
<p>Note that a single MFT entry can contain multiple Transactional data logged
utility stream attributes.</p>
</blockquote>
<h2 id="windows-definitions"><a class="header" href="#windows-definitions">Windows definitions</a></h2>
<h3 id="file-attribute-flags-2"><a class="header" href="#file-attribute-flags-2"><a name="file_attribute_flags"></a>File attribute flags</a></h3>
<p>The file attribute flags consist of the following values:</p>
<div class="table-wrapper"><table><thead><th>Value</th><th>Identifier</th><th>Description</th></thead><tr><td>0x00000001</td><td>FILE_ATTRIBUTE_READONLY</td><td>Is read-only</td></tr>
<tr><td>0x00000002</td><td>FILE_ATTRIBUTE_HIDDEN</td><td>Is hidden</td></tr>
<tr><td>0x00000004</td><td>FILE_ATTRIBUTE_SYSTEM</td><td>Is a system file or directory</td></tr>
<tr><td>0x00000008</td><td></td><td>Is a volume label, which is not used by NTFS</td></tr>
<tr><td>0x00000010</td><td>FILE_ATTRIBUTE_DIRECTORY</td><td>Is a directory, which is not used by NTFS</td></tr>
<tr><td>0x00000020</td><td>FILE_ATTRIBUTE_ARCHIVE</td><td>Should be archived</td></tr>
<tr><td>0x00000040</td><td>FILE_ATTRIBUTE_DEVICE</td><td>Is a device, which is not used by NTFS</td></tr>
<tr><td>0x00000080</td><td>FILE_ATTRIBUTE_NORMAL</td><td>Is normal file. Note that none of the other flags should be set</td></tr>
<tr><td>0x00000100</td><td>FILE_ATTRIBUTE_TEMPORARY</td><td>Is temporary</td></tr>
<tr><td>0x00000200</td><td>FILE_ATTRIBUTE_SPARSE_FILE</td><td>Is a sparse file</td></tr>
<tr><td>0x00000400</td><td>FILE_ATTRIBUTE_REPARSE_POINT</td><td>Is a reparse point or symbolic link</td></tr>
<tr><td>0x00000800</td><td>FILE_ATTRIBUTE_COMPRESSED</td><td>Is compressed</td></tr>
<tr><td>0x00001000</td><td>FILE_ATTRIBUTE_OFFLINE</td><td>Is offline. The data of the file is stored on an offline storage.</td></tr>
<tr><td>0x00002000</td><td>FILE_ATTRIBUTE_NOT_CONTENT_INDEXED</td><td>Do not index content. The content of the file or directory should not be indexed by the indexing service.</td></tr>
<tr><td>0x00004000</td><td>FILE_ATTRIBUTE_ENCRYPTED</td><td>Is encrypted</td></tr>
<tr><td>0x00008000</td><td></td><td>Unknown (seen on Windows 95 FAT)</td></tr>
<tr><td>0x00010000</td><td>FILE_ATTRIBUTE_VIRTUAL</td><td>Is virtual</td></tr>
</table></div>
<p>The following flags are mainly used in the file name attribute and sparsely in
the standard information attribute. It could be that they have a different
meaning in both types of attributes or that the standard information flags are
not updated. For now the latter is assumed.</p>
<div class="table-wrapper"><table><thead><th>Value</th><th>Identifier</th><th>Description</th></thead><tr><td>0x10000000</td><td></td><td>Unknown (Is directory or has $I30 index? Note that an $Extend directory without this flag has been observed)</td></tr>
<tr><td>0x20000000</td><td></td><td>Is index view</td></tr>
</table></div>
<h2 id="corruption-scenarios-1"><a class="header" href="#corruption-scenarios-1"><a name="corruption_scenarios"></a>Corruption scenarios</a></h2>
<h3 id="data-steam-with-inconsistent-data-flags"><a class="header" href="#data-steam-with-inconsistent-data-flags">Data steam with inconsistent data flags</a></h3>
<p>An MFT entry contains an $ATTRIBUTE_LIST attribute that contains multiple $DATA
attributes. The $DATA attributes define a LZNT1 compressed data stream though
only the first $DATA attribute has the compressed data flag set.</p>
<blockquote>
<p>Note that it is unclear if this is a corruption scenario or not.</p>
</blockquote>
<pre><code>MFT entry: 220 information:
    Is allocated                   : true
    File reference                 : 220-59
    Base record file reference     : Not set (0)
    Journal sequence number        : 51876429013
    Number of attributes           : 5

Attribute: 1
    Type                           : $STANDARD_INFORMATION (0x00000010)
    Creation time                  : Jun 05, 2019 06:56:26.032730300 UTC
    Modification time              : Oct 05, 2019 06:56:04.150940700 UTC
    Access time                    : Oct 05, 2019 06:56:04.150940700 UTC
    Entry modification time        : Oct 05, 2019 06:56:04.150940700 UTC
    Owner identifier               : 0
    Security descriptor identifier : 5862
    Update sequence number         : 11553149976
    File attribute flags           : 0x00000820
       Should be archived (FILE_ATTRIBUTE_ARCHIVE)
       Is compressed (FILE_ATTRIBUTE_COMPRESSED)

Attribute: 2
    Type                           : $ATTRIBUTE_LIST (0x00000020)

Attribute: 3
    Type                           : $FILE_NAME (0x00000030)
    Parent file reference          : 33996-57
    Creation time                  : Jun 05, 2019 06:56:26.032730300 UTC
    Modification time              : Oct 05, 2019 06:56:03.510061800 UTC
    Access time                    : Oct 05, 2019 06:56:03.510061800 UTC
    Entry modification time        : Oct 05, 2019 06:56:03.510061800 UTC
    File attribute flags           : 0x00000020
       Should be archived (FILE_ATTRIBUTE_ARCHIVE)
    Namespace                      : POSIX (0)
    Name                           : setupapi.dev.20191005_085603.log

Attribute: 4
    Type                           : $DATA (0x00000080)
    Data VCN range                 : 513 - 1103
    Data flags                     : 0x0000

Attribute: 5
    Type                           : $DATA (0x00000080)
    Data VCN range                 : 0 - 512
    Data size                      : 4487594 bytes
    Data flags                     : 0x0001
</code></pre>
<h3 id="directory-entry-with-outdated-file-reference"><a class="header" href="#directory-entry-with-outdated-file-reference">Directory entry with outdated file reference</a></h3>
<p>The directory entry: \ProgramData\McAfee\Common Framework\Task\5.ini</p>
<pre><code>File entry:
    Path                           : \ProgramData\McAfee\Common Framework\Task\5.ini
    File reference                 : 51106-400
    Name                           : 5.ini
    Parent file reference          : 65804-10
    Size                           : 723
    Creation time                  : Sep 16, 2011 20:47:54.561041200 UTC
    Modification time              : Apr 07, 2012 21:07:02.684060000 UTC
    Access time                    : Apr 07, 2012 21:07:02.652810200 UTC
    Entry modification time        : Apr 07, 2012 21:07:02.684060000 UTC
    File attribute flags           : 0x00002020
       Should be archived (FILE_ATTRIBUTE_ARCHIVE)
       Content should not be indexed (FILE_ATTRIBUTE_NOT_CONTENT_INDEXED)
</code></pre>
<p>The corresponding MFT entry:</p>
<pre><code>MFT entry: 51106 information:
    Is allocated                   : true
    File reference                 : 51106-496
    Base record file reference     : Not set (0)
    Journal sequence number        : 0
    Number of attributes           : 3

Attribute: 1
    Type                           : $STANDARD_INFORMATION (0x00000010)
    Creation time                  : Sep 16, 2011 20:47:54.561041200 UTC
    Modification time              : Apr 07, 2012 21:07:02.684060000 UTC
    Access time                    : Apr 07, 2012 21:07:02.652810200 UTC
    Entry modification time        : Apr 07, 2012 21:07:02.684060000 UTC
    Owner identifier               : 0
    Security descriptor identifier : 1368
    Update sequence number         : 1947271600
    File attribute flags           : 0x00002020
       Should be archived (FILE_ATTRIBUTE_ARCHIVE)
       Content should not be indexed (FILE_ATTRIBUTE_NOT_CONTENT_INDEXED)

Attribute: 2
    Type                           : $FILE_NAME (0x00000030)
    Parent file reference          : 65804-10
    Creation time                  : Sep 16, 2011 20:47:54.561041200 UTC
    Modification time              : Apr 07, 2012 21:07:02.652810200 UTC
    Access time                    : Apr 07, 2012 21:07:02.652810200 UTC
    Entry modification time        : Apr 07, 2012 21:07:02.652810200 UTC
    File attribute flags           : 0x00002020
       Should be archived (FILE_ATTRIBUTE_ARCHIVE)
       Content should not be indexed (FILE_ATTRIBUTE_NOT_CONTENT_INDEXED)
    Namespace                      : DOS and Windows (3)
    Name                           : 1.ini

Attribute: 3
    Type                           : $DATA (0x00000080)
    Data size                      : 723 bytes
    Data flags                     : 0x0000
</code></pre>
<p>TODO: determine if $LogFile could be used to recover from this corruption scenario</p>
<h3 id="lznt1-compressed-block-with-data-size-of-0"><a class="header" href="#lznt1-compressed-block-with-data-size-of-0">LZNT1 compressed block with data size of 0</a></h3>
<p>Not sure if this is a corruption scenario or a data format edge case.</p>
<p>A compression unit (index 30) consisting of the following data runs:</p>
<pre><code>reading data run: 60.
data run:
00000000: 11 01 01                                           ...

value sizes                               : 1, 1
number of cluster blocks                  : 1 (size: 4096)
cluster block number                      : 687143 (1) (offset: 0xa7c27000)

reading data run: 61.
data run:
00000000: 01 0f                                              ..

value sizes                               : 1, 0
number of cluster blocks                  : 15 (size: 61440)
cluster block number                      : 0 (0) (offset: 0x00000000)
        Is sparse
</code></pre>
<p>Contains the following data:</p>
<pre><code>a7c27000  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
...
a7c27ff0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
</code></pre>
<p>This relates to an empty LZNT1 compressed block.</p>
<pre><code>compressed data offset                    : 0 (0x00000000)
compression chunk header                  : 0x0000
compressed chunk size                     : 1
signature value                           : 0
is compressed flag                        : 0
</code></pre>
<p>It was observed in 2 differnt NTFS implementations that the entire block is
filled with 0-byte values.</p>
<p>TODO: verify behavior of Windows NTFS implementation.</p>
<h3 id="truncated-lznt1-compressed-block"><a class="header" href="#truncated-lznt1-compressed-block">Truncated LZNT1 compressed block</a></h3>
<p>Not sure if this is a corruption scenario or a data format edge case.</p>
<p>A compression unit (index 0) consisting of the following data runs:</p>
<pre><code>reading data run: 0.
data run:
00000000: 31 08 48 d8 01                                     1.H..

value sizes                               : 1, 3
number of cluster blocks                  : 8 (size: 32768)
cluster block number                      : 120904 (120904) (offset: 0x1d848000)

reading data run: 1.
data run:
00000000: 01 08                                              ..

value sizes                               : 1, 0
number of cluster blocks                  : 8 (size: 32768)
cluster block number                      : 0 (0) (offset: 0x00000000)
        Is sparse
</code></pre>
<p>Contains the following data:</p>
<pre><code>1d848000  bd b7 50 44 46 50 00 01  00 01 00 40 e0 00 07 0b  |..PDFP.....@....|
...
1d84c000  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
*
1d84fff0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
</code></pre>
<p>This relates to a LZNT1 compressed block that appears to be truncated at offset
16384 (0x00004000).</p>
<pre><code>compressed data offset                    : 16384 (0x00004000)
compression flag byte                     : 0x00
</code></pre>
<p>Different behavior was observed in 2 differnt NTFS implementations:</p>
<ul>
<li>one implementation fills the compressed block with the uncompressed data it could read and the rest with with 0-byte values</li>
<li>another implementation seems to provide the data that was already in its buffer</li>
</ul>
<p>TODO: verify behavior of Windows NTFS implementation.</p>
<h2 id="references-7"><a class="header" href="#references-7">References</a></h2>
<ul>
<li><a href="https://learn.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2003/cc781134(v=ws.10)">How NTFS Works</a>, by Microsoft</li>
<li><a href="https://learn.microsoft.com/en-us/windows/win32/devnotes/master-file-table">Master File Table</a>, by Microsoft</li>
<li><a href="https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-fscc/a82e9105-2405-4e37-b2c3-28c773902d85">NTFS Attribute Types</a>, by Microsoft</li>
<li><a href="https://learn.microsoft.com/en-us/windows/win32/fileio/file-attribute-constants">File Attribute Constants</a>, by Microsoft</li>
<li><a href="https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-fscc/c8e77b37-3909-4fe6-a4ea-2b9d423b1ee4">Reparse Tags</a>, by Microsoft</li>
<li><a href="https://flatcap.github.io/linux-ntfs/ntfs/">NTFS documentation</a>, by Richard Russon</li>
<li><a href="https://learn.microsoft.com/en-us/windows/win32/devnotes/attribute-list-entry">ATTRIBUTE_LIST_ENTRY structure</a>, by Microsoft</li>
<li><a href="https://learn.microsoft.com/en-us/windows/win32/devnotes/attribute-record-header">ATTRIBUTE_RECORD_HEADER structure</a>, by Microsoft</li>
<li><a href="https://learn.microsoft.com/en-us/windows/win32/devnotes/file-record-segment-header">FILE_RECORD_SEGMENT_HEADER structure</a>, by Microsoft</li>
<li><a href="https://learn.microsoft.com/en-us/windows/win32/devnotes/multi-sector-header">MULTI_SECTOR_HEADER structure</a>, by Microsoft</li>
<li><a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/ntifs/ns-ntifs-_reparse_data_buffer">REPARSE_DATA_BUFFER structure (ntifs.h)</a>, by Microsoft</li>
<li><a href="https://learn.microsoft.com/en-us/windows-hardware/drivers/ddi/ntifs/ns-ntifs-_reparse_data_buffer_ex">REPARSE_DATA_BUFFER_EX structure (ntifs.h)</a>, by Microsoft</li>
<li><a href="https://learn.microsoft.com/en-us/windows/win32/api/winioctl/ns-winioctl-usn_record_v2">USN_RECORD_V2</a>, by Microsoft</li>
<li><a href="https://learn.microsoft.com/en-us/openspecs/windows_protocols/ms-fscc/6e3f7352-d11c-4d76-8c39-2516a9df36e8">Zone.Identifier Stream Name</a>, by Microsoft</li>
<li><a href="https://learn.microsoft.com/en-us/previous-versions/windows/internet-explorer/ie-developer/platform-apis/ms537183(v=vs.85)">the Internet Explorer URL security zone</a>, by Microsoft</li>
<li><a href="https://ultradefrag.net/doc/man/ntfs/ntfs_layout.h.html">ntfs_layout.h</a>, by Anton Altaparmakov</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="assorted-formats"><a class="header" href="#assorted-formats">Assorted formats</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="property-list-plist-format"><a class="header" href="#property-list-plist-format">Property list (plist) format</a></h1>
<p>The property list (plist) formats are used to store various kinds of data, for
example configuration data. The format is know to be used stand-alone as well
as embedded in other data formats.</p>
<h2 id="overview-14"><a class="header" href="#overview-14">Overview</a></h2>
<p>Known plist formats are:</p>
<ul>
<li>ASCII plist format</li>
<li>Binary plist format</li>
<li>XML plist format</li>
</ul>
<p>TODO: What about other plist formats like JSON?</p>
<h3 id="value-types"><a class="header" href="#value-types">Value types</a></h3>
<div class="table-wrapper"><table><thead><th>Type</th><th>Description</th></thead><tr><td>array</td><td>Collection of plist values without key</td></tr>
<tr><td>boolean</td><td>Boolean value</td></tr>
<tr><td>data</td><td>Binary data</td></tr>
<tr><td>date</td><td>Date and time value</td></tr>
<tr><td>dictionary</td><td>Collection of plist values with key</td></tr>
<tr><td>integer</td><td>Signed integer value</td></tr>
<tr><td>real</td><td>Floating-point value</td></tr>
<tr><td>string</td><td>String value</td></tr>
</table></div>
<h2 id="ascii-plist-format"><a class="header" href="#ascii-plist-format">ASCII plist format</a></h2>
<p>TODO: complete section</p>
<h2 id="binary-plist-format"><a class="header" href="#binary-plist-format">Binary plist format</a></h2>
<p>A binary plist file consists of:</p>
<ul>
<li>header</li>
<li>object table</li>
<li>offset table</li>
<li>trailer</li>
</ul>
<div class="table-wrapper"><table><thead><th>Characteristics</th><th>Description</th></thead><tr><td>Byte order</td><td>big-endian</td></tr>
<tr><td>Date and time values</td><td>Number of seconds since Jan 1, 2001 00:00:00 UTC</td></tr>
<tr><td>Character strings</td><td>UTF-16 big-endian</td></tr>
</table></div>
<h3 id="binary-plist-header"><a class="header" href="#binary-plist-header">Binary plist header</a></h3>
<p>The binary plist header (CFBinaryPlistHeader) is 8 bytes in size and consists
of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>6</td><td>"bplist"</td><td>Signature</td></tr>
<tr><td>6</td><td>2</td><td></td><td>Format version</td></tr>
</table></div>
<h4 id="format-versions"><a class="header" href="#format-versions">Format versions</a></h4>
<div class="table-wrapper"><table><thead><th>Version</th><th>Description</th></thead><tr><td>"00"</td><td>Supported as of Tiger</td></tr>
<tr><td>"01"</td><td>Supported as of Leopard</td></tr>
<tr><td>"0x"</td><td>Supported as of Snow Leopard, where x is any character</td></tr>
</table></div>
<h3 id="object-table"><a class="header" href="#object-table">Object table</a></h3>
<p>The object table consists of:</p>
<ul>
<li>zero or more objects</li>
</ul>
<p>Objects are of variable size and consist of:</p>
<ul>
<li>an object maker byte</li>
<li>(optional) object data</li>
</ul>
<h4 id="object-marker-byte"><a class="header" href="#object-marker-byte">Object marker byte</a></h4>
<div class="table-wrapper"><table><thead><th>Value</th><th>Identifier</th><th>Description</th></thead><tr><td>0x00</td><td>kCFBinaryPlistMarkerNull</td><td>Empty value (NULL)</td></tr>
<tr><td></td><td></td><td></td></tr>
<tr><td>0x08</td><td>kCFBinaryPlistMarkerFalse</td><td>Boolean False</td></tr>
<tr><td>0x09</td><td>kCFBinaryPlistMarkerTrue</td><td>Boolean True</td></tr>
<tr><td></td><td></td><td></td></tr>
<tr><td>0x0f</td><td>kCFBinaryPlistMarkerFill</td><td>Unknown (Fill byte?)</td></tr>
<tr><td>0x1#</td><td>kCFBinaryPlistMarkerInt</td><td>Integer, where 2^# is the number of bytes</td></tr>
<tr><td>0x2#</td><td>kCFBinaryPlistMarkerInt</td><td>Floating point, where 2^# is the number of bytes</td></tr>
<tr><td></td><td></td><td></td></tr>
<tr><td>0x33</td><td>kCFBinaryPlistMarkerDate</td><td>Date and time value, which is stored as a 64-bits floating point that contains the number of seconds since Jan 1, 2001 00:00:00 UTC</td></tr>
<tr><td></td><td></td><td></td></tr>
<tr><td>0x4#</td><td>kCFBinaryPlistMarkerData</td><td>Binary data, where # is the number of bytes. If # is 15 then the object marker byte is followed by a 32-bit integer that contains the size of the data.</td></tr>
<tr><td>0x5#</td><td>kCFBinaryPlistMarkerASCIIString</td><td>ASCII string, where # is the number of characters. If # is 15 then the object marker byte is followed by an integer object that contains the number of characters in the string. The string is stored in ASCII (with codepage?) without an end-of-string marker</td></tr>
<tr><td>0x6#</td><td>kCFBinaryPlistMarkerUnicode16String</td><td>Unicode string, where # is the number of characters. If # is 15 then the object marker byte is followed by an integer object that contains the number of characters in the string. The string is stored in UTF-16 big-endian without an end-of-string marker</td></tr>
<tr><td>0x7#</td><td></td><td>Unused</td></tr>
<tr><td>0x8#</td><td>kCFBinaryPlistMarkerUID</td><td>UID, where # + 1 is the number of bytes.</td></tr>
<tr><td>0x9#</td><td></td><td>Unused</td></tr>
<tr><td>0xa#</td><td>kCFBinaryPlistMarkerArray</td><td>Array of objects, where # is the number of elements. If # is 15 then the object marker byte is followed by an integer object that contains the number of elements in the array.</td></tr>
<tr><td>0xb#</td><td></td><td>Unused</td></tr>
<tr><td>0xc#</td><td>kCFBinaryPlistMarkerSet</td><td>Set of objects, where # is the number of elements. If # is 15 then the object marker byte is followed by an integer object that contains the number of ele,emts in the set.</td></tr>
<tr><td>0xd#</td><td>kCFBinaryPlistMarkerDict</td><td>Dictionary of key value pairs, where # is the number of key value pairs. If # is 15 then the object marker byte is followed by an integer object that contains the number of key value pairs in the dictionary.</td></tr>
<tr><td>0xe#</td><td></td><td>Unused</td></tr>
<tr><td>0xf#</td><td></td><td>Unused</td></tr>
</table></div>
<h4 id="array-object"><a class="header" href="#array-object">Array object</a></h4>
<p>The array object consists of:</p>
<ul>
<li>array object marker with number of elements</li>
<li>array of object references that identify the element objects.</li>
<li>the element object data</li>
</ul>
<p>The byte size of the object reference is defined in the trailer. An object
reference of 1 will refer to the first object in the (object) offset table.</p>
<h4 id="set-object"><a class="header" href="#set-object">Set object</a></h4>
<p>The set object consists of:</p>
<ul>
<li>set object marker with number of elements</li>
<li>array of object references that identify the element objects.</li>
<li>the element object data</li>
</ul>
<p>The byte size of the object reference is defined in the trailer. An object
reference of 1 will refer to the first object in the (object) offset table.</p>
<h4 id="dictionary-object"><a class="header" href="#dictionary-object">Dictionary object</a></h4>
<p>The dictionary object consists of:</p>
<ul>
<li>dictionary object marker with number of key and value pairs</li>
<li>array of key references that identify key objects.</li>
<li>array of object references that identify the value objects.</li>
<li>the key/value object data</li>
</ul>
<p>The byte size of the key and object reference is defined in the trailer. A key
and object reference of 1 will refer to the first object in the (object) offset
table.</p>
<h3 id="object-offset-table"><a class="header" href="#object-offset-table">(Object) offset table</a></h3>
<p>The offset table consists of an array of offsets. The trailer defines:</p>
<ul>
<li>The location of the offset table</li>
<li>The offset byte size</li>
<li>The number of offsets in the table</li>
</ul>
<p>The offset values are relative from the start of the file.</p>
<h3 id="binary-plist-trailer"><a class="header" href="#binary-plist-trailer">Binary plist trailer</a></h3>
<p>The binary plist trailer (CFBinaryPlistTrailer) is 32 bytes in size and
consists of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>5 x 1</td><td>0</td><td>Unknown (0-byte values)</td></tr>
<tr><td>5</td><td>1</td><td>0</td><td>Unknown (Sort version)</td></tr>
<tr><td>6</td><td>1</td><td></td><td>Offset byte size</td></tr>
<tr><td>7</td><td>1</td><td></td><td>Key and object reference byte size</td></tr>
<tr><td>8</td><td>8</td><td></td><td>Number of objects</td></tr>
<tr><td>16</td><td>8</td><td></td><td>Root (or top-level) object</td></tr>
<tr><td>24</td><td>8</td><td></td><td>Offset table offset, where the offset is relative to the start of the file</td></tr>
</table></div>
<h2 id="xml-plist-format"><a class="header" href="#xml-plist-format">XML plist format</a></h2>
<p>A XML plist file consists of:</p>
<ul>
<li>optional XML declaration</li>
<li>optional Document Type Definition (DTD)</li>
<li>plist root XML element</li>
<li>key-value pair XML elements</li>
</ul>
<p>For example:</p>
<pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE plist SYSTEM "file://localhost/System/Library/DTDs/PropertyList.dtd"&gt;
&lt;plist version="1.0"&gt;
...
&lt;/plist&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="zlib-compressed-data"><a class="header" href="#zlib-compressed-data">Zlib compressed data</a></h1>
<p>Zlib compression is commonly used in file formats. The zlib compressed data
format, as defined in RFC1950, allows for multiple techniques but only the
Deflate compression method, a variation of LZ77, is used.</p>
<h2 id="overview-15"><a class="header" href="#overview-15">Overview</a></h2>
<p>Zlib compressed data consist of:</p>
<ul>
<li>data header</li>
<li>compressed data</li>
<li>Adler-32 checksum of the uncompressed data</li>
</ul>
<h3 id="characteristics-13"><a class="header" href="#characteristics-13">Characteristics</a></h3>
<div class="table-wrapper"><table><thead><th>Characteristics</th><th>Description</th></thead><tr><td>Byte order</td><td>big-endian</td></tr>
</table></div>
<h2 id="data-header"><a class="header" href="#data-header">Data header</a></h2>
<p>The data header is 2 or 6 bytes in size and consist of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td colspan="4"> <em>The bit values are stored a 8-bit values</em></tr>
<tr><td>0.0</td><td>4 bits</td><td></td><td><a href="zlib.html#compression_method">Compression method</a></td></tr>
<tr><td>0.4</td><td>4 bits</td><td></td><td><a href="zlib.html#compression_information">Compression information</a></td></tr>
<tr><td colspan="4"> <em>Flags</em></tr>
<tr><td>1.0</td><td>5 bits</td><td></td><td>Check bits</td></tr>
<tr><td>1.5</td><td>1 bit</td><td></td><td>Preset dictionary flag</td></tr>
<tr><td>1.6</td><td>2 bits</td><td></td><td><a href="zlib.html#compression_level">Compression level</a>. The compression level is used mainly for re-compression</td></tr>
<tr><td colspan="4"> <em>If the dictionary identifier flag is set</em></tr>
<tr><td>2</td><td>4</td><td></td><td>Preset dictionary identifier, which contains an Adler-32 used to identifier the preset dictionary</td></tr>
<tr><td colspan="4"> <em>Common</em></tr>
<tr><td>...</td><td>...</td><td></td><td>Compressed data</td></tr>
<tr><td>...</td><td>4</td><td></td><td>Checksum, which contains an Adler-32 of the compressed data</td></tr>
</table></div>
<p>The check bits value must be such that when the first 2 bytes are represented
as a 16-bit unsigned integer in big-endian byte order the value is a multiple
of 31, such that:</p>
<pre><code>( ( first x 256 ) + second ) mod 31 = 0
</code></pre>
<h3 id="compression-method"><a class="header" href="#compression-method"><a name="compression_method"></a>Compression method</a></h3>
<div class="table-wrapper"><table><thead><th>Value</th><th>Identifier</th><th>Description</th></thead><tr><td>8</td><td></td><td>Deflate (RFC1951), with a maximum window size of 32 KiB</td></tr>
<tr><td></td><td></td><td></td></tr>
<tr><td>15</td><td></td><td>Reserved for additional header data</td></tr>
</table></div>
<blockquote>
<p>Note that RFC1950 only defines 8 as a valid compression method.</p>
</blockquote>
<h3 id="compression-information"><a class="header" href="#compression-information"><a name="compression_information"></a>Compression information</a></h3>
<p>The value of the compression information is dependent on the compression method.</p>
<h4 id="compression-information---compression-method-8-deflate"><a class="header" href="#compression-information---compression-method-8-deflate">Compression information - compression method 8 (Deflate)</a></h4>
<p>For compression method 8 (Deflate) the compression information contains the
base-2 logarithm of the LZ77 window size minus 8.</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0.0</td><td>4 bits</td><td></td><td>Window size, which consists of a base-2 logarithm (2n), with a maximum value of 7 (32 KiB)</td></tr>
</table></div>
<p>To determine the corresponding window size:</p>
<pre><code>1 &lt;&lt; ( 7 + 8 )
</code></pre>
<p>E.g. a compression information value of 7 indicates a 32768 bytes window size.
Values larger than 7 are not allowed according to RFC1950 and thus the maximum
window size is 32768 bytes.</p>
<h3 id="compression-level-1"><a class="header" href="#compression-level-1"><a name="compression_level"></a>Compression level</a></h3>
<div class="table-wrapper"><table><thead><th>Value</th><th>Identifier</th><th>Description</th></thead><tr><td>0</td><td></td><td>Fastest</td></tr>
<tr><td>1</td><td></td><td>Fast</td></tr>
<tr><td>2</td><td></td><td>Default</td></tr>
<tr><td>3</td><td></td><td>Slowest, maximum compression</td></tr>
</table></div>
<h2 id="compressed-data"><a class="header" href="#compressed-data">Compressed data</a></h2>
<h3 id="deflate-compressed-data"><a class="header" href="#deflate-compressed-data">Deflate compressed data</a></h3>
<p>The deflate compressed data consists of one or more deflate compressed blocks.
Each block consists of:</p>
<ul>
<li>block header</li>
<li>block data</li>
</ul>
<blockquote>
<p>Note that a block can reference uncompressed data that is stored in a previous
block.</p>
</blockquote>
<h4 id="block-header"><a class="header" href="#block-header">Block header</a></h4>
<p>The block header is 3 bits in size and consists of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>1 bit</td><td></td><td>Last block (in stream) marker, where 1 represents the last block and 0 otherwise</td></tr>
<tr><td>0.1</td><td>2 bits</td><td></td><td><a href="zlib.html#deflate_block_types">Block type</a></td></tr>
</table></div>
<h4 id="block-types"><a class="header" href="#block-types"><a name="deflate_block_types"></a>Block types</a></h4>
<div class="table-wrapper"><table><thead><th>Value</th><th>Identifier</th><th>Description</th></thead><tr><td>0</td><td></td><td>Uncompressed (or stored) block</td></tr>
<tr><td>1</td><td></td><td>Fixed Huffman compressed block</td></tr>
<tr><td>2</td><td></td><td>Dynamic Huffman compressed block</td></tr>
<tr><td>3</td><td></td><td>Reserved (not used)</td></tr>
</table></div>
<h4 id="uncompressed-block-data"><a class="header" href="#uncompressed-block-data">Uncompressed block data</a></h4>
<p>The uncompressed block data is of variable size and consists of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0.3</td><td>5 bits</td><td></td><td>Empty values (not used)</td></tr>
<tr><td>1</td><td>2</td><td></td><td>Uncompressed data size</td></tr>
<tr><td>3</td><td>2</td><td></td><td>Copy of uncompressed data size, which contains a 1s complement of the uncompressed data size</td></tr>
<tr><td>5</td><td>...</td><td></td><td>Uncompressed data</td></tr>
</table></div>
<p>The uncompressed data size can range between 0 and 65535 bytes.</p>
<h4 id="huffman-compressed-block-data"><a class="header" href="#huffman-compressed-block-data">Huffman compressed block data</a></h4>
<p>The uncompressed block data is of variable size and consists of:</p>
<ul>
<li>Optional dynamic Huffman table</li>
<li>Encoded bit-stream</li>
<li>End-of-stream (or end-of-block or end-of-data) marker</li>
</ul>
<h5 id="dynamic-huffman-table"><a class="header" href="#dynamic-huffman-table">Dynamic Huffman table</a></h5>
<p>The dynamic Huffman table consists of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0.3</td><td>5 bits</td><td></td><td>Number of literal codes, which is value + 257. The number of literal codes must be smaller than 286</td></tr>
<tr><td>1.0</td><td>5 bits</td><td></td><td>Number of distance codes, which is value + 1. The number of distance codes must be smaller than 30</td></tr>
<tr><td>1.5</td><td>4 bits</td><td></td><td>The number of Huffman codes for the code sizes, which is value + 4</td></tr>
<tr><td>2.1</td><td>...</td><td></td><td>The code sizes</td></tr>
<tr><td>...</td><td>...</td><td></td><td>Huffman encoded stream of the Huffman codes for the literals</td></tr>
<tr><td>...</td><td>...</td><td></td><td>Huffman encoded stream of the Huffman codes for the distances</td></tr>
</table></div>
<p>A single code size value is 3 bits of size. A value of 0 means the code size is
not used in the Huffman encoding of the literal and distance codes.</p>
<p>The codes size values are stored in the following sequence:</p>
<pre><code>16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15
</code></pre>
<p>The first value applies to a code size of 16, the second to 17, etc. Code sizes
that are not stored default to 0.</p>
<p>The code size values are used to construct the code sizes Huffman table. This
must be a complete Huffman table which is used to decode the literal and
distance codes. The corresponding codes size Huffman encoding is defined as:</p>
<div class="table-wrapper"><table><thead><th>Value</th><th>Identifier</th><th>Description</th></thead><tr><td>0 - 15</td><td></td><td>Represents a code size of 0 - 15</td></tr>
<tr><td>16</td><td></td><td>Copy the previous code size 3 - 6 times. The next 2 bits indicate repeat length (0 = 3, ... , 3 = 6), e.g. codes 8, 16 (+2 bits 11), 16 (+2 bits 10) will expand to 12 code lengths of 8 (1 + 6 + 5)</td></tr>
<tr><td>17</td><td></td><td>Repeat a code length of 0 for 3 - 10 times (3 bits of length)</td></tr>
<tr><td>18</td><td></td><td>Repeat a code length of 0 for 11 - 138 times (7 bits of length)</td></tr>
</table></div>
<p>Both the literal and distance Huffman codes are stored Huffman encoded using
the code sizes Huffman table. Code sizes that are not stored default to 0.
The code size for the literal code 256 (end-of-block) should be set and thus
not 0.</p>
<h5 id="encoded-bit-stream"><a class="header" href="#encoded-bit-stream">Encoded bit-stream</a></h5>
<p>The encoded bit-stream is stored in 8-bit integers, where bit values are stored
back-to-front. So that 3 least-significant bits (LSB) would represent a 3-bit
value at the start of the -stream. Note that the LSB of the 3-bit value is the
LSB of the byte value.</p>
<p>Deflate uses a Huffman tree of 288 Huffman codes (or symbols) where the values:</p>
<ul>
<li>0 - 255; represent the literal byte values: 0 - 255</li>
<li>256: represents the end of (compressed) stream (or block)</li>
<li>257 - 285 (combined with extra-bits): represent a (size, offset) tuple (or match length) of 3 - 258 bytes</li>
<li>286, 287: are not used (reserved) and their use is considered illegal although the values are still part of the tree</li>
</ul>
<p>This document refers to this Huffman tree as the literals Huffman tree.</p>
<p>The bits in the encoded bit-stream correspond to values in the literals
Huffman tree. If a symbol is found that represents a compression size and
offset tuple (or match length code) the bits following the literals symbol
contains a distance (Huffman) code. The match length coedes might require
additional (or extra) bits to store the length (or size).</p>
<p>The distances Huffman tree contains space for 32 symbols. See section
<a href="zlib.html#deflate_distance_codes">Distance codes</a>. The distance code might require
additional (or extra) bits to store the distance.</p>
<h5 id="literal-codes"><a class="header" href="#literal-codes">Literal codes</a></h5>
<p>The literal codes consist of:</p>
<div class="table-wrapper"><table><thead><th>Value</th><th>Identifier</th><th>Description</th></thead><tr><td>0x00 – 0xff</td><td></td><td>literal byte values</td></tr>
<tr><td>0x100</td><td></td><td>end-of-block marker</td></tr>
<tr><td colspan="3"> <em>0 additional bits</em></tr>
<tr><td>0x101</td><td></td><td>Size of 3</td></tr>
<tr><td>0x102</td><td></td><td>Size of 4</td></tr>
<tr><td>0x103</td><td></td><td>Size of 5</td></tr>
<tr><td>0x104</td><td></td><td>Size of 6</td></tr>
<tr><td>0x105</td><td></td><td>Size of 7</td></tr>
<tr><td>0x106</td><td></td><td>Size of 8</td></tr>
<tr><td>0x107</td><td></td><td>Size of 9</td></tr>
<tr><td>0x108</td><td></td><td>Size of 10</td></tr>
<tr><td colspan="3"> <em>1 additional bit</em></tr>
<tr><td>0x109</td><td></td><td>Size of 11 to 12</td></tr>
<tr><td>0x10a</td><td></td><td>Size of 13 to 14</td></tr>
<tr><td>0x10b</td><td></td><td>Size of 15 to 16</td></tr>
<tr><td>0x10c</td><td></td><td>Size of 17 to 18</td></tr>
<tr><td colspan="3"> <em>2 additional bits</em></tr>
<tr><td>0x10d</td><td></td><td>Size of 19 to 22</td></tr>
<tr><td>0x10e</td><td></td><td>Size of 23 to 26</td></tr>
<tr><td>0x10f</td><td></td><td>Size of 27 to 30</td></tr>
<tr><td>0x110</td><td></td><td>Size of 31 to 34</td></tr>
<tr><td colspan="3"> <em>3 additional bits</em></tr>
<tr><td>0x111</td><td></td><td>Size of 35 to 42</td></tr>
<tr><td>0x112</td><td></td><td>Size of 43 to 50</td></tr>
<tr><td>0x113</td><td></td><td>Size of 51 to 58</td></tr>
<tr><td>0x114</td><td></td><td>Size of 59 to 66</td></tr>
<tr><td colspan="3"> <em>4 additional bits</em></tr>
<tr><td>0x115</td><td></td><td>Size of 67 to 82</td></tr>
<tr><td>0x116</td><td></td><td>Size of 83 to 98</td></tr>
<tr><td>0x117</td><td></td><td>Size of 99 to 114</td></tr>
<tr><td>0x118</td><td></td><td>Size of 115 to 130</td></tr>
<tr><td colspan="3"> <em>5 additional bits</em></tr>
<tr><td>0x119</td><td></td><td>Size of 131 to 162</td></tr>
<tr><td>0x11a</td><td></td><td>Size of 163 to 194</td></tr>
<tr><td>0x11b</td><td></td><td>Size of 195 to 226</td></tr>
<tr><td>0x11c</td><td></td><td>Size of 227 to 257</td></tr>
<tr><td colspan="3"> <em>0 additional bits</em></tr>
<tr><td>0x11d</td><td></td><td>Size of 258</td></tr>
</table></div>
<h5 id="distance-codes"><a class="header" href="#distance-codes"><a name="deflate_distance_codes"></a>Distance codes</a></h5>
<p>The distance codes consist of:</p>
<div class="table-wrapper"><table><thead><th>Value</th><th>Identifier</th><th>Description</th></thead><tr><td>0</td><td>distance of 1</td><td></td></tr>
<tr><td>1</td><td>distance of 2</td><td></td></tr>
<tr><td>2</td><td>distance of 3</td><td></td></tr>
<tr><td>3</td><td>distance of 4</td><td></td></tr>
<tr><td colspan="3"> <em>1 additional bit</em></tr>
<tr><td>4</td><td>distance of 5 - 6</td><td></td></tr>
<tr><td>5</td><td>distance of 7 - 8</td><td></td></tr>
<tr><td colspan="3"> <em>2 additional bits</em></tr>
<tr><td>6</td><td>distance of 9 - 12</td><td></td></tr>
<tr><td>7</td><td>distance of 13 - 16</td><td></td></tr>
<tr><td colspan="3"> <em>3 additional bits</em></tr>
<tr><td>8</td><td>distance of 17 - 24</td><td></td></tr>
<tr><td>9</td><td>distance of 25 - 32</td><td></td></tr>
<tr><td colspan="3"> <em>4 additional bits</em></tr>
<tr><td>10</td><td>distance of 33 - 48</td><td></td></tr>
<tr><td>11</td><td>distance of 49 - 64</td><td></td></tr>
<tr><td colspan="3"> <em>5 additional bits</em></tr>
<tr><td>12</td><td>distance of 65 - 96</td><td></td></tr>
<tr><td>13</td><td>distance of 97 - 128</td><td></td></tr>
<tr><td colspan="3"> <em>6 additional bits</em></tr>
<tr><td>14</td><td>distance of 129 - 192</td><td></td></tr>
<tr><td>15</td><td>distance of 193 - 256</td><td></td></tr>
<tr><td colspan="3"> <em>7 additional bits</em></tr>
<tr><td>16</td><td>distance of 257 - 384</td><td></td></tr>
<tr><td>17</td><td>distance of 385 - 512</td><td></td></tr>
<tr><td colspan="3"> <em>8 additional bits</em></tr>
<tr><td>18</td><td>distance of 513 - 768</td><td></td></tr>
<tr><td>19</td><td>distance of 769 - 1024</td><td></td></tr>
<tr><td colspan="3"> <em>9 additional bits</em></tr>
<tr><td>20</td><td>distance of 1025 - 1536</td><td></td></tr>
<tr><td>21</td><td>distance of 1537 - 2048</td><td></td></tr>
<tr><td colspan="3"> <em>10 additional bits</em></tr>
<tr><td>22</td><td>distance of 2049 - 3072</td><td></td></tr>
<tr><td>23</td><td>distance of 3073 - 4096</td><td></td></tr>
<tr><td colspan="3"> <em>11 additional bits</em></tr>
<tr><td>24</td><td>distance of 4097 - 6144</td><td></td></tr>
<tr><td>25</td><td>distance of 6145 - 8192</td><td></td></tr>
<tr><td colspan="3"> <em>12 additional bits</em></tr>
<tr><td>26</td><td>distance 8193 - 12288</td><td></td></tr>
<tr><td>27</td><td>distance 12289 - 16384</td><td></td></tr>
<tr><td colspan="3"> <em>13 additional bits</em></tr>
<tr><td>28</td><td>distance 16385 - 24576</td><td></td></tr>
<tr><td>29</td><td>distance 24577 - 32768</td><td></td></tr>
<tr><td colspan="3"> <em>other</em></tr>
<tr><td>30-31</td><td>not used, reserved and illegal but still part of the tree.</td><td></td></tr>
</table></div>
<p>TODO: complete this section</p>
<h4 id="additional-bits"><a class="header" href="#additional-bits">Additional bits</a></h4>
<p>The additional bits are stored in big-endian (MSB first) and indicate the index
into the corresponding array of size values (or base size + additional size).</p>
<div class="table-wrapper"><table><thead><th>Value</th><th>Identifier</th><th>Description</th></thead><tr><td colspan="3"> <em>0 additional bits</em></tr>
<tr><td>0</td><td></td><td>Offset of 1</td></tr>
<tr><td>1</td><td></td><td>Offset of 2</td></tr>
<tr><td>2</td><td></td><td>Offset of 3</td></tr>
<tr><td>3</td><td></td><td>Offset of 4</td></tr>
<tr><td colspan="3"> <em>1 additional bit</em></tr>
<tr><td></td><td></td><td></td></tr>
</table></div>
<p>TODO: complete this section</p>
<h4 id="decompression"><a class="header" href="#decompression">Decompression</a></h4>
<p>The decompression in pseudo code:</p>
<pre><code>if( block_header.type == HUFFMANN_FIXED )
{
    initialize the fixed Huffman trees
}

do
{
    read block_header from input stream

    if( block_header.type == UNCOMPRESSED )
    {
        align with next byte
        read and check block_header.size and block_header.size_copy
        read data of block_header.size
    }
    else
    {
        if( block_header.type == HUFFMANN_DYNAMIC )
        {
            read the dynamic Huffman trees (see subsection below)
        }
        loop (until end of block code recognized)
        {
            decode literal/length value from input stream
            if( value &lt; 256 )
            {
                copy value (literal byte) to output stream
            }
            else if value = end of block (256)
            {
                 break from loop
             }
             else (value = 257..285)
             {
                 decode distance from input stream

                 move backwards distance bytes in the output
                 stream, and copy length bytes from this
                 position to the output stream.
            }
        }
    }
}
while( block_header.last_block_flag == 0 );
</code></pre>
<h3 id="adler-32-checksum"><a class="header" href="#adler-32-checksum">Adler-32 checksum</a></h3>
<p>Zlib provides a highly optimized version of the algorithm provided below.</p>
<pre><code>uint32_t adler32(
          uint8_t *buffer,
          size_t buffer_size,
          uint32_t previous_key )
{
    size_t buffer_iterator = 0;
    uint32_t lower_word    = previous_key &amp; 0xffff;
    uint32_t upper_word    = ( previous_key &gt;&gt; 16 ) &amp; 0xffff;

    for( buffer_iterator = 0;
         buffer_iterator &lt; buffer_size;
         buffer_iterator++ )
    {
        lower_word += buffer[ buffer_iterator ];
        upper_word += lower_word;

        if( ( buffer_iterator != 0 )
         &amp;&amp; ( ( buffer_iterator % 0x15b0 == 0 )
          ||  ( buffer_iterator == buffer_size - 1 ) ) )
        {
            lower_word = lower_word % 0xfff1;
            upper_word = upper_word % 0xfff1;
        }
    }
    return( ( upper_word &lt;&lt; 16 ) | lower_word );
}
</code></pre>
<h2 id="references-8"><a class="header" href="#references-8">References</a></h2>
<ul>
<li><a href="http://www.ietf.org/rfc/rfc1950.txt">RFC1950 - ZLIB Compressed Data Format Specification</a></li>
<li><a href="http://www.ietf.org/rfc/rfc1951.txt">RFC1951 - DEFLATE Compressed Data Format Specification</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
