<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>QEMU Copy-On-Write (QCOW) - Keramics data format specifications</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="custom.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Keramics data format specifications</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="qemu-copy-on-write-qcow-image-file-format"><a class="header" href="#qemu-copy-on-write-qcow-image-file-format">QEMU Copy-On-Write (QCOW) image file format</a></h1>
<p>The QEMU Copy-On-Write (QCOW) image file format is used by the QEMU Open Source
Process Emulator to store disk images (storage media)</p>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>A QCOW image file consists of:</p>
<ul>
<li>the file header
<ul>
<li>optional file header extensions</li>
</ul>
</li>
<li>the level 1 table (cluster aligned)</li>
<li>the reference count table (cluster aligned)</li>
<li>reference count blocks</li>
<li>snapshot headers (8-byte aligned on cluster boundary)</li>
<li>clusters containing:
<ul>
<li>level 2 tables</li>
<li>storage media data</li>
</ul>
</li>
</ul>
<p>The storage media data is stored in clusters. Each cluster is a multitude of
512 bytes. The level 1 (L1) table contains level 1 reference of level 2 (L2)
tables. The level 2 tables contain level 2 references of the storage media
clusters.</p>
<p>There are multiple versions of the QCOW image file format. QCOW (version 1)
and QCOW2 (version 2 and later) are sometimes considered even as separate image
formats. Version 3 is considered as an extended version of QCOW2.</p>
<h3 id="characteristics"><a class="header" href="#characteristics">Characteristics</a></h3>
<div class="table-wrapper"><table><thead><th>Characteristics</th><th>Description</th></thead><tr><td>Byte order</td><td>big-endian in most cases, note that some values are in little-endian</td></tr>
<tr><td>Date and time values</td><td>Number of seconds since Jan 1, 1970 00:00:00 UTC (POSIX epoch)</td></tr>
<tr><td>Character strings</td><td>UTF-8</td></tr>
</table></div>
<blockquote>
<p>Note that this docuement assumes that character strings are stored in UTF-8</p>
</blockquote>
<p>The number of bytes per sector is 512.</p>
<h3 id="encryption"><a class="header" href="#encryption">Encryption</a></h3>
<p>The QCOW image format can encrypted the media data stored in the image format.
Currently supported encryption methods are:</p>
<ul>
<li>AES-CBC 128-bit</li>
<li>Linux Unified Key Setup (LUKS)</li>
</ul>
<p>If no encryption is used the encryption method in the file header is set to
none (0).</p>
<blockquote>
<p>Note it is currently unknown if the format supports compression and encryption
at the same time. It does not appear to be supported by qemu-img.</p>
</blockquote>
<h4 id="aes-cbc-128-bit"><a class="header" href="#aes-cbc-128-bit">AES-CBC 128-bit</a></h4>
<p>Both encryption and decryption use:</p>
<ul>
<li>AES-CBC with a 128-bits key decryption of sector data</li>
</ul>
<p>The key is direct copy of the first 16 characters of a user provided (narrow
character) password. If the password is smaller than 16 characters. The
remaining key data is set to 0-byte values.</p>
<blockquote>
<p>Note that it is currently unclear which character sets are allowed and how
characters outside the 7-bit ASCII set should be handled.</p>
</blockquote>
<p>The initialization vector of the AES-CBC is using media data sector number
(relative to the start of the disk) in little-endian format as the first 64
bits of the 128 bit initialization vector. The remaining initialization vector
data is set to 0-byte values. The first sector number is 0 and the bytes per
sector are 512.</p>
<h4 id="linux-unified-key-setup-luks"><a class="header" href="#linux-unified-key-setup-luks">Linux Unified Key Setup (LUKS)</a></h4>
<p>TODO: complete section</p>
<h2 id="file-header"><a class="header" href="#file-header">File header</a></h2>
<h3 id="file-header--version-1"><a class="header" href="#file-header--version-1">File header – version 1</a></h3>
<p>The file header - version 1 is 48 bytes in size and consist of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>4</td><td>"QFI\xfb" or "\x51\x46\x49\xfb"</td><td>The signature (or magic identifier)</td></tr>
<tr><td>4</td><td>4</td><td>1</td><td>Format version</td></tr>
<tr><td>8</td><td>8</td><td></td><td>Backing file name offset</td></tr>
<tr><td>16</td><td>4</td><td></td><td>Backing file name size</td></tr>
<tr><td>20</td><td>4</td><td></td><td>Modification date and time, which contains a POSIX timestamp</td></tr>
<tr><td>24</td><td>8</td><td></td><td>Storage media size</td></tr>
<tr><td>32</td><td>1</td><td></td><td>Number of cluster block bits</td></tr>
<tr><td>33</td><td>1</td><td></td><td>Number of level 2 table bits</td></tr>
<tr><td>34</td><td>2</td><td></td><td>[yellow-background]<em>Unknown (empty values)</em></td></tr>
<tr><td>36</td><td>4</td><td></td><td>Encryption method</td></tr>
<tr><td>40</td><td>8</td><td></td><td>Level 1 table offset</td></tr>
</table></div>
<p>The cluster block size is calculated as:</p>
<pre><code>cluster block size = 1 &lt;&lt; number of cluster block bits
</code></pre>
<p>The level table 2 size is calculated as:</p>
<pre><code>level table 2 size = ( 1 &lt;&lt; number of level 2 table bits ) * 8
</code></pre>
<p>The level 1 table size is calculated as:</p>
<pre><code>level 1 table size = cluster block size * ( 1 &lt;&lt; number of level 2 table bits )

if( media size % level 1 table size != 0 )
{
    level 1 table size = ( media size / level 1 table size ) + 1
}
else
{
    level 1 table size = media size / level 1 table size
}
level 1 table size *= 8
</code></pre>
<p>The backing file name is set in snapshot image files and is normally stored
after the file header.</p>
<h3 id="file-header--version-2"><a class="header" href="#file-header--version-2">File header – version 2</a></h3>
<p>The file header - version 2 is 72 bytes in size and consist of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>4</td><td>"QFI\xfb" or "\x51\x46\x49\xfb"</td><td>The signature (or magic identifier)</td></tr>
<tr><td>4</td><td>4</td><td>2</td><td>Format version</td></tr>
<tr><td>8</td><td>8</td><td></td><td>Backing file name offset</td></tr>
<tr><td>16</td><td>4</td><td></td><td>Backing file name size</td></tr>
<tr><td>20</td><td>4</td><td></td><td>Number of cluster block bits</td></tr>
<tr><td>24</td><td>8</td><td></td><td>Storage media size</td></tr>
<tr><td>32</td><td>4</td><td></td><td>Encryption method</td></tr>
<tr><td>36</td><td>4</td><td></td><td>Number of level 1 table references</td></tr>
<tr><td>40</td><td>8</td><td></td><td>Level 1 table offset</td></tr>
<tr><td>48</td><td>8</td><td></td><td>Reference count table offset</td></tr>
<tr><td>56</td><td>4</td><td></td><td>Reference count table clusters</td></tr>
<tr><td>60</td><td>4</td><td></td><td>Number of snapshots</td></tr>
<tr><td>64</td><td>8</td><td></td><td>Snapshots offset</td></tr>
</table></div>
<p>The cluster block size is calculated as:</p>
<pre><code>cluster block size = 1 &lt;&lt; number of cluster block bits
</code></pre>
<p>The number of level 2 table bits is calculated as:</p>
<pre><code>number of level 2 table bits = number of cluster block bits - 3
</code></pre>
<p>The level table 2 size is calculated as:</p>
<pre><code>level table 2 size = ( 1 &lt;&lt; number of level 2 table bits ) * 8
</code></pre>
<p>The level 1 table size is calculated as:</p>
<pre><code>level 1 table size = number of level 1 table references * 8
</code></pre>
<p>The backing file name is set in snapshot image files and is normally stored
after the file header.</p>
<h3 id="file-header--version-3"><a class="header" href="#file-header--version-3">File header – version 3</a></h3>
<p>The file header - version 3 is 104 or 112 bytes in size and consist of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>4</td><td>"QFI\xfb" or "\x51\x46\x49\xfb"</td><td>The signature (or magic identifier)</td></tr>
<tr><td>4</td><td>4</td><td>3</td><td>Format version</td></tr>
<tr><td>8</td><td>8</td><td></td><td>Backing file name offset</td></tr>
<tr><td>16</td><td>4</td><td></td><td>Backing file name size</td></tr>
<tr><td>20</td><td>4</td><td></td><td>Number of cluster block bits</td></tr>
<tr><td>24</td><td>8</td><td></td><td>Storage media size</td></tr>
<tr><td>32</td><td>4</td><td></td><td>Encryption method</td></tr>
<tr><td>36</td><td>4</td><td></td><td>Number of level 1 table references</td></tr>
<tr><td>40</td><td>8</td><td></td><td>Level 1 table offset</td></tr>
<tr><td>48</td><td>8</td><td></td><td>Reference count table offset</td></tr>
<tr><td>56</td><td>4</td><td></td><td>Reference count table clusters</td></tr>
<tr><td>60</td><td>4</td><td></td><td>Number of snapshots</td></tr>
<tr><td>64</td><td>8</td><td></td><td>Snapshots offset</td></tr>
<tr><td>72</td><td>8</td><td></td><td>Incompatible feature flags</td></tr>
<tr><td>80</td><td>8</td><td></td><td>Compatible feature flags</td></tr>
<tr><td>88</td><td>8</td><td></td><td>Auto-clear feature flags</td></tr>
<tr><td>96</td><td>4</td><td></td><td>Reference count order</td></tr>
<tr><td>100</td><td>4</td><td>104 or 112</td><td>File header size, which contains the size of the file header, this value does not include the size of the file header extensions</td></tr>
<tr><td colspan="4"> <em>If file header size equals 112</em></tr>
<tr><td>104</td><td>1</td><td></td><td>Compression method</td></tr>
<tr><td>105</td><td>7</td><td></td><td>Unknown (padding)</td></tr>
</table></div>
<p>The cluster block size is calculated as:</p>
<pre><code>cluster block size = 1 &lt;&lt; number of cluster block bits
</code></pre>
<p>The number of level 2 table bits is calculated as:</p>
<pre><code>number of level 2 table bits = number of cluster block bits - 3
</code></pre>
<p>The level table 2 size is calculated as:</p>
<pre><code>level table 2 size = ( 1 &lt;&lt; number of level 2 table bits ) * 8
</code></pre>
<p>The level 1 table size is calculated as:</p>
<pre><code>level 1 table size = number of level 1 table references * 8
</code></pre>
<p>The backing file name is set in snapshot image files and is normally stored
after the file header.</p>
<h3 id="encryption-methods"><a class="header" href="#encryption-methods">Encryption methods</a></h3>
<div class="table-wrapper"><table><thead><th>Value</th><th>Identifier</th><th>Description</th></thead><tr><td>0</td><td>QCOW_CRYPT_NONE</td><td>No encryption</td></tr>
<tr><td>1</td><td>QCOW_CRYPT_AES</td><td>AES-CBC 128-bits encryption</td></tr>
<tr><td>2</td><td>QCOW_CRYPT_LUKS</td><td>Linux Unified Key Setup (LUKS) encryption</td></tr>
</table></div>
<h3 id="incompatible-feature-flags"><a class="header" href="#incompatible-feature-flags">Incompatible feature flags</a></h3>
<div class="table-wrapper"><table><thead><th>Value</th><th>Identifier</th><th>Description</th></thead><tr><td>0x00000001</td><td>QCOW2_INCOMPAT_DIRTY</td><td></td></tr>
<tr><td>0x00000002</td><td>QCOW2_INCOMPAT_CORRUPT</td><td></td></tr>
<tr><td>0x00000004</td><td>QCOW2_INCOMPAT_DATA_FILE</td><td></td></tr>
<tr><td>0x00000008</td><td>QCOW2_INCOMPAT_COMPRESSION</td><td></td></tr>
<tr><td>0x00000010</td><td>QCOW2_INCOMPAT_EXTL2</td><td></td></tr>
</table></div>
<h3 id="compatible-feature-flags"><a class="header" href="#compatible-feature-flags">Compatible feature flags</a></h3>
<div class="table-wrapper"><table><thead><th>Value</th><th>Identifier</th><th>Description</th></thead><tr><td>0x00000001</td><td>QCOW2_COMPAT_LAZY_REFCOUNTS</td><td></td></tr>
</table></div>
<h3 id="auto-clear-feature-flags"><a class="header" href="#auto-clear-feature-flags">Auto-clear feature flags</a></h3>
<div class="table-wrapper"><table><thead><th>Value</th><th>Identifier</th><th>Description</th></thead><tr><td>0x00000001</td><td>QCOW2_AUTOCLEAR_BITMAPS</td><td></td></tr>
<tr><td>0x00000002</td><td>QCOW2_AUTOCLEAR_DATA_FILE_RAW</td><td></td></tr>
</table></div>
<h3 id="compression-methods"><a class="header" href="#compression-methods">Compression methods</a></h3>
<div class="table-wrapper"><table><thead><th>Value</th><th>Identifier</th><th>Description</th></thead><tr><td>0</td><td></td><td>ZLIB compression</td></tr>
</table></div>
<h3 id="file-header-extensions"><a class="header" href="#file-header-extensions">File header extensions</a></h3>
<p>A file header extension consist of:</p>
<ul>
<li>file header extension header</li>
<li>file header extension data</li>
</ul>
<h4 id="file-header-extension-header"><a class="header" href="#file-header-extension-header">File header extension header</a></h4>
<p>The file header extension header is 8 bytes in size and consist of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>4</td><td></td><td>The extension type (signature)</td></tr>
<tr><td>4</td><td>4</td><td></td><td>The extension data size</td></tr>
</table></div>
<h4 id="file-header-extension-types"><a class="header" href="#file-header-extension-types">File header extension types</a></h4>
<div class="table-wrapper"><table><thead><th>Value</th><th>Identifier</th><th>Description</th></thead><tr><td>0x0537be77</td><td>QCOW2_EXT_MAGIC_CRYPTO_HEADER</td><td>Crypto header</td></tr>
<tr><td>0x23852875</td><td>QCOW2_EXT_MAGIC_BITMAPS</td><td>Bitmaps</td></tr>
<tr><td>0x44415441 or "DATA"</td><td>QCOW2_EXT_MAGIC_DATA_FILE</td><td>Data-file</td></tr>
<tr><td>0x6803f857</td><td>QCOW2_EXT_MAGIC_FEATURE_TABLE</td><td>Feature table</td></tr>
<tr><td>0xe2792aca</td><td>QCOW2_EXT_MAGIC_BACKING_FORMAT</td><td>Backing format</td></tr>
</table></div>
<h4 id="backing-format-file-header-extension"><a class="header" href="#backing-format-file-header-extension">Backing format file header extension</a></h4>
<p>The backing format file header extension header is of variable size and consist
of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>...</td><td></td><td>Backing format identifier, which contains an UTF-8 string without end-of-string character</td></tr>
</table></div>
<h4 id="bitmaps-file-header-extension"><a class="header" href="#bitmaps-file-header-extension">Bitmaps file header extension</a></h4>
<p>TODO: complete section</p>
<h4 id="crypto-header-file-header-extension"><a class="header" href="#crypto-header-file-header-extension">Crypto header file header extension</a></h4>
<p>The crypto header file header extension header is 16 bytes in size and consist
of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>8</td><td></td><td>The crypto data offset</td></tr>
<tr><td>8</td><td>8</td><td></td><td>The crypto data size</td></tr>
</table></div>
<h4 id="data-file-file-header-extension"><a class="header" href="#data-file-file-header-extension">Data-file file header extension</a></h4>
<p>The data-file file header extension header is of variable size and consist of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>...</td><td></td><td>Data-file filename, which contains an UTF-8 string without end-of-string character</td></tr>
</table></div>
<h4 id="feature-table-file-header-extension"><a class="header" href="#feature-table-file-header-extension">Feature table file header extension</a></h4>
<p>TODO: complete section</p>
<h2 id="level-1-table"><a class="header" href="#level-1-table">Level 1 table</a></h2>
<p>The level 1 table contains level 2 table references.</p>
<p>A reference value of 0 represents unused or unallocated and is considered as
sparse or stored in a corresponding backing file.</p>
<h3 id="level-2-table-reference--version-1"><a class="header" href="#level-2-table-reference--version-1">Level 2 table reference – version 1</a></h3>
<p>The level 2 table reference is 8-bytes in size and consists of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0.0</td><td>63 bits</td><td></td><td>Level 2 table offset, which contains an offset relative from the start of the file</td></tr>
<tr><td>7.7</td><td>1 bit</td><td>QCOW_OFLAG_COMPRESSED</td><td>Is compressed flag</td></tr>
</table></div>
<h3 id="level-2-table-reference--version-2-or-3"><a class="header" href="#level-2-table-reference--version-2-or-3">Level 2 table reference – version 2 or 3</a></h3>
<p>The level 2 table reference is 8-bytes in size and consists of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0.0</td><td>62 bits</td><td></td><td>Level 2 table offset, which contains an offset relative from the start of the file</td></tr>
<tr><td>7.6</td><td>1 bit</td><td>QCOW_OFLAG_COMPRESSED</td><td>Is compressed flag</td></tr>
<tr><td>7.7</td><td>1 bit</td><td>QCOW_OFLAG_COPIED</td><td>Is copied flag</td></tr>
</table></div>
<p>The is copied flag indicates that the reference count of the corresponding
level 2 table is exactly one.</p>
<h2 id="level-2-table"><a class="header" href="#level-2-table">Level 2 table</a></h2>
<p>The level 2 table contains cluster block references.</p>
<p>The level 2 table size is calculated as:</p>
<pre><code>level 2 table size = ( 1 &lt;&lt; number of level 2 table bits ) * 8
</code></pre>
<p>A reference value of 0 represents unused or unallocated and is considered as
sparse or stored in a corresponding backing file.</p>
<h3 id="cluster-block-reference--version-1"><a class="header" href="#cluster-block-reference--version-1">Cluster block reference – version 1</a></h3>
<p>The cluster block reference - version 1 is 8-bytes in size and consists of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0.0</td><td>63 bits</td><td></td><td>Cluster block offset, which contains an offset relative to the start of the cluster block</td></tr>
<tr><td>7.7</td><td>1 bit</td><td>QCOW_OFLAG_COMPRESSED</td><td>Is compressed flag</td></tr>
</table></div>
<h3 id="cluster-block-reference--version-2-or-3"><a class="header" href="#cluster-block-reference--version-2-or-3">Cluster block reference – version 2 or 3</a></h3>
<p>The cluster block reference - version 2 or 3 is 8-bytes in size and consists of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0.0</td><td>62 bits</td><td></td><td>Cluster block offset, which contains an offset relative to the start of the cluster block</td></tr>
<tr><td>7.6</td><td>1 bit</td><td>QCOW_OFLAG_COMPRESSED</td><td>Is compressed flag</td></tr>
<tr><td>7.7</td><td>1 bit</td><td>QCOW_OFLAG_COPIED</td><td>Is copied flag</td></tr>
</table></div>
<p>The is copied flag indicates that the reference count of the corresponding
cluster block is exactly one.</p>
<h2 id="reference-count-table"><a class="header" href="#reference-count-table">Reference count table</a></h2>
<p>The cluster data blocks are referenced counted. For every cluster data block a
16-bit reference count is stored in the reference count table.</p>
<p>The reference count table is stored in cluster block sizes. The file header
contains the number of blocks (or reference count table clusters).</p>
<p>TODO: complete section</p>
<h3 id="notes"><a class="header" href="#notes">Notes</a></h3>
<pre><code>reference count cluster block offset = cluster data block offset /
reference count table offset = cluster data block /

In order to obtain the reference count of a given cluster, you split the
cluster offset into a refcount table offset and refcount block offset.

Since a refcount block is a single cluster of 2 byte entries, the lower
cluster_size - 1 bits is used as the block offset and the rest of the bits are
used as the table offset.

One optimization is that if any cluster pointed to by an L1 or L2 table entry
has a refcount exactly equal to one, the most significant bit of the L1/L2
entry is set as a "copied" flag. This indicates that no snapshots are using
this cluster and it can be immediately written to without having to make a copy
for any snapshots referencing it.
</code></pre>
<h2 id="cluster-data-block"><a class="header" href="#cluster-data-block">Cluster data block</a></h2>
<p>To retrieve a cluster data block corresponding a certain storage media offset:</p>
<p>Determine the level 1 table index from the offset:</p>
<pre><code>level 1 table index bit shift = number of cluster block bits + number of level 2 table bits
</code></pre>
<p>For version 1:</p>
<pre><code>level 1 table index = ( offset &amp; 0x7fffffffffffffffULL ) &gt;&gt; level 1 table index bit shift
</code></pre>
<p>For version 2 and 3:</p>
<pre><code>level 1 table index = ( offset &amp; 0x3fffffffffffffffULL ) &gt;&gt; level 1 table index bit shift
</code></pre>
<p>Retrieve the level 2 table offset from the level 1 table. If the level table 2
offset is 0 and the image has a backing file the cluster data block is stored
in the backing file otherwise the cluster block is considered sparse.</p>
<p>Read the corresponding level 2 table.</p>
<p>Determine the level 2 table index from the offset:</p>
<pre><code>level 2 table index bit mask = ~( 0xffffffffffffffffULL &lt;&lt; number of level 2 table bits )
</code></pre>
<pre><code>level 2 table index = ( offset &gt;&gt; number of cluster block bits ) &gt;&gt; level 2 table index bit mask
</code></pre>
<p>Retrieve the cluster block offset from the level 2 table. If the cluster block
offset is 0 and the image has a backing file the cluster data block is stored
in the backing file otherwise the cluster block is considered sparse.</p>
<h3 id="uncompressed-cluster-data-block"><a class="header" href="#uncompressed-cluster-data-block">Uncompressed cluster data block</a></h3>
<p>If the is compressed flag (QCOW_OFLAG_COMPRESSED) is not set:</p>
<pre><code>cluster block bit mask = ~( 0xffffffffffffffffULL &lt;&lt; number of cluster block bits )
</code></pre>
<pre><code>cluster block data offset = ( offset &amp; cluster block bit mask ) + cluster block offset
</code></pre>
<p>Note that in version 2 or 3 the last cluster block in the file can be smaller than
the cluster block size defined by the number of cluster block bits in the file
header. This does not seem to be the case for version 1.</p>
<h3 id="compressed-cluster-data-block"><a class="header" href="#compressed-cluster-data-block">Compressed cluster data block</a></h3>
<p>If the is compressed flag (QCOW_OFLAG_COMPRESSED) is set the cluster block data
is stored using the compression method defined by the file header or DEFLATE by
default.</p>
<p>Multiple compressed cluster data blocks are stored together in cluster block
sizes. The compressed cluster data blocks are sector (512 bytes) aligned.</p>
<p>The compressed data uses a DEFLATE (inflate) window bits value of -12</p>
<h4 id="compressed-chunk-data-block--version-1"><a class="header" href="#compressed-chunk-data-block--version-1">Compressed chunk data block – version 1</a></h4>
<pre><code>compressed size bit shift = 63 - number of cluster block bits
</code></pre>
<pre><code>compressed block size = ( ( cluster block offset &amp; 0x7fffffffffffffffULL ) &gt;&gt; compressed size bit shift
</code></pre>
<pre><code>compressed block offset &amp;= ~( 0xffffffffffffffffULL &lt;&lt; compressed size bit shift )
</code></pre>
<h4 id="compressed-chunk-data-block--version-2-or-3"><a class="header" href="#compressed-chunk-data-block--version-2-or-3">Compressed chunk data block – version 2 or 3</a></h4>
<pre><code>compressed size bit shift = 62 - ( number of cluster block bits – 8 )
</code></pre>
<p>According to "the QCOW2 Image Format" the compressed block size is calculated
as following:</p>
<pre><code>compressed block size = ( ( ( cluster block offset &amp; 0x3fffffffffffffffULL ) &gt;&gt; compressed size bit shift ) + 1 ) * 512
</code></pre>
<p>Since the compressed block size is stored in 512 byte sectors this value does
not contain the exact byte size of the compressed cluster block data. It
sometimes lacks the size of the last partially filled sector and one sector
should be added if possible within the bounds of the cluster blocks size and
the file size.</p>
<pre><code>cluster block offset &amp;= ~( 0xffffffffffffffffULL &lt;&lt; compressed size bit shift )
</code></pre>
<h2 id="snapshots"><a class="header" href="#snapshots">Snapshots</a></h2>
<p>As of version 1 QCOW can use the backing file name in the file header to point
to a backing file (or parent image) that contains the snapshot image where the
current image only contains the modifications. Version 2 adds support to store
snapshot inside the image.</p>
<h3 id="snapshot-header---version-2-or-3"><a class="header" href="#snapshot-header---version-2-or-3">Snapshot header - version 2 or 3</a></h3>
<p>An in-image snapshot is created by adding a snapshot header, copying the L1
table and incrementing the reference counts of all L2 tables and data clusters
referenced by the L1 table.</p>
<p>The snapshot header is of variable size and consists of:</p>
<div class="table-wrapper"><table><thead><th>Offset</th><th>Size</th><th>Value</th><th>Description</th></thead><tr><td>0</td><td>8</td><td></td><td>Level 1 table offset</td></tr>
<tr><td>8</td><td>4</td><td></td><td>Level 1 size</td></tr>
<tr><td>12</td><td>2</td><td></td><td>Identifier string size</td></tr>
<tr><td>14</td><td>2</td><td></td><td>Name size</td></tr>
<tr><td>16</td><td>4</td><td></td><td>Date in seconds</td></tr>
<tr><td>20</td><td>4</td><td></td><td>Date in nano seconds</td></tr>
<tr><td>24</td><td>8</td><td></td><td>VM clock in nano seconds</td></tr>
<tr><td>32</td><td>4</td><td></td><td>VM state size</td></tr>
<tr><td>36</td><td>4</td><td></td><td>Extra data size</td></tr>
<tr><td>40</td><td>...</td><td></td><td>Extra data</td></tr>
<tr><td>...</td><td>...</td><td></td><td>Identifier string size</td></tr>
<tr><td>...</td><td>...</td><td></td><td>Name</td></tr>
</table></div>
<p>TODO: complete section</p>
<h2 id="references"><a class="header" href="#references">References</a></h2>
<ul>
<li><a href="https://web.archive.org/web/20201006212750/https://people.gnome.org/~markmc/qcow-image-format-version-1.html">The QCOW Image Format</a>, by Mark McLoughlin</li>
<li><a href="https://web.archive.org/web/20121004073848/http://people.gnome.org/~markmc/qcow-image-format.html">The QCOW2 Image Format</a>, by Mark McLoughlin</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="sparseimage.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="udif.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="sparseimage.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="udif.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
